
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080003d9 	.word	0x080003d9
 8000008:	080003db 	.word	0x080003db
 800000c:	080003db 	.word	0x080003db
 8000010:	080003db 	.word	0x080003db
 8000014:	080003db 	.word	0x080003db
 8000018:	080003db 	.word	0x080003db
 800001c:	080003db 	.word	0x080003db
 8000020:	080003db 	.word	0x080003db
 8000024:	080003db 	.word	0x080003db
 8000028:	080003db 	.word	0x080003db
 800002c:	08005441 	.word	0x08005441
 8000030:	080003db 	.word	0x080003db
 8000034:	080003db 	.word	0x080003db
 8000038:	080003db 	.word	0x080003db
 800003c:	080003db 	.word	0x080003db
 8000040:	080003db 	.word	0x080003db
 8000044:	080003db 	.word	0x080003db
 8000048:	080003db 	.word	0x080003db
 800004c:	080003db 	.word	0x080003db
 8000050:	080003db 	.word	0x080003db
 8000054:	080003db 	.word	0x080003db
 8000058:	080036b1 	.word	0x080036b1
 800005c:	08003741 	.word	0x08003741
 8000060:	080037d1 	.word	0x080037d1
 8000064:	08003861 	.word	0x08003861
 8000068:	080038f1 	.word	0x080038f1
 800006c:	08003e31 	.word	0x08003e31
 8000070:	08003ec1 	.word	0x08003ec1
 8000074:	08003f51 	.word	0x08003f51
 8000078:	08003fe1 	.word	0x08003fe1
 800007c:	08004071 	.word	0x08004071
 8000080:	08004101 	.word	0x08004101
 8000084:	08004191 	.word	0x08004191
 8000088:	080003db 	.word	0x080003db
 800008c:	080003db 	.word	0x080003db
 8000090:	080003db 	.word	0x080003db
 8000094:	080003db 	.word	0x080003db
 8000098:	080003db 	.word	0x080003db
 800009c:	08003981 	.word	0x08003981
 80000a0:	080003db 	.word	0x080003db
 80000a4:	080003db 	.word	0x080003db
 80000a8:	080003db 	.word	0x080003db
 80000ac:	080003db 	.word	0x080003db
 80000b0:	08003c11 	.word	0x08003c11
 80000b4:	080003db 	.word	0x080003db
 80000b8:	080003db 	.word	0x080003db
 80000bc:	080003db 	.word	0x080003db
 80000c0:	080003db 	.word	0x080003db
 80000c4:	080003db 	.word	0x080003db
 80000c8:	080003db 	.word	0x080003db
 80000cc:	080003db 	.word	0x080003db
 80000d0:	080003db 	.word	0x080003db
 80000d4:	08003b11 	.word	0x08003b11
 80000d8:	080003db 	.word	0x080003db
 80000dc:	080003db 	.word	0x080003db
 80000e0:	08003a41 	.word	0x08003a41
 80000e4:	080003db 	.word	0x080003db
 80000e8:	080003db 	.word	0x080003db
 80000ec:	080003db 	.word	0x080003db
 80000f0:	080003db 	.word	0x080003db
 80000f4:	080003db 	.word	0x080003db
 80000f8:	080003db 	.word	0x080003db
 80000fc:	08004221 	.word	0x08004221
 8000100:	080003db 	.word	0x080003db
 8000104:	080003db 	.word	0x080003db
 8000108:	08003d71 	.word	0x08003d71
 800010c:	080003db 	.word	0x080003db
 8000110:	080003db 	.word	0x080003db
 8000114:	080003db 	.word	0x080003db
 8000118:	080003db 	.word	0x080003db
 800011c:	080003db 	.word	0x080003db
 8000120:	080042b1 	.word	0x080042b1
 8000124:	08004341 	.word	0x08004341
 8000128:	080043d1 	.word	0x080043d1
 800012c:	08004461 	.word	0x08004461
 8000130:	080044f1 	.word	0x080044f1
 8000134:	080003db 	.word	0x080003db
 8000138:	080003db 	.word	0x080003db
 800013c:	080003db 	.word	0x080003db
 8000140:	080003db 	.word	0x080003db
 8000144:	080003db 	.word	0x080003db
 8000148:	080003db 	.word	0x080003db
 800014c:	080003db 	.word	0x080003db
 8000150:	08004581 	.word	0x08004581
 8000154:	08004611 	.word	0x08004611
 8000158:	080046a1 	.word	0x080046a1
 800015c:	080003db 	.word	0x080003db
 8000160:	080003db 	.word	0x080003db
 8000164:	080003db 	.word	0x080003db
 8000168:	080003db 	.word	0x080003db
 800016c:	080003db 	.word	0x080003db
 8000170:	080003db 	.word	0x080003db
 8000174:	08004731 	.word	0x08004731
 8000178:	080003db 	.word	0x080003db
 800017c:	080003db 	.word	0x080003db
 8000180:	080003db 	.word	0x080003db
 8000184:	080003db 	.word	0x080003db
 8000188:	080003db 	.word	0x080003db
 800018c:	080003db 	.word	0x080003db
 8000190:	080003db 	.word	0x080003db
 8000194:	080003db 	.word	0x080003db
 8000198:	080003db 	.word	0x080003db
 800019c:	080003db 	.word	0x080003db
 80001a0:	080003db 	.word	0x080003db
 80001a4:	080003db 	.word	0x080003db
 80001a8:	080003db 	.word	0x080003db
 80001ac:	080003db 	.word	0x080003db
 80001b0:	080003db 	.word	0x080003db
 80001b4:	080003db 	.word	0x080003db
 80001b8:	080003db 	.word	0x080003db
 80001bc:	080003db 	.word	0x080003db
 80001c0:	080003db 	.word	0x080003db
 80001c4:	080003db 	.word	0x080003db
 80001c8:	080003db 	.word	0x080003db
 80001cc:	080003db 	.word	0x080003db
 80001d0:	080003db 	.word	0x080003db
 80001d4:	080003db 	.word	0x080003db
 80001d8:	080003db 	.word	0x080003db
 80001dc:	080003db 	.word	0x080003db
 80001e0:	080003db 	.word	0x080003db
 80001e4:	080003db 	.word	0x080003db
 80001e8:	080003db 	.word	0x080003db
 80001ec:	080003db 	.word	0x080003db
 80001f0:	080003db 	.word	0x080003db
 80001f4:	080003db 	.word	0x080003db
 80001f8:	080003db 	.word	0x080003db
 80001fc:	080003db 	.word	0x080003db
 8000200:	080003db 	.word	0x080003db
 8000204:	080003db 	.word	0x080003db
 8000208:	080003db 	.word	0x080003db
 800020c:	080003db 	.word	0x080003db
 8000210:	080003db 	.word	0x080003db
 8000214:	080003db 	.word	0x080003db
 8000218:	080003db 	.word	0x080003db
 800021c:	080003db 	.word	0x080003db
 8000220:	080003db 	.word	0x080003db
 8000224:	080003db 	.word	0x080003db
 8000228:	080003db 	.word	0x080003db
 800022c:	080003db 	.word	0x080003db
 8000230:	080003db 	.word	0x080003db
 8000234:	080003db 	.word	0x080003db
 8000238:	080003db 	.word	0x080003db
 800023c:	080003db 	.word	0x080003db
 8000240:	080003db 	.word	0x080003db
 8000244:	080003db 	.word	0x080003db
 8000248:	080003db 	.word	0x080003db
 800024c:	080003db 	.word	0x080003db
 8000250:	080003db 	.word	0x080003db
 8000254:	080003db 	.word	0x080003db
 8000258:	080003db 	.word	0x080003db
 800025c:	080003db 	.word	0x080003db
 8000260:	080003db 	.word	0x080003db
 8000264:	080003db 	.word	0x080003db
 8000268:	080003db 	.word	0x080003db
 800026c:	080003db 	.word	0x080003db
 8000270:	080003db 	.word	0x080003db
 8000274:	080003db 	.word	0x080003db
 8000278:	080003db 	.word	0x080003db
 800027c:	080003db 	.word	0x080003db
 8000280:	080003db 	.word	0x080003db
 8000284:	080003db 	.word	0x080003db
 8000288:	080003db 	.word	0x080003db
 800028c:	080003db 	.word	0x080003db
 8000290:	080003db 	.word	0x080003db
 8000294:	080003db 	.word	0x080003db
 8000298:	080003db 	.word	0x080003db
 800029c:	080003db 	.word	0x080003db
 80002a0:	080003db 	.word	0x080003db
 80002a4:	080003db 	.word	0x080003db
 80002a8:	080003db 	.word	0x080003db
 80002ac:	080003db 	.word	0x080003db
 80002b0:	080003db 	.word	0x080003db
 80002b4:	080003db 	.word	0x080003db
 80002b8:	080003db 	.word	0x080003db
 80002bc:	080003db 	.word	0x080003db
 80002c0:	080003db 	.word	0x080003db
 80002c4:	080003db 	.word	0x080003db
 80002c8:	080003db 	.word	0x080003db
 80002cc:	080003db 	.word	0x080003db
 80002d0:	080003db 	.word	0x080003db
 80002d4:	080003db 	.word	0x080003db
 80002d8:	080003db 	.word	0x080003db
 80002dc:	080003db 	.word	0x080003db

Disassembly of section .text:

08000300 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000300:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000302:	4826      	ldr	r0, [pc, #152]	@ (800039c <endfiniloop+0x6>)
                msr     MSP, r0
 8000304:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000308:	4825      	ldr	r0, [pc, #148]	@ (80003a0 <endfiniloop+0xa>)
                msr     PSP, r0
 800030a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 800030e:	4825      	ldr	r0, [pc, #148]	@ (80003a4 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 8000310:	4925      	ldr	r1, [pc, #148]	@ (80003a8 <endfiniloop+0x12>)
                str     r0, [r1]
 8000312:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 8000314:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000316:	f380 8814 	msr	CONTROL, r0
                isb
 800031a:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 800031e:	f003 f947 	bl	80035b0 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000322:	f004 fc7d 	bl	8004c20 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000326:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800032a:	4920      	ldr	r1, [pc, #128]	@ (80003ac <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 800032c:	4a1b      	ldr	r2, [pc, #108]	@ (800039c <endfiniloop+0x6>)

0800032e <msloop>:
msloop:
                cmp     r1, r2
 800032e:	4291      	cmp	r1, r2
                itt     lo
 8000330:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000332:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000336:	e7fa      	bcc.n	800032e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000338:	491d      	ldr	r1, [pc, #116]	@ (80003b0 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 800033a:	4a19      	ldr	r2, [pc, #100]	@ (80003a0 <endfiniloop+0xa>)

0800033c <psloop>:
psloop:
                cmp     r1, r2
 800033c:	4291      	cmp	r1, r2
                itt     lo
 800033e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000340:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000344:	e7fa      	bcc.n	800033c <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 8000346:	491b      	ldr	r1, [pc, #108]	@ (80003b4 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 8000348:	4a1b      	ldr	r2, [pc, #108]	@ (80003b8 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 800034a:	4b1c      	ldr	r3, [pc, #112]	@ (80003bc <endfiniloop+0x26>)

0800034c <dloop>:
dloop:
                cmp     r2, r3
 800034c:	429a      	cmp	r2, r3
                ittt    lo
 800034e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000350:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000354:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000358:	e7f8      	bcc.n	800034c <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800035a:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 800035c:	4918      	ldr	r1, [pc, #96]	@ (80003c0 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 800035e:	4a19      	ldr	r2, [pc, #100]	@ (80003c4 <endfiniloop+0x2e>)

08000360 <bloop>:
bloop:
                cmp     r1, r2
 8000360:	4291      	cmp	r1, r2
                itt     lo
 8000362:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000364:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000368:	e7fa      	bcc.n	8000360 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800036a:	f003 f971 	bl	8003650 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800036e:	f003 f95f 	bl	8003630 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000372:	4c15      	ldr	r4, [pc, #84]	@ (80003c8 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000374:	4d15      	ldr	r5, [pc, #84]	@ (80003cc <endfiniloop+0x36>)

08000376 <initloop>:
initloop:
                cmp     r4, r5
 8000376:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000378:	da03      	bge.n	8000382 <endinitloop>
                ldr     r1, [r4], #4
 800037a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800037e:	4788      	blx	r1
                b       initloop
 8000380:	e7f9      	b.n	8000376 <initloop>

08000382 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000382:	f005 f86d 	bl	8005460 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 8000386:	4c12      	ldr	r4, [pc, #72]	@ (80003d0 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 8000388:	4d12      	ldr	r5, [pc, #72]	@ (80003d4 <endfiniloop+0x3e>)

0800038a <finiloop>:
finiloop:
                cmp     r4, r5
 800038a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800038c:	da03      	bge.n	8000396 <endfiniloop>
                ldr     r1, [r4], #4
 800038e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000392:	4788      	blx	r1
                b       finiloop
 8000394:	e7f9      	b.n	800038a <finiloop>

08000396 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000396:	f003 b953 	b.w	8003640 <__default_exit>
 800039a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 800039c:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 80003a0:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 80003a4:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 80003a8:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 80003ac:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80003b0:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 80003b4:	080076e8 	.word	0x080076e8
                ldr     r2, =__data_base__
 80003b8:	24000000 	.word	0x24000000
                ldr     r3, =__data_end__
 80003bc:	24000150 	.word	0x24000150
                ldr     r1, =__bss_base__
 80003c0:	24006220 	.word	0x24006220
                ldr     r2, =__bss_end__
 80003c4:	240077e8 	.word	0x240077e8
                ldr     r4, =__init_array_base__
 80003c8:	080002e0 	.word	0x080002e0
                ldr     r5, =__init_array_end__
 80003cc:	080002e0 	.word	0x080002e0
                ldr     r4, =__fini_array_base__
 80003d0:	080002e0 	.word	0x080002e0
                ldr     r5, =__fini_array_end__
 80003d4:	080002e0 	.word	0x080002e0

080003d8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80003d8:	e792      	b.n	8000300 <_crt0_entry>

080003da <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80003da:	f000 f800 	bl	80003de <_unhandled_exception>

080003de <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80003de:	e7fe      	b.n	80003de <_unhandled_exception>

080003e0 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80003e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80003e4:	f8c1 d00c 	str.w	sp, [r1, #12]
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
                mov     sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
 80003e8:	f8d0 d00c 	ldr.w	sp, [r0, #12]

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80003ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080003f0 <__port_thread_start>:
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80003f0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80003f2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80003f6:	4628      	mov	r0, r5
                blx     r4
 80003f8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80003fa:	2000      	movs	r0, #0
                bl      chThdExit
 80003fc:	f005 f818 	bl	8005430 <chThdExit>

08000400 <.zombies>:
.zombies:       b       .zombies
 8000400:	e7fe      	b.n	8000400 <.zombies>

08000402 <__port_switch_from_isr>:
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
#endif
                bl      chSchDoPreemption
 8000402:	f004 fdd5 	bl	8004fb0 <chSchDoPreemption>

08000406 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000406:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000408:	e7fe      	b.n	8000408 <__port_exit_from_isr+0x2>
	...

08000420 <strcmp>:
 8000420:	7802      	ldrb	r2, [r0, #0]
 8000422:	780b      	ldrb	r3, [r1, #0]
 8000424:	2a01      	cmp	r2, #1
 8000426:	bf28      	it	cs
 8000428:	429a      	cmpcs	r2, r3
 800042a:	f040 80d8 	bne.w	80005de <strcmp+0x1be>
 800042e:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000432:	ea40 0401 	orr.w	r4, r0, r1
 8000436:	e9cd 6702 	strd	r6, r7, [sp, #8]
 800043a:	f06f 0c00 	mvn.w	ip, #0
 800043e:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000442:	b31a      	cbz	r2, 800048c <strcmp+0x6c>
 8000444:	ea80 0401 	eor.w	r4, r0, r1
 8000448:	f014 0f07 	tst.w	r4, #7
 800044c:	d16b      	bne.n	8000526 <strcmp+0x106>
 800044e:	f000 0407 	and.w	r4, r0, #7
 8000452:	f020 0007 	bic.w	r0, r0, #7
 8000456:	f004 0503 	and.w	r5, r4, #3
 800045a:	f021 0107 	bic.w	r1, r1, #7
 800045e:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000462:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000466:	f014 0f04 	tst.w	r4, #4
 800046a:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 800046e:	fa0c f405 	lsl.w	r4, ip, r5
 8000472:	ea62 0204 	orn	r2, r2, r4
 8000476:	ea66 0604 	orn	r6, r6, r4
 800047a:	d00b      	beq.n	8000494 <strcmp+0x74>
 800047c:	ea63 0304 	orn	r3, r3, r4
 8000480:	4662      	mov	r2, ip
 8000482:	ea67 0704 	orn	r7, r7, r4
 8000486:	4666      	mov	r6, ip
 8000488:	e004      	b.n	8000494 <strcmp+0x74>
 800048a:	bf00      	nop
 800048c:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000490:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000494:	fa82 f54c 	uadd8	r5, r2, ip
 8000498:	ea82 0406 	eor.w	r4, r2, r6
 800049c:	faa4 f48c 	sel	r4, r4, ip
 80004a0:	bb6c      	cbnz	r4, 80004fe <strcmp+0xde>
 80004a2:	fa83 f54c 	uadd8	r5, r3, ip
 80004a6:	ea83 0507 	eor.w	r5, r3, r7
 80004aa:	faa5 f58c 	sel	r5, r5, ip
 80004ae:	b995      	cbnz	r5, 80004d6 <strcmp+0xb6>
 80004b0:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 80004b4:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 80004b8:	fa82 f54c 	uadd8	r5, r2, ip
 80004bc:	ea82 0406 	eor.w	r4, r2, r6
 80004c0:	faa4 f48c 	sel	r4, r4, ip
 80004c4:	fa83 f54c 	uadd8	r5, r3, ip
 80004c8:	ea83 0507 	eor.w	r5, r3, r7
 80004cc:	faa5 f58c 	sel	r5, r5, ip
 80004d0:	4325      	orrs	r5, r4
 80004d2:	d0db      	beq.n	800048c <strcmp+0x6c>
 80004d4:	b99c      	cbnz	r4, 80004fe <strcmp+0xde>
 80004d6:	ba2d      	rev	r5, r5
 80004d8:	fab5 f485 	clz	r4, r5
 80004dc:	f024 0407 	bic.w	r4, r4, #7
 80004e0:	fa27 f104 	lsr.w	r1, r7, r4
 80004e4:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80004e8:	fa23 f304 	lsr.w	r3, r3, r4
 80004ec:	f003 00ff 	and.w	r0, r3, #255	@ 0xff
 80004f0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 80004f4:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80004f8:	eba0 0001 	sub.w	r0, r0, r1
 80004fc:	4770      	bx	lr
 80004fe:	ba24      	rev	r4, r4
 8000500:	fab4 f484 	clz	r4, r4
 8000504:	f024 0407 	bic.w	r4, r4, #7
 8000508:	fa26 f104 	lsr.w	r1, r6, r4
 800050c:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000510:	fa22 f204 	lsr.w	r2, r2, r4
 8000514:	f002 00ff 	and.w	r0, r2, #255	@ 0xff
 8000518:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800051c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000520:	eba0 0001 	sub.w	r0, r0, r1
 8000524:	4770      	bx	lr
 8000526:	f014 0f03 	tst.w	r4, #3
 800052a:	d13c      	bne.n	80005a6 <strcmp+0x186>
 800052c:	f010 0403 	ands.w	r4, r0, #3
 8000530:	d128      	bne.n	8000584 <strcmp+0x164>
 8000532:	f850 2b08 	ldr.w	r2, [r0], #8
 8000536:	f851 3b08 	ldr.w	r3, [r1], #8
 800053a:	fa82 f54c 	uadd8	r5, r2, ip
 800053e:	ea82 0503 	eor.w	r5, r2, r3
 8000542:	faa5 f58c 	sel	r5, r5, ip
 8000546:	b95d      	cbnz	r5, 8000560 <strcmp+0x140>
 8000548:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800054c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000550:	fa82 f54c 	uadd8	r5, r2, ip
 8000554:	ea82 0503 	eor.w	r5, r2, r3
 8000558:	faa5 f58c 	sel	r5, r5, ip
 800055c:	2d00      	cmp	r5, #0
 800055e:	d0e8      	beq.n	8000532 <strcmp+0x112>
 8000560:	ba2d      	rev	r5, r5
 8000562:	fab5 f485 	clz	r4, r5
 8000566:	f024 0407 	bic.w	r4, r4, #7
 800056a:	fa23 f104 	lsr.w	r1, r3, r4
 800056e:	fa22 f204 	lsr.w	r2, r2, r4
 8000572:	f002 00ff 	and.w	r0, r2, #255	@ 0xff
 8000576:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800057a:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800057e:	eba0 0001 	sub.w	r0, r0, r1
 8000582:	4770      	bx	lr
 8000584:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 8000588:	f020 0003 	bic.w	r0, r0, #3
 800058c:	f850 2b08 	ldr.w	r2, [r0], #8
 8000590:	f021 0103 	bic.w	r1, r1, #3
 8000594:	f851 3b08 	ldr.w	r3, [r1], #8
 8000598:	fa0c f404 	lsl.w	r4, ip, r4
 800059c:	ea62 0204 	orn	r2, r2, r4
 80005a0:	ea63 0304 	orn	r3, r3, r4
 80005a4:	e7c9      	b.n	800053a <strcmp+0x11a>
 80005a6:	f010 0403 	ands.w	r4, r0, #3
 80005aa:	d01d      	beq.n	80005e8 <strcmp+0x1c8>
 80005ac:	eba1 0104 	sub.w	r1, r1, r4
 80005b0:	f020 0003 	bic.w	r0, r0, #3
 80005b4:	07e4      	lsls	r4, r4, #31
 80005b6:	f850 2b04 	ldr.w	r2, [r0], #4
 80005ba:	d006      	beq.n	80005ca <strcmp+0x1aa>
 80005bc:	d212      	bcs.n	80005e4 <strcmp+0x1c4>
 80005be:	788b      	ldrb	r3, [r1, #2]
 80005c0:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 80005c4:	1ae4      	subs	r4, r4, r3
 80005c6:	d106      	bne.n	80005d6 <strcmp+0x1b6>
 80005c8:	b12b      	cbz	r3, 80005d6 <strcmp+0x1b6>
 80005ca:	78cb      	ldrb	r3, [r1, #3]
 80005cc:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 80005d0:	1ae4      	subs	r4, r4, r3
 80005d2:	d100      	bne.n	80005d6 <strcmp+0x1b6>
 80005d4:	b933      	cbnz	r3, 80005e4 <strcmp+0x1c4>
 80005d6:	4620      	mov	r0, r4
 80005d8:	f85d 4b10 	ldr.w	r4, [sp], #16
 80005dc:	4770      	bx	lr
 80005de:	eba2 0003 	sub.w	r0, r2, r3
 80005e2:	4770      	bx	lr
 80005e4:	f101 0104 	add.w	r1, r1, #4
 80005e8:	f850 2b04 	ldr.w	r2, [r0], #4
 80005ec:	07cc      	lsls	r4, r1, #31
 80005ee:	f021 0103 	bic.w	r1, r1, #3
 80005f2:	f851 3b04 	ldr.w	r3, [r1], #4
 80005f6:	d848      	bhi.n	800068a <strcmp+0x26a>
 80005f8:	d224      	bcs.n	8000644 <strcmp+0x224>
 80005fa:	f022 447f 	bic.w	r4, r2, #4278190080	@ 0xff000000
 80005fe:	fa82 f54c 	uadd8	r5, r2, ip
 8000602:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000606:	faa5 f58c 	sel	r5, r5, ip
 800060a:	d10a      	bne.n	8000622 <strcmp+0x202>
 800060c:	b965      	cbnz	r5, 8000628 <strcmp+0x208>
 800060e:	f851 3b04 	ldr.w	r3, [r1], #4
 8000612:	ea84 0402 	eor.w	r4, r4, r2
 8000616:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 800061a:	d10e      	bne.n	800063a <strcmp+0x21a>
 800061c:	f850 2b04 	ldr.w	r2, [r0], #4
 8000620:	e7eb      	b.n	80005fa <strcmp+0x1da>
 8000622:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000626:	e055      	b.n	80006d4 <strcmp+0x2b4>
 8000628:	f035 457f 	bics.w	r5, r5, #4278190080	@ 0xff000000
 800062c:	d14d      	bne.n	80006ca <strcmp+0x2aa>
 800062e:	7808      	ldrb	r0, [r1, #0]
 8000630:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000634:	f1c0 0000 	rsb	r0, r0, #0
 8000638:	4770      	bx	lr
 800063a:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800063e:	f003 03ff 	and.w	r3, r3, #255	@ 0xff
 8000642:	e047      	b.n	80006d4 <strcmp+0x2b4>
 8000644:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000648:	fa82 f54c 	uadd8	r5, r2, ip
 800064c:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 8000650:	faa5 f58c 	sel	r5, r5, ip
 8000654:	d10a      	bne.n	800066c <strcmp+0x24c>
 8000656:	b965      	cbnz	r5, 8000672 <strcmp+0x252>
 8000658:	f851 3b04 	ldr.w	r3, [r1], #4
 800065c:	ea84 0402 	eor.w	r4, r4, r2
 8000660:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000664:	d10c      	bne.n	8000680 <strcmp+0x260>
 8000666:	f850 2b04 	ldr.w	r2, [r0], #4
 800066a:	e7eb      	b.n	8000644 <strcmp+0x224>
 800066c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8000670:	e030      	b.n	80006d4 <strcmp+0x2b4>
 8000672:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000676:	d128      	bne.n	80006ca <strcmp+0x2aa>
 8000678:	880b      	ldrh	r3, [r1, #0]
 800067a:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800067e:	e029      	b.n	80006d4 <strcmp+0x2b4>
 8000680:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000684:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8000688:	e024      	b.n	80006d4 <strcmp+0x2b4>
 800068a:	f002 04ff 	and.w	r4, r2, #255	@ 0xff
 800068e:	fa82 f54c 	uadd8	r5, r2, ip
 8000692:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8000696:	faa5 f58c 	sel	r5, r5, ip
 800069a:	d10a      	bne.n	80006b2 <strcmp+0x292>
 800069c:	b965      	cbnz	r5, 80006b8 <strcmp+0x298>
 800069e:	f851 3b04 	ldr.w	r3, [r1], #4
 80006a2:	ea84 0402 	eor.w	r4, r4, r2
 80006a6:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 80006aa:	d109      	bne.n	80006c0 <strcmp+0x2a0>
 80006ac:	f850 2b04 	ldr.w	r2, [r0], #4
 80006b0:	e7eb      	b.n	800068a <strcmp+0x26a>
 80006b2:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80006b6:	e00d      	b.n	80006d4 <strcmp+0x2b4>
 80006b8:	f015 0fff 	tst.w	r5, #255	@ 0xff
 80006bc:	d105      	bne.n	80006ca <strcmp+0x2aa>
 80006be:	680b      	ldr	r3, [r1, #0]
 80006c0:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80006c4:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 80006c8:	e004      	b.n	80006d4 <strcmp+0x2b4>
 80006ca:	f04f 0000 	mov.w	r0, #0
 80006ce:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006d2:	4770      	bx	lr
 80006d4:	ba12      	rev	r2, r2
 80006d6:	ba1b      	rev	r3, r3
 80006d8:	fa82 f44c 	uadd8	r4, r2, ip
 80006dc:	ea82 0403 	eor.w	r4, r2, r3
 80006e0:	faa4 f58c 	sel	r5, r4, ip
 80006e4:	fab5 f485 	clz	r4, r5
 80006e8:	fa02 f204 	lsl.w	r2, r2, r4
 80006ec:	fa03 f304 	lsl.w	r3, r3, r4
 80006f0:	ea4f 6012 	mov.w	r0, r2, lsr #24
 80006f4:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006f8:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 80006fc:	4770      	bx	lr
 80006fe:	bf00      	nop

08000700 <memcpy>:
 8000700:	4684      	mov	ip, r0
 8000702:	ea41 0300 	orr.w	r3, r1, r0
 8000706:	f013 0303 	ands.w	r3, r3, #3
 800070a:	d16d      	bne.n	80007e8 <memcpy+0xe8>
 800070c:	3a40      	subs	r2, #64	@ 0x40
 800070e:	d341      	bcc.n	8000794 <memcpy+0x94>
 8000710:	f851 3b04 	ldr.w	r3, [r1], #4
 8000714:	f840 3b04 	str.w	r3, [r0], #4
 8000718:	f851 3b04 	ldr.w	r3, [r1], #4
 800071c:	f840 3b04 	str.w	r3, [r0], #4
 8000720:	f851 3b04 	ldr.w	r3, [r1], #4
 8000724:	f840 3b04 	str.w	r3, [r0], #4
 8000728:	f851 3b04 	ldr.w	r3, [r1], #4
 800072c:	f840 3b04 	str.w	r3, [r0], #4
 8000730:	f851 3b04 	ldr.w	r3, [r1], #4
 8000734:	f840 3b04 	str.w	r3, [r0], #4
 8000738:	f851 3b04 	ldr.w	r3, [r1], #4
 800073c:	f840 3b04 	str.w	r3, [r0], #4
 8000740:	f851 3b04 	ldr.w	r3, [r1], #4
 8000744:	f840 3b04 	str.w	r3, [r0], #4
 8000748:	f851 3b04 	ldr.w	r3, [r1], #4
 800074c:	f840 3b04 	str.w	r3, [r0], #4
 8000750:	f851 3b04 	ldr.w	r3, [r1], #4
 8000754:	f840 3b04 	str.w	r3, [r0], #4
 8000758:	f851 3b04 	ldr.w	r3, [r1], #4
 800075c:	f840 3b04 	str.w	r3, [r0], #4
 8000760:	f851 3b04 	ldr.w	r3, [r1], #4
 8000764:	f840 3b04 	str.w	r3, [r0], #4
 8000768:	f851 3b04 	ldr.w	r3, [r1], #4
 800076c:	f840 3b04 	str.w	r3, [r0], #4
 8000770:	f851 3b04 	ldr.w	r3, [r1], #4
 8000774:	f840 3b04 	str.w	r3, [r0], #4
 8000778:	f851 3b04 	ldr.w	r3, [r1], #4
 800077c:	f840 3b04 	str.w	r3, [r0], #4
 8000780:	f851 3b04 	ldr.w	r3, [r1], #4
 8000784:	f840 3b04 	str.w	r3, [r0], #4
 8000788:	f851 3b04 	ldr.w	r3, [r1], #4
 800078c:	f840 3b04 	str.w	r3, [r0], #4
 8000790:	3a40      	subs	r2, #64	@ 0x40
 8000792:	d2bd      	bcs.n	8000710 <memcpy+0x10>
 8000794:	3230      	adds	r2, #48	@ 0x30
 8000796:	d311      	bcc.n	80007bc <memcpy+0xbc>
 8000798:	f851 3b04 	ldr.w	r3, [r1], #4
 800079c:	f840 3b04 	str.w	r3, [r0], #4
 80007a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80007a4:	f840 3b04 	str.w	r3, [r0], #4
 80007a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80007ac:	f840 3b04 	str.w	r3, [r0], #4
 80007b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80007b4:	f840 3b04 	str.w	r3, [r0], #4
 80007b8:	3a10      	subs	r2, #16
 80007ba:	d2ed      	bcs.n	8000798 <memcpy+0x98>
 80007bc:	320c      	adds	r2, #12
 80007be:	d305      	bcc.n	80007cc <memcpy+0xcc>
 80007c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80007c4:	f840 3b04 	str.w	r3, [r0], #4
 80007c8:	3a04      	subs	r2, #4
 80007ca:	d2f9      	bcs.n	80007c0 <memcpy+0xc0>
 80007cc:	3204      	adds	r2, #4
 80007ce:	d008      	beq.n	80007e2 <memcpy+0xe2>
 80007d0:	07d2      	lsls	r2, r2, #31
 80007d2:	bf1c      	itt	ne
 80007d4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80007d8:	f800 3b01 	strbne.w	r3, [r0], #1
 80007dc:	d301      	bcc.n	80007e2 <memcpy+0xe2>
 80007de:	880b      	ldrh	r3, [r1, #0]
 80007e0:	8003      	strh	r3, [r0, #0]
 80007e2:	4660      	mov	r0, ip
 80007e4:	4770      	bx	lr
 80007e6:	bf00      	nop
 80007e8:	2a08      	cmp	r2, #8
 80007ea:	d313      	bcc.n	8000814 <memcpy+0x114>
 80007ec:	078b      	lsls	r3, r1, #30
 80007ee:	d08d      	beq.n	800070c <memcpy+0xc>
 80007f0:	f010 0303 	ands.w	r3, r0, #3
 80007f4:	d08a      	beq.n	800070c <memcpy+0xc>
 80007f6:	f1c3 0304 	rsb	r3, r3, #4
 80007fa:	1ad2      	subs	r2, r2, r3
 80007fc:	07db      	lsls	r3, r3, #31
 80007fe:	bf1c      	itt	ne
 8000800:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000804:	f800 3b01 	strbne.w	r3, [r0], #1
 8000808:	d380      	bcc.n	800070c <memcpy+0xc>
 800080a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800080e:	f820 3b02 	strh.w	r3, [r0], #2
 8000812:	e77b      	b.n	800070c <memcpy+0xc>
 8000814:	3a04      	subs	r2, #4
 8000816:	d3d9      	bcc.n	80007cc <memcpy+0xcc>
 8000818:	3a01      	subs	r2, #1
 800081a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800081e:	f800 3b01 	strb.w	r3, [r0], #1
 8000822:	d2f9      	bcs.n	8000818 <memcpy+0x118>
 8000824:	780b      	ldrb	r3, [r1, #0]
 8000826:	7003      	strb	r3, [r0, #0]
 8000828:	784b      	ldrb	r3, [r1, #1]
 800082a:	7043      	strb	r3, [r0, #1]
 800082c:	788b      	ldrb	r3, [r1, #2]
 800082e:	7083      	strb	r3, [r0, #2]
 8000830:	4660      	mov	r0, ip
 8000832:	4770      	bx	lr
	...

08000840 <strlen>:
 8000840:	b430      	push	{r4, r5}
 8000842:	f890 f000 	pld	[r0]
 8000846:	f020 0107 	bic.w	r1, r0, #7
 800084a:	f06f 0c00 	mvn.w	ip, #0
 800084e:	f010 0407 	ands.w	r4, r0, #7
 8000852:	f891 f020 	pld	[r1, #32]
 8000856:	f040 8048 	bne.w	80008ea <strlen+0xaa>
 800085a:	f04f 0400 	mov.w	r4, #0
 800085e:	f06f 0007 	mvn.w	r0, #7
 8000862:	e9d1 2300 	ldrd	r2, r3, [r1]
 8000866:	f891 f040 	pld	[r1, #64]	@ 0x40
 800086a:	f100 0008 	add.w	r0, r0, #8
 800086e:	fa82 f24c 	uadd8	r2, r2, ip
 8000872:	faa4 f28c 	sel	r2, r4, ip
 8000876:	fa83 f34c 	uadd8	r3, r3, ip
 800087a:	faa2 f38c 	sel	r3, r2, ip
 800087e:	bb4b      	cbnz	r3, 80008d4 <strlen+0x94>
 8000880:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8000884:	fa82 f24c 	uadd8	r2, r2, ip
 8000888:	f100 0008 	add.w	r0, r0, #8
 800088c:	faa4 f28c 	sel	r2, r4, ip
 8000890:	fa83 f34c 	uadd8	r3, r3, ip
 8000894:	faa2 f38c 	sel	r3, r2, ip
 8000898:	b9e3      	cbnz	r3, 80008d4 <strlen+0x94>
 800089a:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 800089e:	fa82 f24c 	uadd8	r2, r2, ip
 80008a2:	f100 0008 	add.w	r0, r0, #8
 80008a6:	faa4 f28c 	sel	r2, r4, ip
 80008aa:	fa83 f34c 	uadd8	r3, r3, ip
 80008ae:	faa2 f38c 	sel	r3, r2, ip
 80008b2:	b97b      	cbnz	r3, 80008d4 <strlen+0x94>
 80008b4:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 80008b8:	f101 0120 	add.w	r1, r1, #32
 80008bc:	fa82 f24c 	uadd8	r2, r2, ip
 80008c0:	f100 0008 	add.w	r0, r0, #8
 80008c4:	faa4 f28c 	sel	r2, r4, ip
 80008c8:	fa83 f34c 	uadd8	r3, r3, ip
 80008cc:	faa2 f38c 	sel	r3, r2, ip
 80008d0:	2b00      	cmp	r3, #0
 80008d2:	d0c6      	beq.n	8000862 <strlen+0x22>
 80008d4:	2a00      	cmp	r2, #0
 80008d6:	bf04      	itt	eq
 80008d8:	3004      	addeq	r0, #4
 80008da:	461a      	moveq	r2, r3
 80008dc:	ba12      	rev	r2, r2
 80008de:	fab2 f282 	clz	r2, r2
 80008e2:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 80008e6:	bc30      	pop	{r4, r5}
 80008e8:	4770      	bx	lr
 80008ea:	e9d1 2300 	ldrd	r2, r3, [r1]
 80008ee:	f004 0503 	and.w	r5, r4, #3
 80008f2:	f1c4 0000 	rsb	r0, r4, #0
 80008f6:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 80008fa:	f014 0f04 	tst.w	r4, #4
 80008fe:	f891 f040 	pld	[r1, #64]	@ 0x40
 8000902:	fa0c f505 	lsl.w	r5, ip, r5
 8000906:	ea62 0205 	orn	r2, r2, r5
 800090a:	bf1c      	itt	ne
 800090c:	ea63 0305 	ornne	r3, r3, r5
 8000910:	4662      	movne	r2, ip
 8000912:	f04f 0400 	mov.w	r4, #0
 8000916:	e7aa      	b.n	800086e <strlen+0x2e>
	...

08000920 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8000920:	f890 3080 	ldrb.w	r3, [r0, #128]	@ 0x80
 8000924:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8000928:	2b20      	cmp	r3, #32
 800092a:	d001      	beq.n	8000930 <sduRequestsHook+0x10>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
      return true;
    default:
      return false;
 800092c:	2000      	movs	r0, #0
    }
  }
  return false;
}
 800092e:	4770      	bx	lr
    switch (usbp->setup[1]) {
 8000930:	f890 3081 	ldrb.w	r3, [r0, #129]	@ 0x81
 8000934:	2b21      	cmp	r3, #33	@ 0x21
 8000936:	d809      	bhi.n	800094c <sduRequestsHook+0x2c>
 8000938:	2b1f      	cmp	r3, #31
 800093a:	d9f7      	bls.n	800092c <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800093c:	4907      	ldr	r1, [pc, #28]	@ (800095c <sduRequestsHook+0x3c>)
 800093e:	2207      	movs	r2, #7
 8000940:	2300      	movs	r3, #0
 8000942:	e9c0 121d 	strd	r1, r2, [r0, #116]	@ 0x74
 8000946:	67c3      	str	r3, [r0, #124]	@ 0x7c
      return true;
 8000948:	2001      	movs	r0, #1
 800094a:	4770      	bx	lr
    switch (usbp->setup[1]) {
 800094c:	2b22      	cmp	r3, #34	@ 0x22
 800094e:	d1ed      	bne.n	800092c <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8000950:	2300      	movs	r3, #0
 8000952:	e9c0 331d 	strd	r3, r3, [r0, #116]	@ 0x74
 8000956:	67c3      	str	r3, [r0, #124]	@ 0x7c
      return true;
 8000958:	e7f6      	b.n	8000948 <sduRequestsHook+0x28>
 800095a:	bf00      	nop
 800095c:	24000004 	.word	0x24000004

08000960 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 8000960:	4770      	bx	lr
 8000962:	bf00      	nop
	...

08000970 <usb_lld_start_out>:
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8000970:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8000974:	68da      	ldr	r2, [r3, #12]
 8000976:	6993      	ldr	r3, [r2, #24]
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8000978:	b410      	push	{r4}

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800097a:	681c      	ldr	r4, [r3, #0]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 800097c:	2c40      	cmp	r4, #64	@ 0x40
  osp->totsize = osp->rxsize;
 800097e:	60dc      	str	r4, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8000980:	d900      	bls.n	8000984 <usb_lld_start_out+0x14>
 8000982:	b329      	cbz	r1, 80009d0 <usb_lld_start_out+0x60>
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8000984:	8a53      	ldrh	r3, [r2, #18]
  /* Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000986:	6812      	ldr	r2, [r2, #0]
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8000988:	f8d0 0090 	ldr.w	r0, [r0, #144]	@ 0x90
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800098c:	f002 0c03 	and.w	ip, r2, #3
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8000990:	1e5a      	subs	r2, r3, #1
 8000992:	4422      	add	r2, r4
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000994:	f1bc 0f01 	cmp.w	ip, #1
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8000998:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 800099c:	fb02 f303 	mul.w	r3, r2, r3
 80009a0:	f103 0303 	add.w	r3, r3, #3
 80009a4:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80009a8:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 80009ac:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 80009b0:	f043 43c0 	orr.w	r3, r3, #1610612736	@ 0x60000000
 80009b4:	f8c2 3b10 	str.w	r3, [r2, #2832]	@ 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80009b8:	d00d      	beq.n	80009d6 <usb_lld_start_out+0x66>
 80009ba:	b209      	sxth	r1, r1
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 80009bc:	eb00 1041 	add.w	r0, r0, r1, lsl #5
}
 80009c0:	bc10      	pop	{r4}
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 80009c2:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 80009c6:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 80009ca:	f8c0 3b00 	str.w	r3, [r0, #2816]	@ 0xb00
}
 80009ce:	4770      	bx	lr
      osp->rxsize = EP0_MAX_OUTSIZE;
 80009d0:	2440      	movs	r4, #64	@ 0x40
 80009d2:	601c      	str	r4, [r3, #0]
 80009d4:	e7d6      	b.n	8000984 <usb_lld_start_out+0x14>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80009d6:	f8d0 3808 	ldr.w	r3, [r0, #2056]	@ 0x808
 80009da:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 80009de:	b209      	sxth	r1, r1
 80009e0:	f413 7f80 	tst.w	r3, #256	@ 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 80009e4:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	@ 0xb00
 80009e8:	bf14      	ite	ne
 80009ea:	f043 5380 	orrne.w	r3, r3, #268435456	@ 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 80009ee:	f043 5300 	orreq.w	r3, r3, #536870912	@ 0x20000000
 80009f2:	f8c2 3b00 	str.w	r3, [r2, #2816]	@ 0xb00
 80009f6:	e7e1      	b.n	80009bc <usb_lld_start_out+0x4c>
	...

08000a00 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8000a00:	eb00 0381 	add.w	r3, r0, r1, lsl #2

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8000a04:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8000a08:	68d8      	ldr	r0, [r3, #12]
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8000a0a:	b510      	push	{r4, lr}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8000a0c:	6944      	ldr	r4, [r0, #20]
  isp->totsize = isp->txsize;
 8000a0e:	6823      	ldr	r3, [r4, #0]
 8000a10:	60e3      	str	r3, [r4, #12]
  if (isp->txsize == 0) {
 8000a12:	b9db      	cbnz	r3, 8000a4c <usb_lld_start_in+0x4c>
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8000a14:	eb02 1341 	add.w	r3, r2, r1, lsl #5
 8000a18:	f44f 2400 	mov.w	r4, #524288	@ 0x80000
 8000a1c:	f8c3 4910 	str.w	r4, [r3, #2320]	@ 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000a20:	6803      	ldr	r3, [r0, #0]
 8000a22:	f003 0303 	and.w	r3, r3, #3
 8000a26:	2b01      	cmp	r3, #1
 8000a28:	d027      	beq.n	8000a7a <usb_lld_start_in+0x7a>
 8000a2a:	b208      	sxth	r0, r1
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8000a2c:	eb02 1040 	add.w	r0, r2, r0, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8000a30:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8000a32:	f8d0 4900 	ldr.w	r4, [r0, #2304]	@ 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8000a36:	408b      	lsls	r3, r1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8000a38:	f044 4404 	orr.w	r4, r4, #2214592512	@ 0x84000000
 8000a3c:	f8c0 4900 	str.w	r4, [r0, #2304]	@ 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8000a40:	f8d2 1834 	ldr.w	r1, [r2, #2100]	@ 0x834
 8000a44:	430b      	orrs	r3, r1
 8000a46:	f8c2 3834 	str.w	r3, [r2, #2100]	@ 0x834
}
 8000a4a:	bd10      	pop	{r4, pc}
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8000a4c:	2b40      	cmp	r3, #64	@ 0x40
 8000a4e:	d900      	bls.n	8000a52 <usb_lld_start_in+0x52>
 8000a50:	b321      	cbz	r1, 8000a9c <usb_lld_start_in+0x9c>
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8000a52:	f8b0 e010 	ldrh.w	lr, [r0, #16]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8000a56:	eb02 1c41 	add.w	ip, r2, r1, lsl #5
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8000a5a:	f10e 34ff 	add.w	r4, lr, #4294967295	@ 0xffffffff
 8000a5e:	441c      	add	r4, r3
 8000a60:	fbb4 f4fe 	udiv	r4, r4, lr
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8000a64:	ea43 43c4 	orr.w	r3, r3, r4, lsl #19
 8000a68:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8000a6c:	f8cc 3910 	str.w	r3, [ip, #2320]	@ 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000a70:	6803      	ldr	r3, [r0, #0]
 8000a72:	f003 0303 	and.w	r3, r3, #3
 8000a76:	2b01      	cmp	r3, #1
 8000a78:	d1d7      	bne.n	8000a2a <usb_lld_start_in+0x2a>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8000a7a:	f8d2 3808 	ldr.w	r3, [r2, #2056]	@ 0x808
 8000a7e:	b208      	sxth	r0, r1
 8000a80:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8000a84:	eb02 1341 	add.w	r3, r2, r1, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8000a88:	f8d3 4900 	ldr.w	r4, [r3, #2304]	@ 0x900
 8000a8c:	bf14      	ite	ne
 8000a8e:	f044 5480 	orrne.w	r4, r4, #268435456	@ 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8000a92:	f044 5400 	orreq.w	r4, r4, #536870912	@ 0x20000000
 8000a96:	f8c3 4900 	str.w	r4, [r3, #2304]	@ 0x900
 8000a9a:	e7c7      	b.n	8000a2c <usb_lld_start_in+0x2c>
      isp->txsize = EP0_MAX_INSIZE;
 8000a9c:	2340      	movs	r3, #64	@ 0x40
 8000a9e:	6023      	str	r3, [r4, #0]
 8000aa0:	e7d7      	b.n	8000a52 <usb_lld_start_in+0x52>
 8000aa2:	bf00      	nop
	...

08000ab0 <__idle_thread>:
 */
static void __idle_thread(void *p) {

  (void)p;

  while (true) {
 8000ab0:	e7fe      	b.n	8000ab0 <__idle_thread>
 8000ab2:	bf00      	nop
	...

08000ac0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8000ac0:	b570      	push	{r4, r5, r6, lr}
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8000ac2:	e9d0 3402 	ldrd	r3, r4, [r0, #8]
  tp->wabase = tdp->wbase;
 8000ac6:	6845      	ldr	r5, [r0, #4]
  tp->state             = CH_STATE_WTSTART;
 8000ac8:	f04f 0e02 	mov.w	lr, #2
  tp->owner             = oip;
 8000acc:	4a1b      	ldr	r2, [pc, #108]	@ (8000b3c <chThdCreateSuspendedI+0x7c>)
  tp->refs              = (trefs_t)1;
 8000ace:	f04f 0c01 	mov.w	ip, #1
  tp->wabase = tdp->wbase;
 8000ad2:	f843 5c28 	str.w	r5, [r3, #-40]
  tp->mtxlist           = NULL;
 8000ad6:	2100      	movs	r1, #0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000ad8:	6905      	ldr	r5, [r0, #16]
 8000ada:	4e19      	ldr	r6, [pc, #100]	@ (8000b40 <chThdCreateSuspendedI+0x80>)
 8000adc:	f843 5c6c 	str.w	r5, [r3, #-108]
 8000ae0:	6945      	ldr	r5, [r0, #20]
 8000ae2:	f843 6c4c 	str.w	r6, [r3, #-76]
 8000ae6:	f843 5c68 	str.w	r5, [r3, #-104]
  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8000aea:	6805      	ldr	r5, [r0, #0]
  REG_INSERT(oip, tp);
 8000aec:	f1a3 0038 	sub.w	r0, r3, #56	@ 0x38
  tp->state             = CH_STATE_WTSTART;
 8000af0:	f823 ec24 	strh.w	lr, [r3, #-36]
  tp->refs              = (trefs_t)1;
 8000af4:	f803 cc22 	strb.w	ip, [r3, #-34]
  tp->hdr.pqueue.prio   = prio;
 8000af8:	f843 4c40 	str.w	r4, [r3, #-64]
  tp->realprio          = prio;
 8000afc:	f843 4c08 	str.w	r4, [r3, #-8]
 * @notapi
 */
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {

  p->next       = qp;
  p->prev       = qp->prev;
 8000b00:	6ad4      	ldr	r4, [r2, #44]	@ 0x2c
  tp->name              = name;
 8000b02:	f843 5c2c 	str.w	r5, [r3, #-44]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000b06:	f1a3 056c 	sub.w	r5, r3, #108	@ 0x6c
 8000b0a:	f843 4c34 	str.w	r4, [r3, #-52]
 8000b0e:	f843 5c3c 	str.w	r5, [r3, #-60]
  p->next       = qp;
 8000b12:	f102 0528 	add.w	r5, r2, #40	@ 0x28
  tp->owner             = oip;
 8000b16:	f843 2c30 	str.w	r2, [r3, #-48]
 8000b1a:	f843 5c38 	str.w	r5, [r3, #-56]
  tp->epending          = (eventmask_t)0;
 8000b1e:	e943 1104 	strd	r1, r1, [r3, #-16]
  p->prev->next = p;
 8000b22:	6020      	str	r0, [r4, #0]
  ch_queue_init(&tp->msgqueue);
 8000b24:	f1a3 0118 	sub.w	r1, r3, #24
  ch_list_init(&tp->waiting);
 8000b28:	f1a3 041c 	sub.w	r4, r3, #28
  qp->prev      = p;
 8000b2c:	62d0      	str	r0, [r2, #44]	@ 0x2c
}
 8000b2e:	f1a3 0048 	sub.w	r0, r3, #72	@ 0x48
  qp->prev = qp;
 8000b32:	f843 1c14 	str.w	r1, [r3, #-20]
  lp->next = lp;
 8000b36:	e943 4107 	strd	r4, r1, [r3, #-28]
 8000b3a:	bd70      	pop	{r4, r5, r6, pc}
 8000b3c:	24006e20 	.word	0x24006e20
 8000b40:	080003f1 	.word	0x080003f1
	...

08000b50 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000b50:	4b01      	ldr	r3, [pc, #4]	@ (8000b58 <chTMStartMeasurementX+0x8>)
 8000b52:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8000b54:	6083      	str	r3, [r0, #8]
}
 8000b56:	4770      	bx	lr
 8000b58:	e0001000 	.word	0xe0001000
 8000b5c:	00000000 	.word	0x00000000

08000b60 <chTMStopMeasurementX>:
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8000b60:	4a0e      	ldr	r2, [pc, #56]	@ (8000b9c <chTMStopMeasurementX+0x3c>)
 8000b62:	4b0f      	ldr	r3, [pc, #60]	@ (8000ba0 <chTMStopMeasurementX+0x40>)
  tmp->last = (now - tmp->last) - offset;
 8000b64:	6881      	ldr	r1, [r0, #8]
 8000b66:	685b      	ldr	r3, [r3, #4]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000b68:	b410      	push	{r4}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8000b6a:	6894      	ldr	r4, [r2, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8000b6c:	6902      	ldr	r2, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8000b6e:	1b1b      	subs	r3, r3, r4
  tmp->n++;
 8000b70:	68c4      	ldr	r4, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8000b72:	1a5b      	subs	r3, r3, r1
  tmp->cumulative += (rttime_t)tmp->last;
 8000b74:	6941      	ldr	r1, [r0, #20]
  tmp->n++;
 8000b76:	3401      	adds	r4, #1
  tmp->cumulative += (rttime_t)tmp->last;
 8000b78:	18d2      	adds	r2, r2, r3
 8000b7a:	6102      	str	r2, [r0, #16]
 8000b7c:	f141 0100 	adc.w	r1, r1, #0
  if (tmp->last > tmp->worst) {
 8000b80:	6842      	ldr	r2, [r0, #4]
  tmp->cumulative += (rttime_t)tmp->last;
 8000b82:	6141      	str	r1, [r0, #20]
  if (tmp->last > tmp->worst) {
 8000b84:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 8000b86:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 8000b88:	bf88      	it	hi
 8000b8a:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 8000b8c:	4293      	cmp	r3, r2
  tmp->n++;
 8000b8e:	e9c0 3402 	strd	r3, r4, [r0, #8]
    tmp->best = tmp->last;
 8000b92:	bf38      	it	cc
 8000b94:	6003      	strcc	r3, [r0, #0]
}
 8000b96:	bc10      	pop	{r4}
 8000b98:	4770      	bx	lr
 8000b9a:	bf00      	nop
 8000b9c:	24006c30 	.word	0x24006c30
 8000ba0:	e0001000 	.word	0xe0001000
	...

08000bb0 <chCoreAllocAlignedI>:
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000bb0:	4b06      	ldr	r3, [pc, #24]	@ (8000bcc <chCoreAllocAlignedI+0x1c>)
 8000bb2:	4249      	negs	r1, r1
 8000bb4:	685a      	ldr	r2, [r3, #4]
 8000bb6:	1a10      	subs	r0, r2, r0
 8000bb8:	4008      	ands	r0, r1
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000bba:	6819      	ldr	r1, [r3, #0]
 8000bbc:	4288      	cmp	r0, r1
 8000bbe:	d303      	bcc.n	8000bc8 <chCoreAllocAlignedI+0x18>
 8000bc0:	4282      	cmp	r2, r0
 8000bc2:	d301      	bcc.n	8000bc8 <chCoreAllocAlignedI+0x18>
    return NULL;
  }

  ch_memcore.topmem = prev;
 8000bc4:	6058      	str	r0, [r3, #4]

  return p;
 8000bc6:	4770      	bx	lr
    return NULL;
 8000bc8:	2000      	movs	r0, #0
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 8000bca:	4770      	bx	lr
 8000bcc:	24006c28 	.word	0x24006c28

08000bd0 <__port_irq_epilogue>:
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000bd0:	2330      	movs	r3, #48	@ 0x30
 8000bd2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000bd6:	4b0d      	ldr	r3, [pc, #52]	@ (8000c0c <__port_irq_epilogue+0x3c>)
 8000bd8:	685b      	ldr	r3, [r3, #4]
 8000bda:	f413 6300 	ands.w	r3, r3, #2048	@ 0x800
 8000bde:	d102      	bne.n	8000be6 <__port_irq_epilogue+0x16>
 8000be0:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000be4:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8000be6:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
 8000bea:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
    s_psp -= sizeof (struct port_extctx);
 8000bee:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
 8000bf0:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8000bf2:	f383 8809 	msr	PSP, r3
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 8000bf6:	4a06      	ldr	r2, [pc, #24]	@ (8000c10 <__port_irq_epilogue+0x40>)
 8000bf8:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8000bfa:	68d2      	ldr	r2, [r2, #12]
    if (chSchIsPreemptionRequired()) {
 8000bfc:	6889      	ldr	r1, [r1, #8]
 8000bfe:	6892      	ldr	r2, [r2, #8]
 8000c00:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8000c02:	bf8c      	ite	hi
 8000c04:	4a03      	ldrhi	r2, [pc, #12]	@ (8000c14 <__port_irq_epilogue+0x44>)
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8000c06:	4a04      	ldrls	r2, [pc, #16]	@ (8000c18 <__port_irq_epilogue+0x48>)
 8000c08:	619a      	str	r2, [r3, #24]
 8000c0a:	4770      	bx	lr
 8000c0c:	e000ed00 	.word	0xe000ed00
 8000c10:	24006e20 	.word	0x24006e20
 8000c14:	08000403 	.word	0x08000403
 8000c18:	08000406 	.word	0x08000406
 8000c1c:	00000000 	.word	0x00000000

08000c20 <get_descriptor>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8000c20:	2902      	cmp	r1, #2
 8000c22:	d00c      	beq.n	8000c3e <get_descriptor+0x1e>
 8000c24:	2903      	cmp	r1, #3
 8000c26:	d004      	beq.n	8000c32 <get_descriptor+0x12>
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
 8000c28:	2901      	cmp	r1, #1
 8000c2a:	4807      	ldr	r0, [pc, #28]	@ (8000c48 <get_descriptor+0x28>)
 8000c2c:	bf18      	it	ne
 8000c2e:	2000      	movne	r0, #0
 8000c30:	4770      	bx	lr
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8000c32:	2a03      	cmp	r2, #3
 8000c34:	d805      	bhi.n	8000c42 <get_descriptor+0x22>
      return &vcom_strings[dindex];
 8000c36:	4805      	ldr	r0, [pc, #20]	@ (8000c4c <get_descriptor+0x2c>)
 8000c38:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 8000c3c:	4770      	bx	lr
  switch (dtype) {
 8000c3e:	4804      	ldr	r0, [pc, #16]	@ (8000c50 <get_descriptor+0x30>)
 8000c40:	4770      	bx	lr
  }
  return NULL;
 8000c42:	2000      	movs	r0, #0
}
 8000c44:	4770      	bx	lr
 8000c46:	bf00      	nop
 8000c48:	08007110 	.word	0x08007110
 8000c4c:	08007118 	.word	0x08007118
 8000c50:	08007108 	.word	0x08007108
	...

08000c60 <cmd_blink>:
  chprintf(chp, "STM32_HSECLK: %d\r\n", STM32_HSECLK);
}

static void cmd_blink(BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)chp; (void)argv; (void)argc;
  blink = !blink;
 8000c60:	4a02      	ldr	r2, [pc, #8]	@ (8000c6c <cmd_blink+0xc>)
 8000c62:	7813      	ldrb	r3, [r2, #0]
 8000c64:	f083 0301 	eor.w	r3, r3, #1
 8000c68:	7013      	strb	r3, [r2, #0]
}
 8000c6a:	4770      	bx	lr
 8000c6c:	24000000 	.word	0x24000000

08000c70 <otg_epout_handler.constprop.0>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8000c70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8000c74:	4f24      	ldr	r7, [pc, #144]	@ (8000d08 <otg_epout_handler.constprop.0+0x98>)
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8000c76:	4604      	mov	r4, r0
  stm32_otg_t *otgp = usbp->otg;
 8000c78:	f8d7 6090 	ldr.w	r6, [r7, #144]	@ 0x90
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8000c7c:	eb06 1340 	add.w	r3, r6, r0, lsl #5
 8000c80:	f8d3 5b08 	ldr.w	r5, [r3, #2824]	@ 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8000c84:	0728      	lsls	r0, r5, #28
  otgp->oe[ep].DOEPINT = epint;
 8000c86:	f8c3 5b08 	str.w	r5, [r3, #2824]	@ 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8000c8a:	d503      	bpl.n	8000c94 <otg_epout_handler.constprop.0+0x24>
 8000c8c:	f8d6 3814 	ldr.w	r3, [r6, #2068]	@ 0x814
 8000c90:	0719      	lsls	r1, r3, #28
 8000c92:	d431      	bmi.n	8000cf8 <otg_epout_handler.constprop.0+0x88>
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8000c94:	07ea      	lsls	r2, r5, #31
 8000c96:	d52d      	bpl.n	8000cf4 <otg_epout_handler.constprop.0+0x84>
 8000c98:	f8d6 3814 	ldr.w	r3, [r6, #2068]	@ 0x814
 8000c9c:	07db      	lsls	r3, r3, #31
 8000c9e:	d529      	bpl.n	8000cf4 <otg_epout_handler.constprop.0+0x84>
    osp = usbp->epc[ep]->out_state;
 8000ca0:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 8000ca4:	68d9      	ldr	r1, [r3, #12]
 8000ca6:	698a      	ldr	r2, [r1, #24]
    if (ep == 0) {
 8000ca8:	b954      	cbnz	r4, 8000cc0 <otg_epout_handler.constprop.0+0x50>
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8000caa:	8a48      	ldrh	r0, [r1, #18]
 8000cac:	6853      	ldr	r3, [r2, #4]
 8000cae:	fbb3 f5f0 	udiv	r5, r3, r0
 8000cb2:	fb00 3315 	mls	r3, r0, r5, r3
 8000cb6:	b91b      	cbnz	r3, 8000cc0 <otg_epout_handler.constprop.0+0x50>
          (osp->rxsize < osp->totsize)) {
 8000cb8:	6810      	ldr	r0, [r2, #0]
 8000cba:	68d3      	ldr	r3, [r2, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8000cbc:	4298      	cmp	r0, r3
 8000cbe:	d30d      	bcc.n	8000cdc <otg_epout_handler.constprop.0+0x6c>
    _usb_isr_invoke_out_cb(usbp, ep);
 8000cc0:	2201      	movs	r2, #1
 8000cc2:	897b      	ldrh	r3, [r7, #10]
 8000cc4:	68cd      	ldr	r5, [r1, #12]
 8000cc6:	40a2      	lsls	r2, r4
 8000cc8:	ea23 0302 	bic.w	r3, r3, r2
 8000ccc:	817b      	strh	r3, [r7, #10]
 8000cce:	b18d      	cbz	r5, 8000cf4 <otg_epout_handler.constprop.0+0x84>
 8000cd0:	4621      	mov	r1, r4
 8000cd2:	462b      	mov	r3, r5
 8000cd4:	480c      	ldr	r0, [pc, #48]	@ (8000d08 <otg_epout_handler.constprop.0+0x98>)
}
 8000cd6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _usb_isr_invoke_out_cb(usbp, ep);
 8000cda:	4718      	bx	r3
        osp->rxsize = osp->totsize - osp->rxsize;
 8000cdc:	1a1b      	subs	r3, r3, r0
        osp->rxcnt  = 0;
 8000cde:	6054      	str	r4, [r2, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000ce0:	2130      	movs	r1, #48	@ 0x30
        osp->rxsize = osp->totsize - osp->rxsize;
 8000ce2:	6013      	str	r3, [r2, #0]
 8000ce4:	f381 8811 	msr	BASEPRI, r1
        usb_lld_start_out(usbp, ep);
 8000ce8:	4807      	ldr	r0, [pc, #28]	@ (8000d08 <otg_epout_handler.constprop.0+0x98>)
 8000cea:	4621      	mov	r1, r4
 8000cec:	f7ff fe40 	bl	8000970 <usb_lld_start_out>
 8000cf0:	f384 8811 	msr	BASEPRI, r4
}
 8000cf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    _usb_isr_invoke_setup_cb(usbp, ep);
 8000cf8:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 8000cfc:	4621      	mov	r1, r4
 8000cfe:	4638      	mov	r0, r7
 8000d00:	68db      	ldr	r3, [r3, #12]
 8000d02:	685b      	ldr	r3, [r3, #4]
 8000d04:	4798      	blx	r3
 8000d06:	e7c5      	b.n	8000c94 <otg_epout_handler.constprop.0+0x24>
 8000d08:	24006c3c 	.word	0x24006c3c
 8000d0c:	00000000 	.word	0x00000000

08000d10 <trace_next.constprop.0>:
 *
 * @notapi
 */
NOINLINE static void trace_next(os_instance_t *oip) {

  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8000d10:	4a0c      	ldr	r2, [pc, #48]	@ (8000d44 <trace_next.constprop.0+0x34>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000d12:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 8000d16:	480c      	ldr	r0, [pc, #48]	@ (8000d48 <trace_next.constprop.0+0x38>)
 8000d18:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(oip->trace_buffer.ptr);

  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 8000d1c:	f502 6c09 	add.w	ip, r2, #2192	@ 0x890
NOINLINE static void trace_next(os_instance_t *oip) {
 8000d20:	b410      	push	{r4}
 8000d22:	6a4c      	ldr	r4, [r1, #36]	@ 0x24
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8000d24:	6819      	ldr	r1, [r3, #0]
  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8000d26:	605c      	str	r4, [r3, #4]
 8000d28:	6840      	ldr	r0, [r0, #4]
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8000d2a:	f360 211f 	bfi	r1, r0, #8, #24
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8000d2e:	f102 0090 	add.w	r0, r2, #144	@ 0x90
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8000d32:	f843 1b10 	str.w	r1, [r3], #16
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8000d36:	4563      	cmp	r3, ip
 8000d38:	bf28      	it	cs
 8000d3a:	4603      	movcs	r3, r0
 8000d3c:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
  }
}
 8000d40:	bc10      	pop	{r4}
 8000d42:	4770      	bx	lr
 8000d44:	24006e20 	.word	0x24006e20
 8000d48:	e0001000 	.word	0xe0001000
 8000d4c:	00000000 	.word	0x00000000

08000d50 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8000d50:	4604      	mov	r4, r0
 8000d52:	b508      	push	{r3, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 8000d54:	b672      	cpsid	i
 * @notapi
 */
void __trace_halt(const char *reason) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8000d56:	4d09      	ldr	r5, [pc, #36]	@ (8000d7c <chSysHalt+0x2c>)
 8000d58:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8000d5c:	071b      	lsls	r3, r3, #28
 8000d5e:	d505      	bpl.n	8000d6c <chSysHalt+0x1c>
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 8000d60:	4b07      	ldr	r3, [pc, #28]	@ (8000d80 <chSysHalt+0x30>)
 8000d62:	2203      	movs	r2, #3
  currcore->dbg.panic_msg = reason;
 8000d64:	f8c5 4084 	str.w	r4, [r5, #132]	@ 0x84
  ch_system.state = ch_sys_halted;
 8000d68:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
 8000d6a:	e7fe      	b.n	8000d6a <chSysHalt+0x1a>
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8000d6c:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
 8000d70:	2205      	movs	r2, #5
    oip->trace_buffer.ptr->state         = 0;
    oip->trace_buffer.ptr->u.halt.reason = reason;
 8000d72:	6098      	str	r0, [r3, #8]
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8000d74:	701a      	strb	r2, [r3, #0]
    trace_next(oip);
 8000d76:	f7ff ffcb 	bl	8000d10 <trace_next.constprop.0>
  }
}
 8000d7a:	e7f1      	b.n	8000d60 <chSysHalt+0x10>
 8000d7c:	24006e20 	.word	0x24006e20
 8000d80:	24006c30 	.word	0x24006c30
	...

08000d90 <_ctl>:
  switch (operation) {
 8000d90:	b109      	cbz	r1, 8000d96 <_ctl+0x6>
}
 8000d92:	2000      	movs	r0, #0
 8000d94:	4770      	bx	lr
    osalDbgAssert(false, "invalid CTL operation");
 8000d96:	4802      	ldr	r0, [pc, #8]	@ (8000da0 <_ctl+0x10>)
static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 8000d98:	b508      	push	{r3, lr}
    osalDbgAssert(false, "invalid CTL operation");
 8000d9a:	f7ff ffd9 	bl	8000d50 <chSysHalt>
 8000d9e:	bf00      	nop
 8000da0:	080074d8 	.word	0x080074d8
	...

08000db0 <otg_disable_ep.isra.0>:
static void otg_disable_ep(USBDriver *usbp) {
 8000db0:	b470      	push	{r4, r5, r6}
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000db2:	2200      	movs	r2, #0
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000db4:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000db8:	688e      	ldr	r6, [r1, #8]
 8000dba:	eb00 1142 	add.w	r1, r0, r2, lsl #5
 8000dbe:	f102 0c01 	add.w	ip, r2, #1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8000dc2:	f8d1 5900 	ldr.w	r5, [r1, #2304]	@ 0x900
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000dc6:	460b      	mov	r3, r1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8000dc8:	2d00      	cmp	r5, #0
 8000dca:	da05      	bge.n	8000dd8 <otg_disable_ep.isra.0+0x28>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 8000dcc:	f8d1 5900 	ldr.w	r5, [r1, #2304]	@ 0x900
 8000dd0:	f045 4580 	orr.w	r5, r5, #1073741824	@ 0x40000000
 8000dd4:	f8c1 5900 	str.w	r5, [r1, #2304]	@ 0x900
    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 8000dd8:	f8d1 5b00 	ldr.w	r5, [r1, #2816]	@ 0xb00
 8000ddc:	2d00      	cmp	r5, #0
 8000dde:	da05      	bge.n	8000dec <otg_disable_ep.isra.0+0x3c>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 8000de0:	f8d1 5b00 	ldr.w	r5, [r1, #2816]	@ 0xb00
 8000de4:	f045 4580 	orr.w	r5, r5, #1073741824	@ 0x40000000
 8000de8:	f8c1 5b00 	str.w	r5, [r1, #2816]	@ 0xb00
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000dec:	4296      	cmp	r6, r2
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000dee:	f8c3 4908 	str.w	r4, [r3, #2312]	@ 0x908
 8000df2:	4662      	mov	r2, ip
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8000df4:	f8c3 4b08 	str.w	r4, [r3, #2824]	@ 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000df8:	d1df      	bne.n	8000dba <otg_disable_ep.isra.0+0xa>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8000dfa:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
}
 8000dfe:	bc70      	pop	{r4, r5, r6}
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8000e00:	f8c0 381c 	str.w	r3, [r0, #2076]	@ 0x81c
}
 8000e04:	4770      	bx	lr
 8000e06:	bf00      	nop
	...

08000e10 <ibqReleaseEmptyBufferS>:
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8000e10:	68c3      	ldr	r3, [r0, #12]
 8000e12:	b193      	cbz	r3, 8000e3a <ibqReleaseEmptyBufferS+0x2a>

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
  ibqp->brdptr += ibqp->bsize;
 8000e14:	f8d0 c01c 	ldr.w	ip, [r0, #28]
  ibqp->bcounter--;
 8000e18:	68c2      	ldr	r2, [r0, #12]
  if (ibqp->brdptr >= ibqp->btop) {
 8000e1a:	e9d0 3105 	ldrd	r3, r1, [r0, #20]
  ibqp->bcounter--;
 8000e1e:	3a01      	subs	r2, #1
  ibqp->brdptr += ibqp->bsize;
 8000e20:	4463      	add	r3, ip
  ibqp->bcounter--;
 8000e22:	60c2      	str	r2, [r0, #12]
  if (ibqp->brdptr >= ibqp->btop) {
 8000e24:	428b      	cmp	r3, r1
  ibqp->brdptr += ibqp->bsize;
 8000e26:	6143      	str	r3, [r0, #20]
  if (ibqp->brdptr >= ibqp->btop) {
 8000e28:	d301      	bcc.n	8000e2e <ibqReleaseEmptyBufferS+0x1e>
    ibqp->brdptr = ibqp->buffers;
 8000e2a:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 8000e2c:	6143      	str	r3, [r0, #20]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8000e2e:	2200      	movs	r2, #0

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8000e30:	6b03      	ldr	r3, [r0, #48]	@ 0x30
  ibqp->ptr = NULL;
 8000e32:	6282      	str	r2, [r0, #40]	@ 0x28
  if (ibqp->notify != NULL) {
 8000e34:	b103      	cbz	r3, 8000e38 <ibqReleaseEmptyBufferS+0x28>
    ibqp->notify(ibqp);
 8000e36:	4718      	bx	r3
 8000e38:	4770      	bx	lr
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8000e3a:	4802      	ldr	r0, [pc, #8]	@ (8000e44 <ibqReleaseEmptyBufferS+0x34>)
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8000e3c:	b510      	push	{r4, lr}
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8000e3e:	f7ff ff87 	bl	8000d50 <chSysHalt>
 8000e42:	bf00      	nop
 8000e44:	08007528 	.word	0x08007528
	...

08000e50 <obqPostFullBufferS>:
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {

  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8000e50:	68c3      	ldr	r3, [r0, #12]
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8000e52:	b510      	push	{r4, lr}
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8000e54:	b1a3      	cbz	r3, 8000e80 <obqPostFullBufferS+0x30>

  /* Writing size field in the buffer.*/
  *((size_t *)(void *)obqp->bwrptr) = size;
 8000e56:	6903      	ldr	r3, [r0, #16]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
  if (obqp->bwrptr >= obqp->btop) {
 8000e58:	6984      	ldr	r4, [r0, #24]
  *((size_t *)(void *)obqp->bwrptr) = size;
 8000e5a:	6019      	str	r1, [r3, #0]
  obqp->bwrptr += obqp->bsize;
 8000e5c:	69c1      	ldr	r1, [r0, #28]
  obqp->bcounter--;
 8000e5e:	68c2      	ldr	r2, [r0, #12]
  obqp->bwrptr += obqp->bsize;
 8000e60:	440b      	add	r3, r1
  obqp->bcounter--;
 8000e62:	3a01      	subs	r2, #1
  if (obqp->bwrptr >= obqp->btop) {
 8000e64:	42a3      	cmp	r3, r4
  obqp->bwrptr += obqp->bsize;
 8000e66:	6103      	str	r3, [r0, #16]
  obqp->bcounter--;
 8000e68:	60c2      	str	r2, [r0, #12]
  if (obqp->bwrptr >= obqp->btop) {
 8000e6a:	d301      	bcc.n	8000e70 <obqPostFullBufferS+0x20>
    obqp->bwrptr = obqp->buffers;
 8000e6c:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 8000e6e:	6103      	str	r3, [r0, #16]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 8000e70:	2200      	movs	r2, #0

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8000e72:	6b03      	ldr	r3, [r0, #48]	@ 0x30
  obqp->ptr = NULL;
 8000e74:	6282      	str	r2, [r0, #40]	@ 0x28
  if (obqp->notify != NULL) {
 8000e76:	b113      	cbz	r3, 8000e7e <obqPostFullBufferS+0x2e>
    obqp->notify(obqp);
  }
}
 8000e78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    obqp->notify(obqp);
 8000e7c:	4718      	bx	r3
}
 8000e7e:	bd10      	pop	{r4, pc}
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8000e80:	4801      	ldr	r0, [pc, #4]	@ (8000e88 <obqPostFullBufferS+0x38>)
 8000e82:	f7ff ff65 	bl	8000d50 <chSysHalt>
 8000e86:	bf00      	nop
 8000e88:	080074ec 	.word	0x080074ec
 8000e8c:	00000000 	.word	0x00000000

08000e90 <chSysUnlock.lto_priv.1>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000e90:	b508      	push	{r3, lr}

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000e92:	4b08      	ldr	r3, [pc, #32]	@ (8000eb4 <chSysUnlock.lto_priv.1+0x24>)
 8000e94:	681a      	ldr	r2, [r3, #0]
 8000e96:	429a      	cmp	r2, r3
 8000e98:	d103      	bne.n	8000ea2 <chSysUnlock.lto_priv.1+0x12>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000e9a:	2300      	movs	r3, #0
 8000e9c:	f383 8811 	msr	BASEPRI, r3
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 8000ea0:	bd08      	pop	{r3, pc}
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000ea2:	68d9      	ldr	r1, [r3, #12]
 8000ea4:	6893      	ldr	r3, [r2, #8]
 8000ea6:	688a      	ldr	r2, [r1, #8]
 8000ea8:	429a      	cmp	r2, r3
 8000eaa:	d2f6      	bcs.n	8000e9a <chSysUnlock.lto_priv.1+0xa>
 8000eac:	4802      	ldr	r0, [pc, #8]	@ (8000eb8 <chSysUnlock.lto_priv.1+0x28>)
 8000eae:	f7ff ff4f 	bl	8000d50 <chSysHalt>
 8000eb2:	bf00      	nop
 8000eb4:	24006e20 	.word	0x24006e20
 8000eb8:	080074e0 	.word	0x080074e0
 8000ebc:	00000000 	.word	0x00000000

08000ec0 <sdu_start_receive.isra.0>:
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8000ec0:	f8d0 248c 	ldr.w	r2, [r0, #1164]	@ 0x48c
 8000ec4:	6813      	ldr	r3, [r2, #0]
 8000ec6:	7819      	ldrb	r1, [r3, #0]
 8000ec8:	2904      	cmp	r1, #4
 8000eca:	d000      	beq.n	8000ece <sdu_start_receive.isra.0+0xe>
 8000ecc:	4770      	bx	lr
 8000ece:	7a01      	ldrb	r1, [r0, #8]
 8000ed0:	2902      	cmp	r1, #2
 8000ed2:	d1fb      	bne.n	8000ecc <sdu_start_receive.isra.0+0xc>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 8000ed4:	f8b3 c00a 	ldrh.w	ip, [r3, #10]
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8000ed8:	b510      	push	{r4, lr}
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 8000eda:	7951      	ldrb	r1, [r2, #5]
 8000edc:	2201      	movs	r2, #1
 8000ede:	408a      	lsls	r2, r1
 8000ee0:	ea12 0f0c 	tst.w	r2, ip
 8000ee4:	fa1f fe82 	uxth.w	lr, r2
 8000ee8:	d000      	beq.n	8000eec <sdu_start_receive.isra.0+0x2c>
}
 8000eea:	bd10      	pop	{r4, pc}
  if (ibqIsFullI(ibqp)) {
 8000eec:	e9d0 2407 	ldrd	r2, r4, [r0, #28]
 8000ef0:	42a2      	cmp	r2, r4
 8000ef2:	d013      	beq.n	8000f1c <sdu_start_receive.isra.0+0x5c>
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8000ef4:	eb03 0081 	add.w	r0, r3, r1, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000ef8:	ea4c 0c0e 	orr.w	ip, ip, lr
  return ibqp->bwrptr + sizeof (size_t);
 8000efc:	3204      	adds	r2, #4
  osp = usbp->epc[ep]->out_state;
 8000efe:	68c4      	ldr	r4, [r0, #12]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8000f00:	4618      	mov	r0, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000f02:	f8a3 c00a 	strh.w	ip, [r3, #10]
  osp = usbp->epc[ep]->out_state;
 8000f06:	69a3      	ldr	r3, [r4, #24]
  osp->rxsize = n;
 8000f08:	f44f 7480 	mov.w	r4, #256	@ 0x100
  osp->rxbuf  = buf;
 8000f0c:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8000f0e:	2200      	movs	r2, #0
 8000f10:	e9c3 4200 	strd	r4, r2, [r3]
 8000f14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  usb_lld_start_out(usbp, ep);
 8000f18:	f7ff bd2a 	b.w	8000970 <usb_lld_start_out>
  if (ibqIsFullI(ibqp)) {
 8000f1c:	6980      	ldr	r0, [r0, #24]
 8000f1e:	2800      	cmp	r0, #0
 8000f20:	d0e8      	beq.n	8000ef4 <sdu_start_receive.isra.0+0x34>
 8000f22:	e7e2      	b.n	8000eea <sdu_start_receive.isra.0+0x2a>
	...

08000f30 <ibnotify>:
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8000f30:	6b43      	ldr	r3, [r0, #52]	@ 0x34
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8000f32:	f8d3 248c 	ldr.w	r2, [r3, #1164]	@ 0x48c
 8000f36:	6810      	ldr	r0, [r2, #0]
 8000f38:	7801      	ldrb	r1, [r0, #0]
 8000f3a:	2904      	cmp	r1, #4
 8000f3c:	d000      	beq.n	8000f40 <ibnotify+0x10>
 8000f3e:	4770      	bx	lr
 8000f40:	7a19      	ldrb	r1, [r3, #8]
 8000f42:	2902      	cmp	r1, #2
 8000f44:	d1fb      	bne.n	8000f3e <ibnotify+0xe>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 8000f46:	f8b0 c00a 	ldrh.w	ip, [r0, #10]
static void ibnotify(io_buffers_queue_t *bqp) {
 8000f4a:	b510      	push	{r4, lr}
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 8000f4c:	7951      	ldrb	r1, [r2, #5]
 8000f4e:	2201      	movs	r2, #1
 8000f50:	408a      	lsls	r2, r1
 8000f52:	ea12 0f0c 	tst.w	r2, ip
 8000f56:	fa1f fe82 	uxth.w	lr, r2
 8000f5a:	d000      	beq.n	8000f5e <ibnotify+0x2e>
}
 8000f5c:	bd10      	pop	{r4, pc}
 8000f5e:	e9d3 2407 	ldrd	r2, r4, [r3, #28]
 8000f62:	42a2      	cmp	r2, r4
 8000f64:	d012      	beq.n	8000f8c <ibnotify+0x5c>
  osp = usbp->epc[ep]->out_state;
 8000f66:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000f6a:	ea4c 0c0e 	orr.w	ip, ip, lr
  return ibqp->bwrptr + sizeof (size_t);
 8000f6e:	3204      	adds	r2, #4
  osp->rxsize = n;
 8000f70:	f44f 7480 	mov.w	r4, #256	@ 0x100
  osp = usbp->epc[ep]->out_state;
 8000f74:	68db      	ldr	r3, [r3, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000f76:	f8a0 c00a 	strh.w	ip, [r0, #10]
  osp = usbp->epc[ep]->out_state;
 8000f7a:	699b      	ldr	r3, [r3, #24]
  osp->rxbuf  = buf;
 8000f7c:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8000f7e:	2200      	movs	r2, #0
 8000f80:	e9c3 4200 	strd	r4, r2, [r3]
 8000f84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  usb_lld_start_out(usbp, ep);
 8000f88:	f7ff bcf2 	b.w	8000970 <usb_lld_start_out>
  if (ibqIsFullI(ibqp)) {
 8000f8c:	699b      	ldr	r3, [r3, #24]
 8000f8e:	2b00      	cmp	r3, #0
 8000f90:	d0e9      	beq.n	8000f66 <ibnotify+0x36>
 8000f92:	e7e3      	b.n	8000f5c <ibnotify+0x2c>
	...

08000fa0 <obnotify>:
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8000fa0:	6b43      	ldr	r3, [r0, #52]	@ 0x34
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8000fa2:	f8d3 248c 	ldr.w	r2, [r3, #1164]	@ 0x48c
 8000fa6:	6810      	ldr	r0, [r2, #0]
 8000fa8:	7801      	ldrb	r1, [r0, #0]
 8000faa:	2904      	cmp	r1, #4
 8000fac:	d000      	beq.n	8000fb0 <obnotify+0x10>
 8000fae:	4770      	bx	lr
 8000fb0:	7a19      	ldrb	r1, [r3, #8]
 8000fb2:	2902      	cmp	r1, #2
 8000fb4:	d1fb      	bne.n	8000fae <obnotify+0xe>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8000fb6:	f8b0 c008 	ldrh.w	ip, [r0, #8]
static void obnotify(io_buffers_queue_t *bqp) {
 8000fba:	b510      	push	{r4, lr}
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8000fbc:	7911      	ldrb	r1, [r2, #4]
 8000fbe:	2201      	movs	r2, #1
 8000fc0:	408a      	lsls	r2, r1
 8000fc2:	ea12 0f0c 	tst.w	r2, ip
 8000fc6:	fa1f fe82 	uxth.w	lr, r2
 8000fca:	d000      	beq.n	8000fce <obnotify+0x2e>
}
 8000fcc:	bd10      	pop	{r4, pc}
  if (obqIsEmptyI(obqp)) {
 8000fce:	e9d3 4215 	ldrd	r4, r2, [r3, #84]	@ 0x54
 8000fd2:	4294      	cmp	r4, r2
 8000fd4:	d012      	beq.n	8000ffc <obnotify+0x5c>
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8000fd6:	eb00 0481 	add.w	r4, r0, r1, lsl #2
  *sizep = *((size_t *)(void *)obqp->brdptr);
 8000fda:	4613      	mov	r3, r2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000fdc:	ea4c 0c0e 	orr.w	ip, ip, lr
  isp = usbp->epc[ep]->in_state;
 8000fe0:	68e2      	ldr	r2, [r4, #12]
 8000fe2:	f853 4b04 	ldr.w	r4, [r3], #4
 8000fe6:	6952      	ldr	r2, [r2, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000fe8:	f8a0 c008 	strh.w	ip, [r0, #8]
  /*lint -restore*/
  isp->txbuf  = buf;
 8000fec:	6093      	str	r3, [r2, #8]
  isp->txsize = n;
  isp->txcnt  = 0;
 8000fee:	2300      	movs	r3, #0
 8000ff0:	e9c2 4300 	strd	r4, r3, [r2]
 8000ff4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8000ff8:	f7ff bd02 	b.w	8000a00 <usb_lld_start_in>
  if (obqIsEmptyI(obqp)) {
 8000ffc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8000ffe:	2b00      	cmp	r3, #0
 8001000:	d0e9      	beq.n	8000fd6 <obnotify+0x36>
    osalDbgAssert(buf != NULL, "buffer not found");
 8001002:	4801      	ldr	r0, [pc, #4]	@ (8001008 <obnotify+0x68>)
 8001004:	f7ff fea4 	bl	8000d50 <chSysHalt>
 8001008:	080074b8 	.word	0x080074b8
 800100c:	00000000 	.word	0x00000000

08001010 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001010:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8001012:	f890 3070 	ldrb.w	r3, [r0, #112]	@ 0x70
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001016:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8001018:	3b06      	subs	r3, #6
 800101a:	2b05      	cmp	r3, #5
 800101c:	d804      	bhi.n	8001028 <_usb_ep0in+0x18>
 800101e:	e8df f003 	tbb	[pc, r3]
 8001022:	0333      	.short	0x0333
 8001024:	2c130603 	.word	0x2c130603
    return;
  case USB_EP0_STP_WAITING:
  case USB_EP0_OUT_WAITING_STS:
  case USB_EP0_OUT_RX:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 8001028:	4832      	ldr	r0, [pc, #200]	@ (80010f4 <_usb_ep0in+0xe4>)
 800102a:	f7ff fe91 	bl	8000d50 <chSysHalt>
    if ((usbp->ep0n < max) &&
 800102e:	6f83      	ldr	r3, [r0, #120]	@ 0x78
    max = (size_t)get_hword(&usbp->setup[6]);
 8001030:	f8b0 2086 	ldrh.w	r2, [r0, #134]	@ 0x86
    if ((usbp->ep0n < max) &&
 8001034:	4293      	cmp	r3, r2
 8001036:	d207      	bcs.n	8001048 <_usb_ep0in+0x38>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8001038:	68c2      	ldr	r2, [r0, #12]
 800103a:	8a12      	ldrh	r2, [r2, #16]
 800103c:	fbb3 f1f2 	udiv	r1, r3, r2
 8001040:	fb02 3311 	mls	r3, r2, r1, r3
    if ((usbp->ep0n < max) &&
 8001044:	2b00      	cmp	r3, #0
 8001046:	d036      	beq.n	80010b6 <_usb_ep0in+0xa6>
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8001048:	2214      	movs	r2, #20
 800104a:	2330      	movs	r3, #48	@ 0x30
 800104c:	f884 2070 	strb.w	r2, [r4, #112]	@ 0x70
 8001050:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8001054:	8963      	ldrh	r3, [r4, #10]
 8001056:	f013 0501 	ands.w	r5, r3, #1
 800105a:	d144      	bne.n	80010e6 <_usb_ep0in+0xd6>
  osp = usbp->epc[ep]->out_state;
 800105c:	68e2      	ldr	r2, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800105e:	f043 0301 	orr.w	r3, r3, #1
  usb_lld_start_out(usbp, ep);
 8001062:	4629      	mov	r1, r5
 8001064:	4620      	mov	r0, r4
  osp = usbp->epc[ep]->out_state;
 8001066:	6992      	ldr	r2, [r2, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001068:	8163      	strh	r3, [r4, #10]
  osp->rxbuf  = buf;
 800106a:	6095      	str	r5, [r2, #8]
  osp->rxsize = n;
 800106c:	e9c2 5500 	strd	r5, r5, [r2]
  usb_lld_start_out(usbp, ep);
 8001070:	f7ff fc7e 	bl	8000970 <usb_lld_start_out>
 8001074:	f385 8811 	msr	BASEPRI, r5
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8001078:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
 800107a:	6fc3      	ldr	r3, [r0, #124]	@ 0x7c
 800107c:	b103      	cbz	r3, 8001080 <_usb_ep0in+0x70>
      usbp->ep0endcb(usbp);
 800107e:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 8001080:	2300      	movs	r3, #0
 8001082:	f884 3070 	strb.w	r3, [r4, #112]	@ 0x70
}
 8001086:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_stall_in(usbp, 0);
 8001088:	f8d0 3090 	ldr.w	r3, [r0, #144]	@ 0x90
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800108c:	6841      	ldr	r1, [r0, #4]
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800108e:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
 8001092:	680d      	ldr	r5, [r1, #0]
 8001094:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
 8001098:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800109c:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	@ 0xb00
 80010a0:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
 80010a4:	f8c3 2b00 	str.w	r2, [r3, #2816]	@ 0xb00
 80010a8:	b10d      	cbz	r5, 80010ae <_usb_ep0in+0x9e>
 80010aa:	2106      	movs	r1, #6
 80010ac:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 80010ae:	2306      	movs	r3, #6
 80010b0:	f884 3070 	strb.w	r3, [r4, #112]	@ 0x70
}
 80010b4:	bd38      	pop	{r3, r4, r5, pc}
 80010b6:	2330      	movs	r3, #48	@ 0x30
 80010b8:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 80010bc:	8903      	ldrh	r3, [r0, #8]
 80010be:	f013 0501 	ands.w	r5, r3, #1
 80010c2:	d113      	bne.n	80010ec <_usb_ep0in+0xdc>
  isp = usbp->epc[ep]->in_state;
 80010c4:	68c2      	ldr	r2, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80010c6:	f043 0301 	orr.w	r3, r3, #1
  usb_lld_start_in(usbp, ep);
 80010ca:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 80010cc:	6952      	ldr	r2, [r2, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80010ce:	8103      	strh	r3, [r0, #8]
  isp->txbuf  = buf;
 80010d0:	6095      	str	r5, [r2, #8]
  isp->txsize = n;
 80010d2:	e9c2 5500 	strd	r5, r5, [r2]
  usb_lld_start_in(usbp, ep);
 80010d6:	f7ff fc93 	bl	8000a00 <usb_lld_start_in>
 80010da:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 80010de:	230a      	movs	r3, #10
 80010e0:	f884 3070 	strb.w	r3, [r4, #112]	@ 0x70
}
 80010e4:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 80010e6:	4804      	ldr	r0, [pc, #16]	@ (80010f8 <_usb_ep0in+0xe8>)
 80010e8:	f7ff fe32 	bl	8000d50 <chSysHalt>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 80010ec:	4803      	ldr	r0, [pc, #12]	@ (80010fc <_usb_ep0in+0xec>)
 80010ee:	f7ff fe2f 	bl	8000d50 <chSysHalt>
 80010f2:	bf00      	nop
 80010f4:	08007410 	.word	0x08007410
 80010f8:	080074c4 	.word	0x080074c4
 80010fc:	080074a4 	.word	0x080074a4

08001100 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8001100:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8001102:	f890 1070 	ldrb.w	r1, [r0, #112]	@ 0x70
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8001106:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8001108:	2914      	cmp	r1, #20
 800110a:	d034      	beq.n	8001176 <_usb_ep0out+0x76>
 800110c:	2915      	cmp	r1, #21
 800110e:	d01a      	beq.n	8001146 <_usb_ep0out+0x46>
 8001110:	2906      	cmp	r1, #6
 8001112:	d002      	beq.n	800111a <_usb_ep0out+0x1a>
  case USB_EP0_STP_WAITING:
  case USB_EP0_IN_TX:
  case USB_EP0_IN_WAITING_TX0:
  case USB_EP0_IN_SENDING_STS:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 8001114:	481f      	ldr	r0, [pc, #124]	@ (8001194 <_usb_ep0out+0x94>)
 8001116:	f7ff fe1b 	bl	8000d50 <chSysHalt>
    /* Falls through.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800111a:	f8d0 3090 	ldr.w	r3, [r0, #144]	@ 0x90
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800111e:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
 8001122:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
 8001126:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800112a:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	@ 0xb00
 800112e:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
 8001132:	f8c3 2b00 	str.w	r2, [r3, #2816]	@ 0xb00
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001136:	6843      	ldr	r3, [r0, #4]
 8001138:	681b      	ldr	r3, [r3, #0]
 800113a:	b103      	cbz	r3, 800113e <_usb_ep0out+0x3e>
 800113c:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 800113e:	2306      	movs	r3, #6
 8001140:	f884 3070 	strb.w	r3, [r4, #112]	@ 0x70
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8001144:	bd38      	pop	{r3, r4, r5, pc}
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8001146:	220b      	movs	r2, #11
 8001148:	2330      	movs	r3, #48	@ 0x30
 800114a:	f880 2070 	strb.w	r2, [r0, #112]	@ 0x70
 800114e:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8001152:	8903      	ldrh	r3, [r0, #8]
 8001154:	f013 0501 	ands.w	r5, r3, #1
 8001158:	d119      	bne.n	800118e <_usb_ep0out+0x8e>
  isp = usbp->epc[ep]->in_state;
 800115a:	68c2      	ldr	r2, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800115c:	f043 0301 	orr.w	r3, r3, #1
  usb_lld_start_in(usbp, ep);
 8001160:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 8001162:	6952      	ldr	r2, [r2, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001164:	8103      	strh	r3, [r0, #8]
  isp->txbuf  = buf;
 8001166:	6095      	str	r5, [r2, #8]
  isp->txsize = n;
 8001168:	e9c2 5500 	strd	r5, r5, [r2]
  usb_lld_start_in(usbp, ep);
 800116c:	f7ff fc48 	bl	8000a00 <usb_lld_start_in>
 8001170:	f385 8811 	msr	BASEPRI, r5
}
 8001174:	bd38      	pop	{r3, r4, r5, pc}
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8001176:	68c3      	ldr	r3, [r0, #12]
 8001178:	699b      	ldr	r3, [r3, #24]
 800117a:	685b      	ldr	r3, [r3, #4]
 800117c:	2b00      	cmp	r3, #0
 800117e:	d1e1      	bne.n	8001144 <_usb_ep0out+0x44>
    if (usbp->ep0endcb != NULL) {
 8001180:	6fc3      	ldr	r3, [r0, #124]	@ 0x7c
 8001182:	b103      	cbz	r3, 8001186 <_usb_ep0out+0x86>
      usbp->ep0endcb(usbp);
 8001184:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 8001186:	2300      	movs	r3, #0
 8001188:	f884 3070 	strb.w	r3, [r4, #112]	@ 0x70
}
 800118c:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 800118e:	4802      	ldr	r0, [pc, #8]	@ (8001198 <_usb_ep0out+0x98>)
 8001190:	f7ff fdde 	bl	8000d50 <chSysHalt>
 8001194:	08007404 	.word	0x08007404
 8001198:	080074a4 	.word	0x080074a4
 800119c:	00000000 	.word	0x00000000

080011a0 <vt_set_alarm>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80011a0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;

  if (delay < currdelta) {
 80011a4:	2902      	cmp	r1, #2
 80011a6:	68da      	ldr	r2, [r3, #12]
 80011a8:	bf38      	it	cc
 80011aa:	2102      	movcc	r1, #2
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80011ac:	0792      	lsls	r2, r2, #30
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 80011ae:	b510      	push	{r4, lr}

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 80011b0:	eb00 0401 	add.w	r4, r0, r1
 80011b4:	d519      	bpl.n	80011ea <vt_set_alarm+0x4a>
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80011b6:	635c      	str	r4, [r3, #52]	@ 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 80011b8:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80011ba:	1a10      	subs	r0, r2, r0
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(now, newnow);
    if (likely(nowdelta < delay)) {
 80011bc:	4281      	cmp	r1, r0
 80011be:	d900      	bls.n	80011c2 <vt_set_alarm+0x22>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 80011c0:	bd10      	pop	{r4, pc}
    if (likely(nowdelta < delay)) {
 80011c2:	2102      	movs	r1, #2
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80011c4:	68d8      	ldr	r0, [r3, #12]
    currdelta += (sysinterval_t)1;
 80011c6:	3101      	adds	r1, #1
 80011c8:	0780      	lsls	r0, r0, #30
  return systime + (systime_t)interval;
 80011ca:	eb01 0402 	add.w	r4, r1, r2
 80011ce:	d50c      	bpl.n	80011ea <vt_set_alarm+0x4a>
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80011d0:	635c      	str	r4, [r3, #52]	@ 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 80011d2:	6a58      	ldr	r0, [r3, #36]	@ 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80011d4:	1a82      	subs	r2, r0, r2
    if (likely(nowdelta < delay)) {
 80011d6:	428a      	cmp	r2, r1
 80011d8:	d20a      	bcs.n	80011f0 <vt_set_alarm+0x50>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 80011da:	2902      	cmp	r1, #2
 80011dc:	d9f0      	bls.n	80011c0 <vt_set_alarm+0x20>
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 80011de:	4a05      	ldr	r2, [pc, #20]	@ (80011f4 <vt_set_alarm+0x54>)
 80011e0:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 80011e2:	f043 0301 	orr.w	r3, r3, #1
 80011e6:	6353      	str	r3, [r2, #52]	@ 0x34
}
 80011e8:	bd10      	pop	{r4, pc}
 80011ea:	4803      	ldr	r0, [pc, #12]	@ (80011f8 <vt_set_alarm+0x58>)
 80011ec:	f7ff fdb0 	bl	8000d50 <chSysHalt>
 80011f0:	4602      	mov	r2, r0
 80011f2:	e7e7      	b.n	80011c4 <vt_set_alarm+0x24>
 80011f4:	24006e20 	.word	0x24006e20
 80011f8:	08007274 	.word	0x08007274
 80011fc:	00000000 	.word	0x00000000

08001200 <__sch_ready_ahead>:
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8001200:	b510      	push	{r4, lr}
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001202:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 8001206:	b31b      	cbz	r3, 8001250 <__sch_ready_ahead+0x50>
 8001208:	2b0f      	cmp	r3, #15
 800120a:	d021      	beq.n	8001250 <__sch_ready_ahead+0x50>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 800120c:	4a12      	ldr	r2, [pc, #72]	@ (8001258 <__sch_ready_ahead+0x58>)
 800120e:	4604      	mov	r4, r0
 8001210:	f8b2 1088 	ldrh.w	r1, [r2, #136]	@ 0x88
 8001214:	07c9      	lsls	r1, r1, #31
 8001216:	d50f      	bpl.n	8001238 <__sch_ready_ahead+0x38>
  tp->state = CH_STATE_READY;
 8001218:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 800121a:	69a3      	ldr	r3, [r4, #24]
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio > p->prio));
 800121c:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 800121e:	f884 2024 	strb.w	r2, [r4, #36]	@ 0x24
    pqp = pqp->next;
 8001222:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio > p->prio));
 8001224:	689a      	ldr	r2, [r3, #8]
 8001226:	428a      	cmp	r2, r1
 8001228:	d8fb      	bhi.n	8001222 <__sch_ready_ahead+0x22>

  /* Insertion on prev.*/
  p->next       = pqp;
  p->prev       = pqp->prev;
 800122a:	685a      	ldr	r2, [r3, #4]
}
 800122c:	4620      	mov	r0, r4
  p->next       = pqp;
 800122e:	6023      	str	r3, [r4, #0]
  p->prev       = pqp->prev;
 8001230:	6062      	str	r2, [r4, #4]
  p->prev->next = p;
 8001232:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8001234:	605c      	str	r4, [r3, #4]
 8001236:	bd10      	pop	{r4, pc}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8001238:	00db      	lsls	r3, r3, #3
  __trace_ready(tp, tp->u.rdymsg);
 800123a:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 800123c:	f8d2 208c 	ldr.w	r2, [r2, #140]	@ 0x8c
 8001240:	f043 0301 	orr.w	r3, r3, #1
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8001244:	e9c2 0102 	strd	r0, r1, [r2, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8001248:	7013      	strb	r3, [r2, #0]
    trace_next(oip);
 800124a:	f7ff fd61 	bl	8000d10 <trace_next.constprop.0>
}
 800124e:	e7e3      	b.n	8001218 <__sch_ready_ahead+0x18>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001250:	4802      	ldr	r0, [pc, #8]	@ (800125c <__sch_ready_ahead+0x5c>)
 8001252:	f7ff fd7d 	bl	8000d50 <chSysHalt>
 8001256:	bf00      	nop
 8001258:	24006e20 	.word	0x24006e20
 800125c:	08007260 	.word	0x08007260

08001260 <chCoreAllocFromTop>:
 8001260:	2330      	movs	r3, #48	@ 0x30
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8001262:	b510      	push	{r4, lr}
 8001264:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8001268:	4b10      	ldr	r3, [pc, #64]	@ (80012ac <chCoreAllocFromTop+0x4c>)
 800126a:	4249      	negs	r1, r1
 800126c:	685c      	ldr	r4, [r3, #4]
 800126e:	1a20      	subs	r0, r4, r0
 8001270:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8001272:	6819      	ldr	r1, [r3, #0]
  prev = p - offset;
 8001274:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8001276:	428a      	cmp	r2, r1
 8001278:	d30a      	bcc.n	8001290 <chCoreAllocFromTop+0x30>
 800127a:	4294      	cmp	r4, r2
 800127c:	d308      	bcc.n	8001290 <chCoreAllocFromTop+0x30>
  ch_memcore.topmem = prev;
 800127e:	605a      	str	r2, [r3, #4]
 8001280:	4b0b      	ldr	r3, [pc, #44]	@ (80012b0 <chCoreAllocFromTop+0x50>)
 8001282:	681a      	ldr	r2, [r3, #0]
 8001284:	429a      	cmp	r2, r3
 8001286:	d108      	bne.n	800129a <chCoreAllocFromTop+0x3a>
 8001288:	2300      	movs	r3, #0
 800128a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 800128e:	bd10      	pop	{r4, pc}
 8001290:	4b07      	ldr	r3, [pc, #28]	@ (80012b0 <chCoreAllocFromTop+0x50>)
    return NULL;
 8001292:	2000      	movs	r0, #0
 8001294:	681a      	ldr	r2, [r3, #0]
 8001296:	429a      	cmp	r2, r3
 8001298:	d0f6      	beq.n	8001288 <chCoreAllocFromTop+0x28>
 800129a:	68d9      	ldr	r1, [r3, #12]
 800129c:	6893      	ldr	r3, [r2, #8]
 800129e:	688a      	ldr	r2, [r1, #8]
 80012a0:	429a      	cmp	r2, r3
 80012a2:	d2f1      	bcs.n	8001288 <chCoreAllocFromTop+0x28>
 80012a4:	4803      	ldr	r0, [pc, #12]	@ (80012b4 <chCoreAllocFromTop+0x54>)
 80012a6:	f7ff fd53 	bl	8000d50 <chSysHalt>
 80012aa:	bf00      	nop
 80012ac:	24006c28 	.word	0x24006c28
 80012b0:	24006e20 	.word	0x24006e20
 80012b4:	080071b0 	.word	0x080071b0
	...

080012c0 <sof_handler>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 80012c0:	b538      	push	{r3, r4, r5, lr}
 80012c2:	2330      	movs	r3, #48	@ 0x30
 80012c4:	f383 8811 	msr	BASEPRI, r3
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80012c8:	4b25      	ldr	r3, [pc, #148]	@ (8001360 <sof_handler+0xa0>)
 80012ca:	f8d3 248c 	ldr.w	r2, [r3, #1164]	@ 0x48c
 80012ce:	6810      	ldr	r0, [r2, #0]
 80012d0:	7801      	ldrb	r1, [r0, #0]
 80012d2:	2904      	cmp	r1, #4
 80012d4:	d102      	bne.n	80012dc <sof_handler+0x1c>
 80012d6:	7a19      	ldrb	r1, [r3, #8]
 80012d8:	2902      	cmp	r1, #2
 80012da:	d003      	beq.n	80012e4 <sof_handler+0x24>
 80012dc:	2300      	movs	r3, #0
 80012de:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
  osalSysUnlockFromISR();
}
 80012e2:	bd38      	pop	{r3, r4, r5, pc}
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80012e4:	7911      	ldrb	r1, [r2, #4]
 80012e6:	2201      	movs	r2, #1
 80012e8:	f8b0 c008 	ldrh.w	ip, [r0, #8]
 80012ec:	408a      	lsls	r2, r1
 80012ee:	ea12 0f0c 	tst.w	r2, ip
 80012f2:	fa1f fe82 	uxth.w	lr, r2
 80012f6:	d1f1      	bne.n	80012dc <sof_handler+0x1c>

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80012f8:	e9d3 4215 	ldrd	r4, r2, [r3, #84]	@ 0x54
 80012fc:	4294      	cmp	r4, r2
 80012fe:	d1ed      	bne.n	80012dc <sof_handler+0x1c>
 8001300:	6d1c      	ldr	r4, [r3, #80]	@ 0x50
 8001302:	2c00      	cmp	r4, #0
 8001304:	d0ea      	beq.n	80012dc <sof_handler+0x1c>
 8001306:	6edc      	ldr	r4, [r3, #108]	@ 0x6c
 8001308:	2c00      	cmp	r4, #0
 800130a:	d0e7      	beq.n	80012dc <sof_handler+0x1c>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 800130c:	3c04      	subs	r4, #4

    if (size > 0U) {
 800130e:	1aa4      	subs	r4, r4, r2
 8001310:	d0e4      	beq.n	80012dc <sof_handler+0x1c>

      /* Writing size field in the buffer.*/
      *((size_t *)(void *)obqp->bwrptr) = size;
 8001312:	6014      	str	r4, [r2, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8001314:	6d1c      	ldr	r4, [r3, #80]	@ 0x50
      obqp->bwrptr += obqp->bsize;
 8001316:	6e1d      	ldr	r5, [r3, #96]	@ 0x60
      obqp->bcounter--;
 8001318:	3c01      	subs	r4, #1
      obqp->bwrptr += obqp->bsize;
 800131a:	4415      	add	r5, r2
      obqp->bcounter--;
 800131c:	651c      	str	r4, [r3, #80]	@ 0x50
      if (obqp->bwrptr >= obqp->btop) {
 800131e:	6ddc      	ldr	r4, [r3, #92]	@ 0x5c
      obqp->bwrptr += obqp->bsize;
 8001320:	655d      	str	r5, [r3, #84]	@ 0x54
      if (obqp->bwrptr >= obqp->btop) {
 8001322:	42a5      	cmp	r5, r4
 8001324:	d301      	bcc.n	800132a <sof_handler+0x6a>
        obqp->bwrptr = obqp->buffers;
 8001326:	6e9d      	ldr	r5, [r3, #104]	@ 0x68
 8001328:	655d      	str	r5, [r3, #84]	@ 0x54
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 800132a:	2400      	movs	r4, #0
  if (obqIsEmptyI(obqp)) {
 800132c:	42aa      	cmp	r2, r5
      obqp->ptr = NULL;
 800132e:	66dc      	str	r4, [r3, #108]	@ 0x6c
  if (obqIsEmptyI(obqp)) {
 8001330:	d010      	beq.n	8001354 <sof_handler+0x94>
  isp = usbp->epc[ep]->in_state;
 8001332:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  *sizep = *((size_t *)(void *)obqp->brdptr);
 8001336:	f852 4b04 	ldr.w	r4, [r2], #4
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800133a:	ea4c 0c0e 	orr.w	ip, ip, lr
  isp = usbp->epc[ep]->in_state;
 800133e:	68db      	ldr	r3, [r3, #12]
 8001340:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001342:	f8a0 c008 	strh.w	ip, [r0, #8]
  isp->txbuf  = buf;
 8001346:	609a      	str	r2, [r3, #8]
  isp->txcnt  = 0;
 8001348:	2200      	movs	r2, #0
 800134a:	e9c3 4200 	strd	r4, r2, [r3]
  usb_lld_start_in(usbp, ep);
 800134e:	f7ff fb57 	bl	8000a00 <usb_lld_start_in>
 8001352:	e7c3      	b.n	80012dc <sof_handler+0x1c>
  if (obqIsEmptyI(obqp)) {
 8001354:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8001356:	2b00      	cmp	r3, #0
 8001358:	d0eb      	beq.n	8001332 <sof_handler+0x72>
    osalDbgAssert(buf != NULL, "queue is empty");
 800135a:	4802      	ldr	r0, [pc, #8]	@ (8001364 <sof_handler+0xa4>)
 800135c:	f7ff fcf8 	bl	8000d50 <chSysHalt>
 8001360:	24006778 	.word	0x24006778
 8001364:	080070b4 	.word	0x080070b4
	...

08001370 <otg_epin_handler.constprop.0>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8001370:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  stm32_otg_t *otgp = usbp->otg;
 8001374:	4e42      	ldr	r6, [pc, #264]	@ (8001480 <otg_epin_handler.constprop.0+0x110>)
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8001376:	4605      	mov	r5, r0
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8001378:	ea4f 1940 	mov.w	r9, r0, lsl #5
  stm32_otg_t *otgp = usbp->otg;
 800137c:	f8d6 7090 	ldr.w	r7, [r6, #144]	@ 0x90
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8001380:	eb07 1340 	add.w	r3, r7, r0, lsl #5
 8001384:	f8d3 4908 	ldr.w	r4, [r3, #2312]	@ 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8001388:	07e1      	lsls	r1, r4, #31
  otgp->ie[ep].DIEPINT = epint;
 800138a:	f8c3 4908 	str.w	r4, [r3, #2312]	@ 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 800138e:	d503      	bpl.n	8001398 <otg_epin_handler.constprop.0+0x28>
 8001390:	f8d7 3810 	ldr.w	r3, [r7, #2064]	@ 0x810
 8001394:	07da      	lsls	r2, r3, #31
 8001396:	d40c      	bmi.n	80013b2 <otg_epin_handler.constprop.0+0x42>
  if ((epint & DIEPINT_TXFE) &&
 8001398:	0623      	lsls	r3, r4, #24
 800139a:	d508      	bpl.n	80013ae <otg_epin_handler.constprop.0+0x3e>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 800139c:	f04f 0e01 	mov.w	lr, #1
 80013a0:	f8d7 3834 	ldr.w	r3, [r7, #2100]	@ 0x834
 80013a4:	fa0e fe05 	lsl.w	lr, lr, r5
  if ((epint & DIEPINT_TXFE) &&
 80013a8:	ea13 0f0e 	tst.w	r3, lr
 80013ac:	d118      	bne.n	80013e0 <otg_epin_handler.constprop.0+0x70>
}
 80013ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80013b2:	eb06 0380 	add.w	r3, r6, r0, lsl #2
 80013b6:	68d9      	ldr	r1, [r3, #12]
 80013b8:	694b      	ldr	r3, [r1, #20]
    if (isp->txsize < isp->totsize) {
 80013ba:	6818      	ldr	r0, [r3, #0]
 80013bc:	68da      	ldr	r2, [r3, #12]
 80013be:	4290      	cmp	r0, r2
 80013c0:	d34a      	bcc.n	8001458 <otg_epin_handler.constprop.0+0xe8>
      _usb_isr_invoke_in_cb(usbp, ep);
 80013c2:	2201      	movs	r2, #1
 80013c4:	8933      	ldrh	r3, [r6, #8]
 80013c6:	f8d1 8008 	ldr.w	r8, [r1, #8]
 80013ca:	40aa      	lsls	r2, r5
 80013cc:	ea23 0302 	bic.w	r3, r3, r2
 80013d0:	8133      	strh	r3, [r6, #8]
 80013d2:	f1b8 0f00 	cmp.w	r8, #0
 80013d6:	d0df      	beq.n	8001398 <otg_epin_handler.constprop.0+0x28>
 80013d8:	4629      	mov	r1, r5
 80013da:	4630      	mov	r0, r6
 80013dc:	47c0      	blx	r8
 80013de:	e7db      	b.n	8001398 <otg_epin_handler.constprop.0+0x28>
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 80013e0:	eb06 0385 	add.w	r3, r6, r5, lsl #2
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 80013e4:	f8d6 8090 	ldr.w	r8, [r6, #144]	@ 0x90
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 80013e8:	68d9      	ldr	r1, [r3, #12]
 80013ea:	694e      	ldr	r6, [r1, #20]
 80013ec:	e9d6 3400 	ldrd	r3, r4, [r6]
 80013f0:	429c      	cmp	r4, r3
 80013f2:	d22a      	bcs.n	800144a <otg_epin_handler.constprop.0+0xda>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80013f4:	1c6a      	adds	r2, r5, #1
    if (n > usbp->epc[ep]->in_maxsize)
 80013f6:	8a0f      	ldrh	r7, [r1, #16]
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80013f8:	eb08 0c09 	add.w	ip, r8, r9
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80013fc:	b2d2      	uxtb	r2, r2
 80013fe:	eb08 3202 	add.w	r2, r8, r2, lsl #12
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8001402:	1b1b      	subs	r3, r3, r4
    if (n > usbp->epc[ep]->in_maxsize)
 8001404:	42bb      	cmp	r3, r7
 8001406:	bf28      	it	cs
 8001408:	463b      	movcs	r3, r7
 800140a:	461c      	mov	r4, r3
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800140c:	f8dc 3918 	ldr.w	r3, [ip, #2328]	@ 0x918
 8001410:	b29b      	uxth	r3, r3
 8001412:	ebb4 0f83 	cmp.w	r4, r3, lsl #2
 8001416:	d8ca      	bhi.n	80013ae <otg_epin_handler.constprop.0+0x3e>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8001418:	68b5      	ldr	r5, [r6, #8]
  osalDbgAssert(n > 0, "is zero");
 800141a:	b36c      	cbz	r4, 8001478 <otg_epin_handler.constprop.0+0x108>
    *fifop = *((uint32_t *)buf);
 800141c:	682b      	ldr	r3, [r5, #0]
    if (n <= 4) {
 800141e:	2c04      	cmp	r4, #4
    *fifop = *((uint32_t *)buf);
 8001420:	6013      	str	r3, [r2, #0]
    if (n <= 4) {
 8001422:	d90a      	bls.n	800143a <otg_epin_handler.constprop.0+0xca>
 8001424:	1f60      	subs	r0, r4, #5
 8001426:	462b      	mov	r3, r5
 8001428:	f020 0003 	bic.w	r0, r0, #3
 800142c:	3004      	adds	r0, #4
 800142e:	4428      	add	r0, r5
    *fifop = *((uint32_t *)buf);
 8001430:	f853 1f04 	ldr.w	r1, [r3, #4]!
    if (n <= 4) {
 8001434:	4283      	cmp	r3, r0
    *fifop = *((uint32_t *)buf);
 8001436:	6011      	str	r1, [r2, #0]
    if (n <= 4) {
 8001438:	d1fa      	bne.n	8001430 <otg_epin_handler.constprop.0+0xc0>
    usbp->epc[ep]->in_state->txcnt += n;
 800143a:	6873      	ldr	r3, [r6, #4]
    usbp->epc[ep]->in_state->txbuf += n;
 800143c:	4425      	add	r5, r4
    usbp->epc[ep]->in_state->txcnt += n;
 800143e:	441c      	add	r4, r3
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8001440:	6833      	ldr	r3, [r6, #0]
    usbp->epc[ep]->in_state->txbuf += n;
 8001442:	60b5      	str	r5, [r6, #8]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8001444:	42a3      	cmp	r3, r4
    usbp->epc[ep]->in_state->txcnt += n;
 8001446:	6074      	str	r4, [r6, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8001448:	d8db      	bhi.n	8001402 <otg_epin_handler.constprop.0+0x92>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 800144a:	f8d8 3834 	ldr.w	r3, [r8, #2100]	@ 0x834
 800144e:	ea23 030e 	bic.w	r3, r3, lr
 8001452:	f8c8 3834 	str.w	r3, [r8, #2100]	@ 0x834
      return true;
 8001456:	e7aa      	b.n	80013ae <otg_epin_handler.constprop.0+0x3e>
      isp->txsize = isp->totsize - isp->txsize;
 8001458:	1a12      	subs	r2, r2, r0
      isp->txcnt  = 0;
 800145a:	f04f 0800 	mov.w	r8, #0
      isp->txsize = isp->totsize - isp->txsize;
 800145e:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 8001460:	f8c3 8004 	str.w	r8, [r3, #4]
 8001464:	2330      	movs	r3, #48	@ 0x30
 8001466:	f383 8811 	msr	BASEPRI, r3
      usb_lld_start_in(usbp, ep);
 800146a:	4629      	mov	r1, r5
 800146c:	4630      	mov	r0, r6
 800146e:	f7ff fac7 	bl	8000a00 <usb_lld_start_in>
 8001472:	f388 8811 	msr	BASEPRI, r8
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
}
 8001476:	e78f      	b.n	8001398 <otg_epin_handler.constprop.0+0x28>
  osalDbgAssert(n > 0, "is zero");
 8001478:	4802      	ldr	r0, [pc, #8]	@ (8001484 <otg_epin_handler.constprop.0+0x114>)
 800147a:	f7ff fc69 	bl	8000d50 <chSysHalt>
 800147e:	bf00      	nop
 8001480:	24006c3c 	.word	0x24006c3c
 8001484:	08006dfc 	.word	0x08006dfc
	...

08001490 <vt_insert_first.constprop.0>:

/**
 * @brief   Inserts a timer as first element in a delta list.
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
 8001490:	b538      	push	{r3, r4, r5, lr}
                            sysinterval_t delay) {
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8001492:	4c1b      	ldr	r4, [pc, #108]	@ (8001500 <vt_insert_first.constprop.0+0x70>)
  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8001494:	2a02      	cmp	r2, #2
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {

  dlp->delta      = delta;
  dlp->prev       = dlhp;
 8001496:	f104 0310 	add.w	r3, r4, #16
  vtlp->lasttime = now;
 800149a:	61e1      	str	r1, [r4, #28]
  dlp->delta      = delta;
 800149c:	6082      	str	r2, [r0, #8]
  if (delay < currdelta) {
 800149e:	bf38      	it	cc
 80014a0:	2202      	movcc	r2, #2
  dlp->prev       = dlhp;
 80014a2:	6043      	str	r3, [r0, #4]
  dlp->next       = dlp->prev->next;
 80014a4:	6923      	ldr	r3, [r4, #16]
  return systime + (systime_t)interval;
 80014a6:	188d      	adds	r5, r1, r2
 80014a8:	6003      	str	r3, [r0, #0]
  dlp->next->prev = dlp;
 80014aa:	6058      	str	r0, [r3, #4]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80014ac:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  dlhp->next      = dlp;
 80014b0:	6120      	str	r0, [r4, #16]
 80014b2:	68d8      	ldr	r0, [r3, #12]
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80014b4:	f010 0002 	ands.w	r0, r0, #2
 80014b8:	d11c      	bne.n	80014f4 <vt_insert_first.constprop.0+0x64>
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80014ba:	635d      	str	r5, [r3, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 80014bc:	6118      	str	r0, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80014be:	2002      	movs	r0, #2
 80014c0:	60d8      	str	r0, [r3, #12]
  return (systime_t)STM32_ST_TIM->CNT;
 80014c2:	6a5d      	ldr	r5, [r3, #36]	@ 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80014c4:	eba5 0c01 	sub.w	ip, r5, r1
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80014c8:	4562      	cmp	r2, ip
 80014ca:	d902      	bls.n	80014d2 <vt_insert_first.constprop.0+0x42>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 80014cc:	bd38      	pop	{r3, r4, r5, pc}
 80014ce:	4629      	mov	r1, r5
 80014d0:	4615      	mov	r5, r2
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80014d2:	68da      	ldr	r2, [r3, #12]
    currdelta += (sysinterval_t)1;
 80014d4:	3001      	adds	r0, #1
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80014d6:	0792      	lsls	r2, r2, #30
  return systime + (systime_t)interval;
 80014d8:	4401      	add	r1, r0
 80014da:	d50e      	bpl.n	80014fa <vt_insert_first.constprop.0+0x6a>
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80014dc:	6359      	str	r1, [r3, #52]	@ 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 80014de:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80014e0:	1b51      	subs	r1, r2, r5
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80014e2:	4281      	cmp	r1, r0
 80014e4:	d2f3      	bcs.n	80014ce <vt_insert_first.constprop.0+0x3e>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 80014e6:	2802      	cmp	r0, #2
 80014e8:	d9f0      	bls.n	80014cc <vt_insert_first.constprop.0+0x3c>
 80014ea:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 80014ec:	f043 0301 	orr.w	r3, r3, #1
 80014f0:	6363      	str	r3, [r4, #52]	@ 0x34
}
 80014f2:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80014f4:	4803      	ldr	r0, [pc, #12]	@ (8001504 <vt_insert_first.constprop.0+0x74>)
 80014f6:	f7ff fc2b 	bl	8000d50 <chSysHalt>
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80014fa:	4803      	ldr	r0, [pc, #12]	@ (8001508 <vt_insert_first.constprop.0+0x78>)
 80014fc:	f7ff fc28 	bl	8000d50 <chSysHalt>
 8001500:	24006e20 	.word	0x24006e20
 8001504:	08006dec 	.word	0x08006dec
 8001508:	08007274 	.word	0x08007274
 800150c:	00000000 	.word	0x00000000

08001510 <__sch_ready_behind.isra.0>:
static thread_t *__sch_ready_behind(thread_t *tp) {
 8001510:	b510      	push	{r4, lr}
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001512:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 8001516:	b313      	cbz	r3, 800155e <__sch_ready_behind.isra.0+0x4e>
 8001518:	2b0f      	cmp	r3, #15
 800151a:	d020      	beq.n	800155e <__sch_ready_behind.isra.0+0x4e>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 800151c:	4a11      	ldr	r2, [pc, #68]	@ (8001564 <__sch_ready_behind.isra.0+0x54>)
 800151e:	4604      	mov	r4, r0
 8001520:	f8b2 1088 	ldrh.w	r1, [r2, #136]	@ 0x88
 8001524:	07c9      	lsls	r1, r1, #31
 8001526:	d50e      	bpl.n	8001546 <__sch_ready_behind.isra.0+0x36>
  tp->state = CH_STATE_READY;
 8001528:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800152a:	69a3      	ldr	r3, [r4, #24]
  } while (unlikely(pqp->prio >= p->prio));
 800152c:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 800152e:	f884 2024 	strb.w	r2, [r4, #36]	@ 0x24
    pqp = pqp->next;
 8001532:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8001534:	689a      	ldr	r2, [r3, #8]
 8001536:	428a      	cmp	r2, r1
 8001538:	d2fb      	bcs.n	8001532 <__sch_ready_behind.isra.0+0x22>
  p->prev       = pqp->prev;
 800153a:	685a      	ldr	r2, [r3, #4]
 800153c:	e9c4 3200 	strd	r3, r2, [r4]
  p->prev->next = p;
 8001540:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8001542:	605c      	str	r4, [r3, #4]
}
 8001544:	bd10      	pop	{r4, pc}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8001546:	00db      	lsls	r3, r3, #3
  __trace_ready(tp, tp->u.rdymsg);
 8001548:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 800154a:	f8d2 208c 	ldr.w	r2, [r2, #140]	@ 0x8c
 800154e:	f043 0301 	orr.w	r3, r3, #1
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8001552:	e9c2 0102 	strd	r0, r1, [r2, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8001556:	7013      	strb	r3, [r2, #0]
    trace_next(oip);
 8001558:	f7ff fbda 	bl	8000d10 <trace_next.constprop.0>
}
 800155c:	e7e4      	b.n	8001528 <__sch_ready_behind.isra.0+0x18>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800155e:	4802      	ldr	r0, [pc, #8]	@ (8001568 <__sch_ready_behind.isra.0+0x58>)
 8001560:	f7ff fbf6 	bl	8000d50 <chSysHalt>
 8001564:	24006e20 	.word	0x24006e20
 8001568:	08006dd8 	.word	0x08006dd8
 800156c:	00000000 	.word	0x00000000

08001570 <__sch_wakeup>:
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8001570:	b508      	push	{r3, lr}
 8001572:	2330      	movs	r3, #48	@ 0x30
 8001574:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
 8001578:	f891 3024 	ldrb.w	r3, [r1, #36]	@ 0x24
 800157c:	2b0c      	cmp	r3, #12
 800157e:	d810      	bhi.n	80015a2 <__sch_wakeup+0x32>
 8001580:	e8df f003 	tbb	[pc, r3]
 8001584:	190f0f15 	.word	0x190f0f15
 8001588:	0b0f070b 	.word	0x0b0f070b
 800158c:	0f0f0f0f 	.word	0x0f0f0f0f
 8001590:	0b          	.byte	0x0b
 8001591:	00          	.byte	0x00
    chSemFastSignalI(tp->u.wtsemp);
 8001592:	6a8a      	ldr	r2, [r1, #40]	@ 0x28
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8001594:	6893      	ldr	r3, [r2, #8]
 8001596:	3301      	adds	r3, #1
 8001598:	6093      	str	r3, [r2, #8]
  p->prev->next = p->next;
 800159a:	e9d1 3200 	ldrd	r3, r2, [r1]
 800159e:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 80015a0:	605a      	str	r2, [r3, #4]
  tp->u.rdymsg = MSG_TIMEOUT;
 80015a2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  (void) __sch_ready_behind(tp);
 80015a6:	4608      	mov	r0, r1
  tp->u.rdymsg = MSG_TIMEOUT;
 80015a8:	628b      	str	r3, [r1, #40]	@ 0x28
  (void) __sch_ready_behind(tp);
 80015aa:	f7ff ffb1 	bl	8001510 <__sch_ready_behind.isra.0>
 80015ae:	2300      	movs	r3, #0
 80015b0:	f383 8811 	msr	BASEPRI, r3
}
 80015b4:	bd08      	pop	{r3, pc}
    *tp->u.wttrp = NULL;
 80015b6:	6a8b      	ldr	r3, [r1, #40]	@ 0x28
 80015b8:	2200      	movs	r2, #0
 80015ba:	601a      	str	r2, [r3, #0]
    break;
 80015bc:	e7f1      	b.n	80015a2 <__sch_wakeup+0x32>
 80015be:	bf00      	nop

080015c0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80015c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 80015c2:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80015c4:	42a0      	cmp	r0, r4
 80015c6:	d02c      	beq.n	8001622 <chEvtBroadcastFlagsI+0x62>
 80015c8:	4607      	mov	r7, r0
 80015ca:	460d      	mov	r5, r1
    tp->u.rdymsg = MSG_OK;
 80015cc:	2600      	movs	r6, #0
 80015ce:	e00d      	b.n	80015ec <chEvtBroadcastFlagsI+0x2c>
  tp->epending |= events;
 80015d0:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
 80015d4:	6b81      	ldr	r1, [r0, #56]	@ 0x38
  if (((tp->state == CH_STATE_WTOREVT) &&
 80015d6:	f890 2024 	ldrb.w	r2, [r0, #36]	@ 0x24
  tp->epending |= events;
 80015da:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 80015dc:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 80015de:	6383      	str	r3, [r0, #56]	@ 0x38
  if (((tp->state == CH_STATE_WTOREVT) &&
 80015e0:	d016      	beq.n	8001610 <chEvtBroadcastFlagsI+0x50>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80015e2:	2a0b      	cmp	r2, #11
 80015e4:	d01e      	beq.n	8001624 <chEvtBroadcastFlagsI+0x64>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 80015e6:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80015e8:	42a7      	cmp	r7, r4
 80015ea:	d01a      	beq.n	8001622 <chEvtBroadcastFlagsI+0x62>
    elp->flags |= flags;
 80015ec:	68e3      	ldr	r3, [r4, #12]
 80015ee:	432b      	orrs	r3, r5
 80015f0:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 80015f2:	2d00      	cmp	r5, #0
 80015f4:	d0ec      	beq.n	80015d0 <chEvtBroadcastFlagsI+0x10>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 80015f6:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 80015f8:	421d      	tst	r5, r3
 80015fa:	d1e9      	bne.n	80015d0 <chEvtBroadcastFlagsI+0x10>
    elp = elp->next;
 80015fc:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80015fe:	42bc      	cmp	r4, r7
 8001600:	d00f      	beq.n	8001622 <chEvtBroadcastFlagsI+0x62>
    elp->flags |= flags;
 8001602:	68e3      	ldr	r3, [r4, #12]
 8001604:	432b      	orrs	r3, r5
 8001606:	60e3      	str	r3, [r4, #12]
        ((flags & elp->wflags) != (eventflags_t)0)) {
 8001608:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 800160a:	421d      	tst	r5, r3
 800160c:	d1e0      	bne.n	80015d0 <chEvtBroadcastFlagsI+0x10>
 800160e:	e7f5      	b.n	80015fc <chEvtBroadcastFlagsI+0x3c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8001610:	6a82      	ldr	r2, [r0, #40]	@ 0x28
  if (((tp->state == CH_STATE_WTOREVT) &&
 8001612:	4213      	tst	r3, r2
 8001614:	d0e7      	beq.n	80015e6 <chEvtBroadcastFlagsI+0x26>
    tp->u.rdymsg = MSG_OK;
 8001616:	6286      	str	r6, [r0, #40]	@ 0x28
  return __sch_ready_behind(tp);
 8001618:	f7ff ff7a 	bl	8001510 <__sch_ready_behind.isra.0>
    elp = elp->next;
 800161c:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 800161e:	42a7      	cmp	r7, r4
 8001620:	d1e4      	bne.n	80015ec <chEvtBroadcastFlagsI+0x2c>
  }
}
 8001622:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8001624:	6a82      	ldr	r2, [r0, #40]	@ 0x28
      ((tp->state == CH_STATE_WTANDEVT) &&
 8001626:	439a      	bics	r2, r3
 8001628:	d1dd      	bne.n	80015e6 <chEvtBroadcastFlagsI+0x26>
 800162a:	e7f4      	b.n	8001616 <chEvtBroadcastFlagsI+0x56>
 800162c:	0000      	movs	r0, r0
	...

08001630 <sduDataTransmitted>:
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8001630:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8001632:	f101 030b 	add.w	r3, r1, #11
 8001636:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
  if (sdup == NULL) {
 800163a:	b34c      	cbz	r4, 8001690 <sduDataTransmitted+0x60>
 800163c:	460e      	mov	r6, r1
 800163e:	4605      	mov	r5, r0
 8001640:	2330      	movs	r3, #48	@ 0x30
 8001642:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001646:	eb05 0786 	add.w	r7, r5, r6, lsl #2
 800164a:	2108      	movs	r1, #8
 800164c:	1d20      	adds	r0, r4, #4
 800164e:	f7ff ffb7 	bl	80015c0 <chEvtBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8001652:	68fb      	ldr	r3, [r7, #12]
 8001654:	695b      	ldr	r3, [r3, #20]
 8001656:	681b      	ldr	r3, [r3, #0]
 8001658:	b9db      	cbnz	r3, 8001692 <sduDataTransmitted+0x62>
 800165a:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 800165c:	6da2      	ldr	r2, [r4, #88]	@ 0x58
 800165e:	4293      	cmp	r3, r2
 8001660:	d037      	beq.n	80016d2 <sduDataTransmitted+0xa2>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8001662:	2301      	movs	r3, #1
 8001664:	8929      	ldrh	r1, [r5, #8]
 8001666:	40b3      	lsls	r3, r6
 8001668:	b298      	uxth	r0, r3
 800166a:	400b      	ands	r3, r1
 800166c:	d155      	bne.n	800171a <sduDataTransmitted+0xea>
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800166e:	ea41 0400 	orr.w	r4, r1, r0
  usb_lld_start_in(usbp, ep);
 8001672:	4631      	mov	r1, r6
  *sizep = *((size_t *)(void *)obqp->brdptr);
 8001674:	f852 6b04 	ldr.w	r6, [r2], #4
 8001678:	4628      	mov	r0, r5
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800167a:	812c      	strh	r4, [r5, #8]
  isp = usbp->epc[ep]->in_state;
 800167c:	68fc      	ldr	r4, [r7, #12]
 800167e:	6964      	ldr	r4, [r4, #20]
  isp->txbuf  = buf;
 8001680:	60a2      	str	r2, [r4, #8]
  isp->txcnt  = 0;
 8001682:	e9c4 6300 	strd	r6, r3, [r4]
  usb_lld_start_in(usbp, ep);
 8001686:	f7ff f9bb 	bl	8000a00 <usb_lld_start_in>
 800168a:	2300      	movs	r3, #0
 800168c:	f383 8811 	msr	BASEPRI, r3
}
 8001690:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 8001692:	e9d4 3215 	ldrd	r3, r2, [r4, #84]	@ 0x54
 8001696:	4293      	cmp	r3, r2
 8001698:	d039      	beq.n	800170e <sduDataTransmitted+0xde>
  obqp->bcounter++;
 800169a:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 800169c:	3101      	adds	r1, #1
 800169e:	6521      	str	r1, [r4, #80]	@ 0x50
  obqp->brdptr += obqp->bsize;
 80016a0:	6e21      	ldr	r1, [r4, #96]	@ 0x60
 80016a2:	440a      	add	r2, r1
  if (obqp->brdptr >= obqp->btop) {
 80016a4:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
 80016a6:	428a      	cmp	r2, r1
  obqp->brdptr += obqp->bsize;
 80016a8:	65a2      	str	r2, [r4, #88]	@ 0x58
  if (obqp->brdptr >= obqp->btop) {
 80016aa:	d301      	bcc.n	80016b0 <sduDataTransmitted+0x80>
    obqp->brdptr = obqp->buffers;
 80016ac:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
 80016ae:	65a2      	str	r2, [r4, #88]	@ 0x58
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (ch_queue_notempty(&tqp->queue)) {
 80016b0:	f104 0244 	add.w	r2, r4, #68	@ 0x44
  return (bool)(qp->next != qp);
 80016b4:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 80016b6:	4282      	cmp	r2, r0
 80016b8:	d0d0      	beq.n	800165c <sduDataTransmitted+0x2c>
  qp->next       = p->next;
 80016ba:	6803      	ldr	r3, [r0, #0]
 80016bc:	6463      	str	r3, [r4, #68]	@ 0x44
  qp->next->prev = qp;
 80016be:	605a      	str	r2, [r3, #4]

  chDbgAssert(ch_queue_notempty(&tqp->queue), "empty queue");

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 80016c0:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 80016c4:	2b04      	cmp	r3, #4
 80016c6:	d12b      	bne.n	8001720 <sduDataTransmitted+0xf0>

  tp->u.rdymsg = msg;
 80016c8:	2300      	movs	r3, #0
 80016ca:	6283      	str	r3, [r0, #40]	@ 0x28
 80016cc:	f7ff ff20 	bl	8001510 <__sch_ready_behind.isra.0>
 80016d0:	e7c3      	b.n	800165a <sduDataTransmitted+0x2a>
  if (obqIsEmptyI(obqp)) {
 80016d2:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 80016d4:	2b00      	cmp	r3, #0
 80016d6:	d0c4      	beq.n	8001662 <sduDataTransmitted+0x32>
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80016d8:	68fa      	ldr	r2, [r7, #12]
 80016da:	6954      	ldr	r4, [r2, #20]
 80016dc:	6823      	ldr	r3, [r4, #0]
 80016de:	2b00      	cmp	r3, #0
 80016e0:	d0d3      	beq.n	800168a <sduDataTransmitted+0x5a>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 80016e2:	8a12      	ldrh	r2, [r2, #16]
 80016e4:	3a01      	subs	r2, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80016e6:	421a      	tst	r2, r3
 80016e8:	d1cf      	bne.n	800168a <sduDataTransmitted+0x5a>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 80016ea:	2301      	movs	r3, #1
 80016ec:	892a      	ldrh	r2, [r5, #8]
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 80016ee:	f105 0780 	add.w	r7, r5, #128	@ 0x80
 80016f2:	40b3      	lsls	r3, r6
 80016f4:	b299      	uxth	r1, r3
 80016f6:	4013      	ands	r3, r2
 80016f8:	d10f      	bne.n	800171a <sduDataTransmitted+0xea>
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80016fa:	430a      	orrs	r2, r1
  usb_lld_start_in(usbp, ep);
 80016fc:	4628      	mov	r0, r5
 80016fe:	4631      	mov	r1, r6
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001700:	812a      	strh	r2, [r5, #8]
  isp->txbuf  = buf;
 8001702:	60a7      	str	r7, [r4, #8]
  isp->txsize = n;
 8001704:	e9c4 3300 	strd	r3, r3, [r4]
  usb_lld_start_in(usbp, ep);
 8001708:	f7ff f97a 	bl	8000a00 <usb_lld_start_in>
}
 800170c:	e7bd      	b.n	800168a <sduDataTransmitted+0x5a>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 800170e:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 8001710:	2900      	cmp	r1, #0
 8001712:	d0c2      	beq.n	800169a <sduDataTransmitted+0x6a>
 8001714:	4804      	ldr	r0, [pc, #16]	@ (8001728 <sduDataTransmitted+0xf8>)
 8001716:	f7ff fb1b 	bl	8000d50 <chSysHalt>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 800171a:	4804      	ldr	r0, [pc, #16]	@ (800172c <sduDataTransmitted+0xfc>)
 800171c:	f7ff fb18 	bl	8000d50 <chSysHalt>
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8001720:	4803      	ldr	r0, [pc, #12]	@ (8001730 <sduDataTransmitted+0x100>)
 8001722:	f7ff fb15 	bl	8000d50 <chSysHalt>
 8001726:	bf00      	nop
 8001728:	0800748c 	.word	0x0800748c
 800172c:	080074a4 	.word	0x080074a4
 8001730:	08007478 	.word	0x08007478
	...

08001740 <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8001740:	3113      	adds	r1, #19
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8001742:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8001744:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 8001748:	b194      	cbz	r4, 8001770 <sduDataReceived+0x30>
 800174a:	2330      	movs	r3, #48	@ 0x30
 800174c:	f383 8811 	msr	BASEPRI, r3
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8001750:	f8d4 248c 	ldr.w	r2, [r4, #1164]	@ 0x48c
 8001754:	6813      	ldr	r3, [r2, #0]
 8001756:	7952      	ldrb	r2, [r2, #5]
 8001758:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800175c:	68db      	ldr	r3, [r3, #12]
 800175e:	699b      	ldr	r3, [r3, #24]
 8001760:	685d      	ldr	r5, [r3, #4]
  if (size > (size_t)0) {
 8001762:	b935      	cbnz	r5, 8001772 <sduDataReceived+0x32>
  (void) sdu_start_receive(sdup);
 8001764:	4620      	mov	r0, r4
 8001766:	f7ff fbab 	bl	8000ec0 <sdu_start_receive.isra.0>
 800176a:	2300      	movs	r3, #0
 800176c:	f383 8811 	msr	BASEPRI, r3
}
 8001770:	bd38      	pop	{r3, r4, r5, pc}
 8001772:	2104      	movs	r1, #4
 8001774:	1860      	adds	r0, r4, r1
 8001776:	f7ff ff23 	bl	80015c0 <chEvtBroadcastFlagsI>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 800177a:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 800177e:	4293      	cmp	r3, r2
 8001780:	d01c      	beq.n	80017bc <sduDataReceived+0x7c>
  *((size_t *)(void *)ibqp->bwrptr) = size;
 8001782:	601d      	str	r5, [r3, #0]
  ibqp->bcounter++;
 8001784:	69a2      	ldr	r2, [r4, #24]
  if (ibqp->bwrptr >= ibqp->btop) {
 8001786:	e9d4 1009 	ldrd	r1, r0, [r4, #36]	@ 0x24
  ibqp->bcounter++;
 800178a:	3201      	adds	r2, #1
  ibqp->bwrptr += ibqp->bsize;
 800178c:	4403      	add	r3, r0
  ibqp->bcounter++;
 800178e:	61a2      	str	r2, [r4, #24]
  if (ibqp->bwrptr >= ibqp->btop) {
 8001790:	428b      	cmp	r3, r1
  ibqp->bwrptr += ibqp->bsize;
 8001792:	61e3      	str	r3, [r4, #28]
  if (ibqp->bwrptr >= ibqp->btop) {
 8001794:	d301      	bcc.n	800179a <sduDataReceived+0x5a>
    ibqp->bwrptr = ibqp->buffers;
 8001796:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8001798:	61e3      	str	r3, [r4, #28]
 800179a:	f104 030c 	add.w	r3, r4, #12
  return (bool)(qp->next != qp);
 800179e:	68e0      	ldr	r0, [r4, #12]
 80017a0:	4283      	cmp	r3, r0
 80017a2:	d0df      	beq.n	8001764 <sduDataReceived+0x24>
  qp->next       = p->next;
 80017a4:	6802      	ldr	r2, [r0, #0]
 80017a6:	60e2      	str	r2, [r4, #12]
  qp->next->prev = qp;
 80017a8:	6053      	str	r3, [r2, #4]
 80017aa:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 80017ae:	2b04      	cmp	r3, #4
 80017b0:	d10a      	bne.n	80017c8 <sduDataReceived+0x88>
  tp->u.rdymsg = msg;
 80017b2:	2300      	movs	r3, #0
 80017b4:	6283      	str	r3, [r0, #40]	@ 0x28
 80017b6:	f7ff feab 	bl	8001510 <__sch_ready_behind.isra.0>
 80017ba:	e7d3      	b.n	8001764 <sduDataReceived+0x24>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 80017bc:	69a2      	ldr	r2, [r4, #24]
 80017be:	2a00      	cmp	r2, #0
 80017c0:	d0df      	beq.n	8001782 <sduDataReceived+0x42>
 80017c2:	4803      	ldr	r0, [pc, #12]	@ (80017d0 <sduDataReceived+0x90>)
 80017c4:	f7ff fac4 	bl	8000d50 <chSysHalt>
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 80017c8:	4802      	ldr	r0, [pc, #8]	@ (80017d4 <sduDataReceived+0x94>)
 80017ca:	f7ff fac1 	bl	8000d50 <chSysHalt>
 80017ce:	bf00      	nop
 80017d0:	08007464 	.word	0x08007464
 80017d4:	08007478 	.word	0x08007478
	...

080017e0 <chThdDequeueAllI.constprop.0>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80017e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return (bool)(qp->next != qp);
 80017e4:	6804      	ldr	r4, [r0, #0]

  while (ch_queue_notempty(&tqp->queue)) {
 80017e6:	4284      	cmp	r4, r0
 80017e8:	d021      	beq.n	800182e <chThdDequeueAllI.constprop.0+0x4e>
 80017ea:	4605      	mov	r5, r0
  tp->u.rdymsg = msg;
 80017ec:	f06f 0701 	mvn.w	r7, #1
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 80017f0:	4e16      	ldr	r6, [pc, #88]	@ (800184c <chThdDequeueAllI.constprop.0+0x6c>)
  tp->state = CH_STATE_READY;
 80017f2:	f04f 0800 	mov.w	r8, #0
  qp->next       = p->next;
 80017f6:	6823      	ldr	r3, [r4, #0]
 80017f8:	602b      	str	r3, [r5, #0]
  qp->next->prev = qp;
 80017fa:	605d      	str	r5, [r3, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 80017fc:	f894 3024 	ldrb.w	r3, [r4, #36]	@ 0x24
 8001800:	2b04      	cmp	r3, #4
 8001802:	d11f      	bne.n	8001844 <chThdDequeueAllI.constprop.0+0x64>
 8001804:	f8b6 3088 	ldrh.w	r3, [r6, #136]	@ 0x88
  tp->u.rdymsg = msg;
 8001808:	62a7      	str	r7, [r4, #40]	@ 0x28
 800180a:	07db      	lsls	r3, r3, #31
 800180c:	d511      	bpl.n	8001832 <chThdDequeueAllI.constprop.0+0x52>
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800180e:	69a3      	ldr	r3, [r4, #24]
  } while (unlikely(pqp->prio >= p->prio));
 8001810:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 8001812:	f884 8024 	strb.w	r8, [r4, #36]	@ 0x24
    pqp = pqp->next;
 8001816:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8001818:	689a      	ldr	r2, [r3, #8]
 800181a:	428a      	cmp	r2, r1
 800181c:	d2fb      	bcs.n	8001816 <chThdDequeueAllI.constprop.0+0x36>
  p->prev       = pqp->prev;
 800181e:	685a      	ldr	r2, [r3, #4]
 8001820:	e9c4 3200 	strd	r3, r2, [r4]
  p->prev->next = p;
 8001824:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8001826:	605c      	str	r4, [r3, #4]
  return (bool)(qp->next != qp);
 8001828:	682c      	ldr	r4, [r5, #0]
 800182a:	42ac      	cmp	r4, r5
 800182c:	d1e3      	bne.n	80017f6 <chThdDequeueAllI.constprop.0+0x16>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800182e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8001832:	f8d6 308c 	ldr.w	r3, [r6, #140]	@ 0x8c
 8001836:	2221      	movs	r2, #33	@ 0x21
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8001838:	e9c3 4702 	strd	r4, r7, [r3, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 800183c:	701a      	strb	r2, [r3, #0]
    trace_next(oip);
 800183e:	f7ff fa67 	bl	8000d10 <trace_next.constprop.0>
}
 8001842:	e7e4      	b.n	800180e <chThdDequeueAllI.constprop.0+0x2e>
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8001844:	4802      	ldr	r0, [pc, #8]	@ (8001850 <chThdDequeueAllI.constprop.0+0x70>)
 8001846:	f7ff fa83 	bl	8000d50 <chSysHalt>
 800184a:	bf00      	nop
 800184c:	24006e20 	.word	0x24006e20
 8001850:	08007478 	.word	0x08007478
	...

08001860 <_usb_ep0setup>:
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8001860:	b570      	push	{r4, r5, r6, lr}
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8001862:	f890 3070 	ldrb.w	r3, [r0, #112]	@ 0x70
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8001866:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8001868:	b113      	cbz	r3, 8001870 <_usb_ep0setup+0x10>
    usbp->ep0state = USB_EP0_STP_WAITING;
 800186a:	2300      	movs	r3, #0
 800186c:	f880 3070 	strb.w	r3, [r0, #112]	@ 0x70
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8001870:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  if ((usbp->config->requests_hook_cb == NULL) ||
 8001874:	6862      	ldr	r2, [r4, #4]
 8001876:	68cb      	ldr	r3, [r1, #12]
 8001878:	6a1b      	ldr	r3, [r3, #32]
 800187a:	6819      	ldr	r1, [r3, #0]
 800187c:	685b      	ldr	r3, [r3, #4]
 800187e:	f8c4 1080 	str.w	r1, [r4, #128]	@ 0x80
 8001882:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
 8001886:	6893      	ldr	r3, [r2, #8]
 8001888:	b363      	cbz	r3, 80018e4 <_usb_ep0setup+0x84>
      !(usbp->config->requests_hook_cb(usbp))) {
 800188a:	4620      	mov	r0, r4
 800188c:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 800188e:	b348      	cbz	r0, 80018e4 <_usb_ep0setup+0x84>
  if (usbp->ep0n > max) {
 8001890:	6fa1      	ldr	r1, [r4, #120]	@ 0x78
 8001892:	f894 3080 	ldrb.w	r3, [r4, #128]	@ 0x80
  max = (size_t)get_hword(&usbp->setup[6]);
 8001896:	f8b4 2086 	ldrh.w	r2, [r4, #134]	@ 0x86
  if (usbp->ep0n > max) {
 800189a:	428a      	cmp	r2, r1
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800189c:	bf2c      	ite	cs
 800189e:	460a      	movcs	r2, r1
    usbp->ep0n = max;
 80018a0:	67a2      	strcc	r2, [r4, #120]	@ 0x78
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80018a2:	0619      	lsls	r1, r3, #24
 80018a4:	d45d      	bmi.n	8001962 <_usb_ep0setup+0x102>
    if (usbp->ep0n != 0U) {
 80018a6:	2a00      	cmp	r2, #0
 80018a8:	f000 80a9 	beq.w	80019fe <_usb_ep0setup+0x19e>
      usbp->ep0state = USB_EP0_OUT_RX;
 80018ac:	2215      	movs	r2, #21
 80018ae:	2330      	movs	r3, #48	@ 0x30
 80018b0:	f884 2070 	strb.w	r2, [r4, #112]	@ 0x70
 80018b4:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 80018b8:	8963      	ldrh	r3, [r4, #10]
 80018ba:	f013 0501 	ands.w	r5, r3, #1
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 80018be:	e9d4 121d 	ldrd	r1, r2, [r4, #116]	@ 0x74
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 80018c2:	f040 8154 	bne.w	8001b6e <_usb_ep0setup+0x30e>
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80018c6:	f043 0301 	orr.w	r3, r3, #1
  usb_lld_start_out(usbp, ep);
 80018ca:	4620      	mov	r0, r4
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80018cc:	8163      	strh	r3, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 80018ce:	68e3      	ldr	r3, [r4, #12]
 80018d0:	699b      	ldr	r3, [r3, #24]
  osp->rxbuf  = buf;
 80018d2:	6099      	str	r1, [r3, #8]
  usb_lld_start_out(usbp, ep);
 80018d4:	4629      	mov	r1, r5
  osp->rxcnt  = 0;
 80018d6:	e9c3 2500 	strd	r2, r5, [r3]
  usb_lld_start_out(usbp, ep);
 80018da:	f7ff f849 	bl	8000970 <usb_lld_start_out>
 80018de:	f385 8811 	msr	BASEPRI, r5
}
 80018e2:	bd70      	pop	{r4, r5, r6, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 80018e4:	f894 3080 	ldrb.w	r3, [r4, #128]	@ 0x80
 80018e8:	f013 0560 	ands.w	r5, r3, #96	@ 0x60
 80018ec:	4618      	mov	r0, r3
 80018ee:	d120      	bne.n	8001932 <_usb_ep0setup+0xd2>
           ((uint32_t)usbp->setup[1] << 8U))) {
 80018f0:	f894 1081 	ldrb.w	r1, [r4, #129]	@ 0x81
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80018f4:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 80018f8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80018fc:	f240 3102 	movw	r1, #770	@ 0x302
 8001900:	428a      	cmp	r2, r1
 8001902:	f000 8137 	beq.w	8001b74 <_usb_ep0setup+0x314>
 8001906:	f200 8094 	bhi.w	8001a32 <_usb_ep0setup+0x1d2>
 800190a:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
 800190e:	f000 811b 	beq.w	8001b48 <_usb_ep0setup+0x2e8>
 8001912:	d843      	bhi.n	800199c <_usb_ep0setup+0x13c>
 8001914:	2a01      	cmp	r2, #1
 8001916:	f000 8128 	beq.w	8001b6a <_usb_ep0setup+0x30a>
 800191a:	2a02      	cmp	r2, #2
 800191c:	f000 80c6 	beq.w	8001aac <_usb_ep0setup+0x24c>
 8001920:	b93a      	cbnz	r2, 8001932 <_usb_ep0setup+0xd2>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8001922:	f104 0288 	add.w	r2, r4, #136	@ 0x88
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8001926:	2102      	movs	r1, #2
 8001928:	2000      	movs	r0, #0
 800192a:	e9c4 211d 	strd	r2, r1, [r4, #116]	@ 0x74
 800192e:	67e0      	str	r0, [r4, #124]	@ 0x7c
 8001930:	e7b1      	b.n	8001896 <_usb_ep0setup+0x36>
 8001932:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8001936:	f8d2 3900 	ldr.w	r3, [r2, #2304]	@ 0x900
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800193a:	6861      	ldr	r1, [r4, #4]
 800193c:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8001940:	680d      	ldr	r5, [r1, #0]
 8001942:	f8c2 3900 	str.w	r3, [r2, #2304]	@ 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8001946:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	@ 0xb00
 800194a:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800194e:	f8c2 3b00 	str.w	r3, [r2, #2816]	@ 0xb00
 8001952:	b115      	cbz	r5, 800195a <_usb_ep0setup+0xfa>
 8001954:	2106      	movs	r1, #6
 8001956:	4620      	mov	r0, r4
 8001958:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
 800195a:	2306      	movs	r3, #6
 800195c:	f884 3070 	strb.w	r3, [r4, #112]	@ 0x70
}
 8001960:	bd70      	pop	{r4, r5, r6, pc}
    if (usbp->ep0n != 0U) {
 8001962:	b392      	cbz	r2, 80019ca <_usb_ep0setup+0x16a>
      usbp->ep0state = USB_EP0_IN_TX;
 8001964:	2209      	movs	r2, #9
 8001966:	2330      	movs	r3, #48	@ 0x30
 8001968:	f884 2070 	strb.w	r2, [r4, #112]	@ 0x70
 800196c:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8001970:	8923      	ldrh	r3, [r4, #8]
 8001972:	f013 0501 	ands.w	r5, r3, #1
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8001976:	e9d4 121d 	ldrd	r1, r2, [r4, #116]	@ 0x74
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 800197a:	f040 811b 	bne.w	8001bb4 <_usb_ep0setup+0x354>
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800197e:	f043 0301 	orr.w	r3, r3, #1
  usb_lld_start_in(usbp, ep);
 8001982:	4620      	mov	r0, r4
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001984:	8123      	strh	r3, [r4, #8]
  isp = usbp->epc[ep]->in_state;
 8001986:	68e3      	ldr	r3, [r4, #12]
 8001988:	695b      	ldr	r3, [r3, #20]
  isp->txbuf  = buf;
 800198a:	6099      	str	r1, [r3, #8]
  usb_lld_start_in(usbp, ep);
 800198c:	4629      	mov	r1, r5
  isp->txcnt  = 0;
 800198e:	e9c3 2500 	strd	r2, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8001992:	f7ff f835 	bl	8000a00 <usb_lld_start_in>
 8001996:	f385 8811 	msr	BASEPRI, r5
}
 800199a:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800199c:	f5b2 7f81 	cmp.w	r2, #258	@ 0x102
 80019a0:	f000 80ba 	beq.w	8001b18 <_usb_ep0setup+0x2b8>
 80019a4:	f5b2 7f40 	cmp.w	r2, #768	@ 0x300
 80019a8:	d1c3      	bne.n	8001932 <_usb_ep0setup+0xd2>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80019aa:	f894 3082 	ldrb.w	r3, [r4, #130]	@ 0x82
 80019ae:	2b01      	cmp	r3, #1
 80019b0:	d1bf      	bne.n	8001932 <_usb_ep0setup+0xd2>
      usbp->status |= 2U;
 80019b2:	f8b4 3088 	ldrh.w	r3, [r4, #136]	@ 0x88
 80019b6:	f043 0302 	orr.w	r3, r3, #2
 80019ba:	f8a4 3088 	strh.w	r3, [r4, #136]	@ 0x88
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80019be:	2300      	movs	r3, #0
 80019c0:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
 80019c4:	67e3      	str	r3, [r4, #124]	@ 0x7c
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80019c6:	0603      	lsls	r3, r0, #24
 80019c8:	d519      	bpl.n	80019fe <_usb_ep0setup+0x19e>
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 80019ca:	2214      	movs	r2, #20
 80019cc:	2330      	movs	r3, #48	@ 0x30
 80019ce:	f884 2070 	strb.w	r2, [r4, #112]	@ 0x70
 80019d2:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 80019d6:	8963      	ldrh	r3, [r4, #10]
 80019d8:	f013 0501 	ands.w	r5, r3, #1
 80019dc:	f040 80c7 	bne.w	8001b6e <_usb_ep0setup+0x30e>
  osp = usbp->epc[ep]->out_state;
 80019e0:	68e2      	ldr	r2, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80019e2:	f043 0301 	orr.w	r3, r3, #1
  usb_lld_start_out(usbp, ep);
 80019e6:	4629      	mov	r1, r5
 80019e8:	4620      	mov	r0, r4
  osp = usbp->epc[ep]->out_state;
 80019ea:	6992      	ldr	r2, [r2, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80019ec:	8163      	strh	r3, [r4, #10]
  osp->rxbuf  = buf;
 80019ee:	6095      	str	r5, [r2, #8]
  osp->rxcnt  = 0;
 80019f0:	e9c2 5500 	strd	r5, r5, [r2]
  usb_lld_start_out(usbp, ep);
 80019f4:	f7fe ffbc 	bl	8000970 <usb_lld_start_out>
 80019f8:	f385 8811 	msr	BASEPRI, r5
}
 80019fc:	bd70      	pop	{r4, r5, r6, pc}
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 80019fe:	220b      	movs	r2, #11
 8001a00:	2330      	movs	r3, #48	@ 0x30
 8001a02:	f884 2070 	strb.w	r2, [r4, #112]	@ 0x70
 8001a06:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8001a0a:	8923      	ldrh	r3, [r4, #8]
 8001a0c:	f013 0501 	ands.w	r5, r3, #1
 8001a10:	f040 80d0 	bne.w	8001bb4 <_usb_ep0setup+0x354>
  isp = usbp->epc[ep]->in_state;
 8001a14:	68e2      	ldr	r2, [r4, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001a16:	f043 0301 	orr.w	r3, r3, #1
  usb_lld_start_in(usbp, ep);
 8001a1a:	4629      	mov	r1, r5
 8001a1c:	4620      	mov	r0, r4
  isp = usbp->epc[ep]->in_state;
 8001a1e:	6952      	ldr	r2, [r2, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001a20:	8123      	strh	r3, [r4, #8]
  isp->txbuf  = buf;
 8001a22:	6095      	str	r5, [r2, #8]
  isp->txcnt  = 0;
 8001a24:	e9c2 5500 	strd	r5, r5, [r2]
  usb_lld_start_in(usbp, ep);
 8001a28:	f7fe ffea 	bl	8000a00 <usb_lld_start_in>
 8001a2c:	f385 8811 	msr	BASEPRI, r5
}
 8001a30:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001a32:	f5b2 6f00 	cmp.w	r2, #2048	@ 0x800
 8001a36:	f000 80b5 	beq.w	8001ba4 <_usb_ep0setup+0x344>
 8001a3a:	d81c      	bhi.n	8001a76 <_usb_ep0setup+0x216>
 8001a3c:	f5b2 6fa0 	cmp.w	r2, #1280	@ 0x500
 8001a40:	d04b      	beq.n	8001ada <_usb_ep0setup+0x27a>
 8001a42:	f5a2 62c0 	sub.w	r2, r2, #1536	@ 0x600
 8001a46:	2a01      	cmp	r2, #1
 8001a48:	f63f af73 	bhi.w	8001932 <_usb_ep0setup+0xd2>
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8001a4c:	6861      	ldr	r1, [r4, #4]
 8001a4e:	4620      	mov	r0, r4
 8001a50:	f8b4 3084 	ldrh.w	r3, [r4, #132]	@ 0x84
 8001a54:	684e      	ldr	r6, [r1, #4]
 8001a56:	f894 2082 	ldrb.w	r2, [r4, #130]	@ 0x82
 8001a5a:	f894 1083 	ldrb.w	r1, [r4, #131]	@ 0x83
 8001a5e:	47b0      	blx	r6
    if (dp == NULL) {
 8001a60:	2800      	cmp	r0, #0
 8001a62:	f43f af66 	beq.w	8001932 <_usb_ep0setup+0xd2>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8001a66:	f894 3080 	ldrb.w	r3, [r4, #128]	@ 0x80
 8001a6a:	e9d0 1200 	ldrd	r1, r2, [r0]
 8001a6e:	67e5      	str	r5, [r4, #124]	@ 0x7c
 8001a70:	e9c4 211d 	strd	r2, r1, [r4, #116]	@ 0x74
    return true;
 8001a74:	e70f      	b.n	8001896 <_usb_ep0setup+0x36>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001a76:	f5b2 6f10 	cmp.w	r2, #2304	@ 0x900
 8001a7a:	d171      	bne.n	8001b60 <_usb_ep0setup+0x300>
      if (usbp->state == USB_ACTIVE) {
 8001a7c:	7823      	ldrb	r3, [r4, #0]
 8001a7e:	2b04      	cmp	r3, #4
 8001a80:	f000 80a2 	beq.w	8001bc8 <_usb_ep0setup+0x368>
      if (usbp->setup[2] != 0U) {
 8001a84:	f894 3082 	ldrb.w	r3, [r4, #130]	@ 0x82
 8001a88:	b14b      	cbz	r3, 8001a9e <_usb_ep0setup+0x23e>
        usbp->state = USB_ACTIVE;
 8001a8a:	2104      	movs	r1, #4
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8001a8c:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
 8001a8e:	f884 308b 	strb.w	r3, [r4, #139]	@ 0x8b
        usbp->state = USB_ACTIVE;
 8001a92:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8001a94:	6813      	ldr	r3, [r2, #0]
 8001a96:	b113      	cbz	r3, 8001a9e <_usb_ep0setup+0x23e>
 8001a98:	2102      	movs	r1, #2
 8001a9a:	4620      	mov	r0, r4
 8001a9c:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8001a9e:	2300      	movs	r3, #0
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001aa0:	f894 0080 	ldrb.w	r0, [r4, #128]	@ 0x80
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8001aa4:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
 8001aa8:	67e3      	str	r3, [r4, #124]	@ 0x7c
    return true;
 8001aaa:	e78c      	b.n	80019c6 <_usb_ep0setup+0x166>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8001aac:	f994 0084 	ldrsb.w	r0, [r4, #132]	@ 0x84
 8001ab0:	f894 1084 	ldrb.w	r1, [r4, #132]	@ 0x84
 8001ab4:	2800      	cmp	r0, #0
 8001ab6:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
  ctl = usbp->otg->ie[ep].DIEPCTL;
 8001aba:	f001 010f 	and.w	r1, r1, #15
 8001abe:	db7c      	blt.n	8001bba <_usb_ep0setup+0x35a>
  ctl = usbp->otg->oe[ep].DOEPCTL;
 8001ac0:	3158      	adds	r1, #88	@ 0x58
 8001ac2:	0149      	lsls	r1, r1, #5
 8001ac4:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8001ac6:	0408      	lsls	r0, r1, #16
 8001ac8:	f57f af35 	bpl.w	8001936 <_usb_ep0setup+0xd6>
  if (ctl & DOEPCTL_STALL)
 8001acc:	4859      	ldr	r0, [pc, #356]	@ (8001c34 <_usb_ep0setup+0x3d4>)
 8001ace:	f411 1f00 	tst.w	r1, #2097152	@ 0x200000
 8001ad2:	4a59      	ldr	r2, [pc, #356]	@ (8001c38 <_usb_ep0setup+0x3d8>)
 8001ad4:	bf08      	it	eq
 8001ad6:	4602      	moveq	r2, r0
 8001ad8:	e725      	b.n	8001926 <_usb_ep0setup+0xc6>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8001ada:	f8b4 3080 	ldrh.w	r3, [r4, #128]	@ 0x80
 8001ade:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
 8001ae2:	f47f af6c 	bne.w	80019be <_usb_ep0setup+0x15e>
  usbp->address = usbp->setup[2];
 8001ae6:	f894 1082 	ldrb.w	r1, [r4, #130]	@ 0x82
 8001aea:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 8001aee:	f884 108a 	strb.w	r1, [r4, #138]	@ 0x8a
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8001af2:	f8d2 3800 	ldr.w	r3, [r2, #2048]	@ 0x800
 8001af6:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 8001afa:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8001afe:	6861      	ldr	r1, [r4, #4]
 8001b00:	680d      	ldr	r5, [r1, #0]
 8001b02:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800
 8001b06:	b125      	cbz	r5, 8001b12 <_usb_ep0setup+0x2b2>
 8001b08:	4620      	mov	r0, r4
 8001b0a:	2101      	movs	r1, #1
 8001b0c:	47a8      	blx	r5
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001b0e:	f894 0080 	ldrb.w	r0, [r4, #128]	@ 0x80
  usbp->state = USB_SELECTED;
 8001b12:	2303      	movs	r3, #3
 8001b14:	7023      	strb	r3, [r4, #0]
}
 8001b16:	e752      	b.n	80019be <_usb_ep0setup+0x15e>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8001b18:	f894 3082 	ldrb.w	r3, [r4, #130]	@ 0x82
 8001b1c:	2b00      	cmp	r3, #0
 8001b1e:	f47f af08 	bne.w	8001932 <_usb_ep0setup+0xd2>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8001b22:	f894 3084 	ldrb.w	r3, [r4, #132]	@ 0x84
 8001b26:	f013 010f 	ands.w	r1, r3, #15
 8001b2a:	f43f af48 	beq.w	80019be <_usb_ep0setup+0x15e>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8001b2e:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 8001b32:	061e      	lsls	r6, r3, #24
 8001b34:	eb02 1241 	add.w	r2, r2, r1, lsl #5
 8001b38:	d472      	bmi.n	8001c20 <_usb_ep0setup+0x3c0>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8001b3a:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	@ 0xb00
 8001b3e:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8001b42:	f8c2 3b00 	str.w	r3, [r2, #2816]	@ 0xb00
}
 8001b46:	e73a      	b.n	80019be <_usb_ep0setup+0x15e>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8001b48:	f894 3082 	ldrb.w	r3, [r4, #130]	@ 0x82
 8001b4c:	2b01      	cmp	r3, #1
 8001b4e:	f47f aef0 	bne.w	8001932 <_usb_ep0setup+0xd2>
      usbp->status &= ~2U;
 8001b52:	f8b4 3088 	ldrh.w	r3, [r4, #136]	@ 0x88
 8001b56:	f023 0302 	bic.w	r3, r3, #2
 8001b5a:	f8a4 3088 	strh.w	r3, [r4, #136]	@ 0x88
      return true;
 8001b5e:	e72e      	b.n	80019be <_usb_ep0setup+0x15e>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001b60:	f640 4102 	movw	r1, #3074	@ 0xc02
 8001b64:	428a      	cmp	r2, r1
 8001b66:	f47f aee4 	bne.w	8001932 <_usb_ep0setup+0xd2>
 8001b6a:	4a34      	ldr	r2, [pc, #208]	@ (8001c3c <_usb_ep0setup+0x3dc>)
 8001b6c:	e6db      	b.n	8001926 <_usb_ep0setup+0xc6>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8001b6e:	4834      	ldr	r0, [pc, #208]	@ (8001c40 <_usb_ep0setup+0x3e0>)
 8001b70:	f7ff f8ee 	bl	8000d50 <chSysHalt>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8001b74:	f894 3082 	ldrb.w	r3, [r4, #130]	@ 0x82
 8001b78:	2b00      	cmp	r3, #0
 8001b7a:	f47f aeda 	bne.w	8001932 <_usb_ep0setup+0xd2>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8001b7e:	f894 3084 	ldrb.w	r3, [r4, #132]	@ 0x84
 8001b82:	f013 010f 	ands.w	r1, r3, #15
 8001b86:	f43f af1a 	beq.w	80019be <_usb_ep0setup+0x15e>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8001b8a:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 8001b8e:	061d      	lsls	r5, r3, #24
 8001b90:	eb02 1241 	add.w	r2, r2, r1, lsl #5
 8001b94:	d43d      	bmi.n	8001c12 <_usb_ep0setup+0x3b2>
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8001b96:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	@ 0xb00
 8001b9a:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8001b9e:	f8c2 3b00 	str.w	r3, [r2, #2816]	@ 0xb00
}
 8001ba2:	e70c      	b.n	80019be <_usb_ep0setup+0x15e>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8001ba4:	2201      	movs	r2, #1
 8001ba6:	f104 008b 	add.w	r0, r4, #139	@ 0x8b
 8001baa:	67e5      	str	r5, [r4, #124]	@ 0x7c
 8001bac:	4611      	mov	r1, r2
 8001bae:	e9c4 021d 	strd	r0, r2, [r4, #116]	@ 0x74
    return true;
 8001bb2:	e670      	b.n	8001896 <_usb_ep0setup+0x36>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8001bb4:	4823      	ldr	r0, [pc, #140]	@ (8001c44 <_usb_ep0setup+0x3e4>)
 8001bb6:	f7ff f8cb 	bl	8000d50 <chSysHalt>
  ctl = usbp->otg->ie[ep].DIEPCTL;
 8001bba:	3148      	adds	r1, #72	@ 0x48
 8001bbc:	0149      	lsls	r1, r1, #5
 8001bbe:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DIEPCTL_USBAEP))
 8001bc0:	040d      	lsls	r5, r1, #16
 8001bc2:	f57f aeb8 	bpl.w	8001936 <_usb_ep0setup+0xd6>
 8001bc6:	e781      	b.n	8001acc <_usb_ep0setup+0x26c>
 8001bc8:	2330      	movs	r3, #48	@ 0x30
 8001bca:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 8001bce:	7823      	ldrb	r3, [r4, #0]
 8001bd0:	2b04      	cmp	r3, #4
 8001bd2:	d12c      	bne.n	8001c2e <_usb_ep0setup+0x3ce>
  usbp->transmitting &= 1U;
 8001bd4:	68a3      	ldr	r3, [r4, #8]
    usbp->epc[i] = NULL;
 8001bd6:	2220      	movs	r2, #32
 8001bd8:	4629      	mov	r1, r5
 8001bda:	f104 0010 	add.w	r0, r4, #16
  usbp->transmitting &= 1U;
 8001bde:	f003 1301 	and.w	r3, r3, #65537	@ 0x10001
 8001be2:	60a3      	str	r3, [r4, #8]
    usbp->epc[i] = NULL;
 8001be4:	f004 fb24 	bl	8006230 <memset>
  otg_disable_ep(usbp);
 8001be8:	e9d4 0124 	ldrd	r0, r1, [r4, #144]	@ 0x90
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8001bec:	680b      	ldr	r3, [r1, #0]
 8001bee:	f8c4 3098 	str.w	r3, [r4, #152]	@ 0x98
  otg_disable_ep(usbp);
 8001bf2:	f7ff f8dd 	bl	8000db0 <otg_disable_ep.isra.0>
 8001bf6:	f385 8811 	msr	BASEPRI, r5
        usbp->state = USB_SELECTED;
 8001bfa:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8001bfc:	6863      	ldr	r3, [r4, #4]
        usbp->configuration = 0U;
 8001bfe:	f884 508b 	strb.w	r5, [r4, #139]	@ 0x8b
        usbp->state = USB_SELECTED;
 8001c02:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8001c04:	681b      	ldr	r3, [r3, #0]
 8001c06:	2b00      	cmp	r3, #0
 8001c08:	f43f af3c 	beq.w	8001a84 <_usb_ep0setup+0x224>
 8001c0c:	4620      	mov	r0, r4
 8001c0e:	4798      	blx	r3
 8001c10:	e738      	b.n	8001a84 <_usb_ep0setup+0x224>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8001c12:	f8d2 3900 	ldr.w	r3, [r2, #2304]	@ 0x900
 8001c16:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8001c1a:	f8c2 3900 	str.w	r3, [r2, #2304]	@ 0x900
}
 8001c1e:	e6ce      	b.n	80019be <_usb_ep0setup+0x15e>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8001c20:	f8d2 3900 	ldr.w	r3, [r2, #2304]	@ 0x900
 8001c24:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8001c28:	f8c2 3900 	str.w	r3, [r2, #2304]	@ 0x900
}
 8001c2c:	e6c7      	b.n	80019be <_usb_ep0setup+0x15e>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 8001c2e:	4806      	ldr	r0, [pc, #24]	@ (8001c48 <_usb_ep0setup+0x3e8>)
 8001c30:	f7ff f88e 	bl	8000d50 <chSysHalt>
 8001c34:	08007434 	.word	0x08007434
 8001c38:	08007438 	.word	0x08007438
 8001c3c:	0800743c 	.word	0x0800743c
 8001c40:	080074c4 	.word	0x080074c4
 8001c44:	080074a4 	.word	0x080074a4
 8001c48:	0800741c 	.word	0x0800741c
 8001c4c:	00000000 	.word	0x00000000

08001c50 <usbInitEndpointI>:
                      const USBEndpointConfig *epcp) {
 8001c50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  osalDbgAssert(usbp->state == USB_ACTIVE,
 8001c52:	7803      	ldrb	r3, [r0, #0]
 8001c54:	2b04      	cmp	r3, #4
 8001c56:	f040 80b1 	bne.w	8001dbc <usbInitEndpointI+0x16c>
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 8001c5a:	eb00 0481 	add.w	r4, r0, r1, lsl #2
 8001c5e:	fa0f fc81 	sxth.w	ip, r1
 8001c62:	68e3      	ldr	r3, [r4, #12]
 8001c64:	2b00      	cmp	r3, #0
 8001c66:	f040 80a9 	bne.w	8001dbc <usbInitEndpointI+0x16c>
  if (epcp->in_state != NULL) {
 8001c6a:	6955      	ldr	r5, [r2, #20]
  usbp->epc[ep] = epcp;
 8001c6c:	60e2      	str	r2, [r4, #12]
  if (epcp->in_state != NULL) {
 8001c6e:	b11d      	cbz	r5, 8001c78 <usbInitEndpointI+0x28>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8001c70:	602b      	str	r3, [r5, #0]
 8001c72:	606b      	str	r3, [r5, #4]
 8001c74:	60ab      	str	r3, [r5, #8]
 8001c76:	60eb      	str	r3, [r5, #12]
  if (epcp->out_state != NULL) {
 8001c78:	6993      	ldr	r3, [r2, #24]
 8001c7a:	b123      	cbz	r3, 8001c86 <usbInitEndpointI+0x36>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8001c7c:	2200      	movs	r2, #0
 8001c7e:	601a      	str	r2, [r3, #0]
 8001c80:	605a      	str	r2, [r3, #4]
 8001c82:	609a      	str	r2, [r3, #8]
 8001c84:	60da      	str	r2, [r3, #12]
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8001c86:	68e3      	ldr	r3, [r4, #12]
  otgp->oe[ep].DOEPTSIZ = 0;
 8001c88:	2600      	movs	r6, #0
  stm32_otg_t *otgp = usbp->otg;
 8001c8a:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8001c8e:	681c      	ldr	r4, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 8001c90:	699f      	ldr	r7, [r3, #24]
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8001c92:	f004 0403 	and.w	r4, r4, #3
 8001c96:	1e65      	subs	r5, r4, #1
 8001c98:	2d02      	cmp	r5, #2
 8001c9a:	4d4b      	ldr	r5, [pc, #300]	@ (8001dc8 <usbInitEndpointI+0x178>)
 8001c9c:	bf98      	it	ls
 8001c9e:	eb05 4584 	addls.w	r5, r5, r4, lsl #18
  otgp->oe[ep].DOEPTSIZ = 0;
 8001ca2:	eb02 1441 	add.w	r4, r2, r1, lsl #5
 8001ca6:	f8c4 6b10 	str.w	r6, [r4, #2832]	@ 0xb10
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8001caa:	f101 0410 	add.w	r4, r1, #16
 8001cae:	2601      	movs	r6, #1
 8001cb0:	fa06 fe04 	lsl.w	lr, r6, r4
  otgp->oe[ep].DOEPTSIZ = 0;
 8001cb4:	014c      	lsls	r4, r1, #5
  if (usbp->epc[ep]->out_state != NULL) {
 8001cb6:	2f00      	cmp	r7, #0
 8001cb8:	d046      	beq.n	8001d48 <usbInitEndpointI+0xf8>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8001cba:	8a5f      	ldrh	r7, [r3, #18]
 8001cbc:	f101 0658 	add.w	r6, r1, #88	@ 0x58
  otgp->ie[ep].DIEPTSIZ = 0;
 8001cc0:	4414      	add	r4, r2
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8001cc2:	0176      	lsls	r6, r6, #5
 8001cc4:	432f      	orrs	r7, r5
 8001cc6:	5197      	str	r7, [r2, r6]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8001cc8:	f8d2 681c 	ldr.w	r6, [r2, #2076]	@ 0x81c
 8001ccc:	ea46 060e 	orr.w	r6, r6, lr
 8001cd0:	f8c2 681c 	str.w	r6, [r2, #2076]	@ 0x81c
  otgp->ie[ep].DIEPTSIZ = 0;
 8001cd4:	2600      	movs	r6, #0
 8001cd6:	f8c4 6910 	str.w	r6, [r4, #2320]	@ 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 8001cda:	695c      	ldr	r4, [r3, #20]
 8001cdc:	2c00      	cmp	r4, #0
 8001cde:	d048      	beq.n	8001d72 <usbInitEndpointI+0x122>
    if (usbp->epc[ep]->in_multiplier > 1)
 8001ce0:	8b9c      	ldrh	r4, [r3, #28]
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8001ce2:	f8b3 c010 	ldrh.w	ip, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8001ce6:	2c01      	cmp	r4, #1
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8001ce8:	ea4f 039c 	mov.w	r3, ip, lsr #2
      fsize *= usbp->epc[ep]->in_multiplier;
 8001cec:	bf88      	it	hi
 8001cee:	4363      	mulhi	r3, r4
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8001cf0:	e9d0 4625 	ldrd	r4, r6, [r0, #148]	@ 0x94
 8001cf4:	6867      	ldr	r7, [r4, #4]
  usbp->pmnext += size;
 8001cf6:	199c      	adds	r4, r3, r6
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8001cf8:	041b      	lsls	r3, r3, #16
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8001cfa:	42bc      	cmp	r4, r7
  usbp->pmnext += size;
 8001cfc:	f8c0 4098 	str.w	r4, [r0, #152]	@ 0x98
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8001d00:	d85f      	bhi.n	8001dc2 <usbInitEndpointI+0x172>
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8001d02:	f101 003f 	add.w	r0, r1, #63	@ 0x3f
 8001d06:	4333      	orrs	r3, r6
 8001d08:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8001d0c:	6043      	str	r3, [r0, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8001d0e:	018b      	lsls	r3, r1, #6
 8001d10:	f043 0320 	orr.w	r3, r3, #32
 8001d14:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8001d16:	6913      	ldr	r3, [r2, #16]
 8001d18:	0698      	lsls	r0, r3, #26
 8001d1a:	d4fc      	bmi.n	8001d16 <usbInitEndpointI+0xc6>
 8001d1c:	482b      	ldr	r0, [pc, #172]	@ (8001dcc <usbInitEndpointI+0x17c>)
 8001d1e:	6844      	ldr	r4, [r0, #4]
 8001d20:	6843      	ldr	r3, [r0, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8001d22:	1b1b      	subs	r3, r3, r4
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8001d24:	2b11      	cmp	r3, #17
 8001d26:	d9fb      	bls.n	8001d20 <usbInitEndpointI+0xd0>
                           DIEPCTL_TXFNUM(ep) |
 8001d28:	ea4c 5c81 	orr.w	ip, ip, r1, lsl #22
    otgp->ie[ep].DIEPCTL = ctl |
 8001d2c:	f101 0048 	add.w	r0, r1, #72	@ 0x48
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8001d30:	2301      	movs	r3, #1
    otgp->ie[ep].DIEPCTL = ctl |
 8001d32:	0140      	lsls	r0, r0, #5
                           DIEPCTL_TXFNUM(ep) |
 8001d34:	ea4c 0505 	orr.w	r5, ip, r5
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8001d38:	408b      	lsls	r3, r1
    otgp->ie[ep].DIEPCTL = ctl |
 8001d3a:	5015      	str	r5, [r2, r0]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8001d3c:	f8d2 081c 	ldr.w	r0, [r2, #2076]	@ 0x81c
 8001d40:	4303      	orrs	r3, r0
 8001d42:	f8c2 381c 	str.w	r3, [r2, #2076]	@ 0x81c
}
 8001d46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8001d48:	eb02 174c 	add.w	r7, r2, ip, lsl #5
  otgp->ie[ep].DIEPTSIZ = 0;
 8001d4c:	4414      	add	r4, r2
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8001d4e:	f8d7 6b00 	ldr.w	r6, [r7, #2816]	@ 0xb00
 8001d52:	f426 4600 	bic.w	r6, r6, #32768	@ 0x8000
 8001d56:	f8c7 6b00 	str.w	r6, [r7, #2816]	@ 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8001d5a:	f8d2 681c 	ldr.w	r6, [r2, #2076]	@ 0x81c
 8001d5e:	ea26 060e 	bic.w	r6, r6, lr
 8001d62:	f8c2 681c 	str.w	r6, [r2, #2076]	@ 0x81c
  otgp->ie[ep].DIEPTSIZ = 0;
 8001d66:	2600      	movs	r6, #0
 8001d68:	f8c4 6910 	str.w	r6, [r4, #2320]	@ 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 8001d6c:	695c      	ldr	r4, [r3, #20]
 8001d6e:	2c00      	cmp	r4, #0
 8001d70:	d1b6      	bne.n	8001ce0 <usbInitEndpointI+0x90>
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8001d72:	f101 033f 	add.w	r3, r1, #63	@ 0x3f
 8001d76:	4816      	ldr	r0, [pc, #88]	@ (8001dd0 <usbInitEndpointI+0x180>)
 8001d78:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8001d7c:	6058      	str	r0, [r3, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8001d7e:	018b      	lsls	r3, r1, #6
 8001d80:	f043 0320 	orr.w	r3, r3, #32
 8001d84:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8001d86:	6913      	ldr	r3, [r2, #16]
 8001d88:	069b      	lsls	r3, r3, #26
 8001d8a:	d4fc      	bmi.n	8001d86 <usbInitEndpointI+0x136>
 8001d8c:	480f      	ldr	r0, [pc, #60]	@ (8001dcc <usbInitEndpointI+0x17c>)
 8001d8e:	6844      	ldr	r4, [r0, #4]
 8001d90:	6843      	ldr	r3, [r0, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8001d92:	1b1b      	subs	r3, r3, r4
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8001d94:	2b11      	cmp	r3, #17
 8001d96:	d9fb      	bls.n	8001d90 <usbInitEndpointI+0x140>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8001d98:	eb02 1c4c 	add.w	ip, r2, ip, lsl #5
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8001d9c:	2301      	movs	r3, #1
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8001d9e:	f8dc 0900 	ldr.w	r0, [ip, #2304]	@ 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8001da2:	fa03 f101 	lsl.w	r1, r3, r1
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8001da6:	f420 4000 	bic.w	r0, r0, #32768	@ 0x8000
 8001daa:	f8cc 0900 	str.w	r0, [ip, #2304]	@ 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8001dae:	f8d2 381c 	ldr.w	r3, [r2, #2076]	@ 0x81c
 8001db2:	ea23 0301 	bic.w	r3, r3, r1
 8001db6:	f8c2 381c 	str.w	r3, [r2, #2076]	@ 0x81c
 8001dba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  osalDbgAssert(usbp->state == USB_ACTIVE,
 8001dbc:	4805      	ldr	r0, [pc, #20]	@ (8001dd4 <usbInitEndpointI+0x184>)
 8001dbe:	f7fe ffc7 	bl	8000d50 <chSysHalt>
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8001dc2:	4805      	ldr	r0, [pc, #20]	@ (8001dd8 <usbInitEndpointI+0x188>)
 8001dc4:	f7fe ffc4 	bl	8000d50 <chSysHalt>
 8001dc8:	10008000 	.word	0x10008000
 8001dcc:	e0001000 	.word	0xe0001000
 8001dd0:	02000400 	.word	0x02000400
 8001dd4:	08007450 	.word	0x08007450
 8001dd8:	08007440 	.word	0x08007440
 8001ddc:	00000000 	.word	0x00000000

08001de0 <usb_event>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8001de0:	b538      	push	{r3, r4, r5, lr}
  switch (event) {
 8001de2:	2905      	cmp	r1, #5
 8001de4:	d81e      	bhi.n	8001e24 <usb_event+0x44>
 8001de6:	e8df f001 	tbb	[pc, r1]
 8001dea:	1d03      	.short	0x1d03
 8001dec:	1e03032d 	.word	0x1e03032d
 8001df0:	2330      	movs	r3, #48	@ 0x30
 8001df2:	f383 8811 	msr	BASEPRI, r3
  if (bqIsSuspendedX(&sdup->ibqueue) && bqIsSuspendedX(&sdup->obqueue)) {
 8001df6:	4c2c      	ldr	r4, [pc, #176]	@ (8001ea8 <usb_event+0xc8>)
 8001df8:	7d23      	ldrb	r3, [r4, #20]
 8001dfa:	b113      	cbz	r3, 8001e02 <usb_event+0x22>
 8001dfc:	f894 304c 	ldrb.w	r3, [r4, #76]	@ 0x4c
 8001e00:	b96b      	cbnz	r3, 8001e1e <usb_event+0x3e>
 8001e02:	2102      	movs	r1, #2
 8001e04:	4829      	ldr	r0, [pc, #164]	@ (8001eac <usb_event+0xcc>)
  bqSuspendI(&sdup->ibqueue);
 8001e06:	2501      	movs	r5, #1
 8001e08:	f7ff fbda 	bl	80015c0 <chEvtBroadcastFlagsI>
  chThdDequeueAllI(tqp, msg);
 8001e0c:	4828      	ldr	r0, [pc, #160]	@ (8001eb0 <usb_event+0xd0>)
 8001e0e:	7525      	strb	r5, [r4, #20]
 8001e10:	f7ff fce6 	bl	80017e0 <chThdDequeueAllI.constprop.0>
 8001e14:	4827      	ldr	r0, [pc, #156]	@ (8001eb4 <usb_event+0xd4>)
  bqSuspendI(&sdup->obqueue);
 8001e16:	f884 504c 	strb.w	r5, [r4, #76]	@ 0x4c
 8001e1a:	f7ff fce1 	bl	80017e0 <chThdDequeueAllI.constprop.0>
 8001e1e:	2300      	movs	r3, #0
 8001e20:	f383 8811 	msr	BASEPRI, r3
}
 8001e24:	bd38      	pop	{r3, r4, r5, pc}
 8001e26:	2330      	movs	r3, #48	@ 0x30
 8001e28:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 8001e2c:	2101      	movs	r1, #1
 8001e2e:	481f      	ldr	r0, [pc, #124]	@ (8001eac <usb_event+0xcc>)
 8001e30:	f7ff fbc6 	bl	80015c0 <chEvtBroadcastFlagsI>
  bqResumeX(&sdup->ibqueue);
 8001e34:	4a1c      	ldr	r2, [pc, #112]	@ (8001ea8 <usb_event+0xc8>)
 8001e36:	2300      	movs	r3, #0
 8001e38:	7513      	strb	r3, [r2, #20]
  bqResumeX(&sdup->obqueue);
 8001e3a:	f882 304c 	strb.w	r3, [r2, #76]	@ 0x4c
 8001e3e:	f383 8811 	msr	BASEPRI, r3
 8001e42:	bd38      	pop	{r3, r4, r5, pc}
 8001e44:	4604      	mov	r4, r0
 8001e46:	2330      	movs	r3, #48	@ 0x30
 8001e48:	f383 8811 	msr	BASEPRI, r3
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8001e4c:	4a1a      	ldr	r2, [pc, #104]	@ (8001eb8 <usb_event+0xd8>)
 8001e4e:	2101      	movs	r1, #1
 8001e50:	f7ff fefe 	bl	8001c50 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 8001e54:	4620      	mov	r0, r4
  ibqp->bcounter  = 0;
 8001e56:	4c14      	ldr	r4, [pc, #80]	@ (8001ea8 <usb_event+0xc8>)
 8001e58:	2102      	movs	r1, #2
 8001e5a:	4a18      	ldr	r2, [pc, #96]	@ (8001ebc <usb_event+0xdc>)
 8001e5c:	2500      	movs	r5, #0
 8001e5e:	f7ff fef7 	bl	8001c50 <usbInitEndpointI>
void ibqResetI(input_buffers_queue_t *ibqp) {
 8001e62:	6b23      	ldr	r3, [r4, #48]	@ 0x30
  chThdDequeueAllI(tqp, msg);
 8001e64:	f104 000c 	add.w	r0, r4, #12
  ibqp->bcounter  = 0;
 8001e68:	61a5      	str	r5, [r4, #24]
  ibqp->ptr       = NULL;
 8001e6a:	6365      	str	r5, [r4, #52]	@ 0x34
 8001e6c:	63a5      	str	r5, [r4, #56]	@ 0x38
  ibqp->bwrptr    = ibqp->buffers;
 8001e6e:	e9c4 3307 	strd	r3, r3, [r4, #28]
 8001e72:	f7ff fcb5 	bl	80017e0 <chThdDequeueAllI.constprop.0>
 8001e76:	f104 0044 	add.w	r0, r4, #68	@ 0x44
  bqResumeX(&sdup->ibqueue);
 8001e7a:	7525      	strb	r5, [r4, #20]
  obqp->bcounter  = bqSizeX(obqp);
 8001e7c:	e9d4 2319 	ldrd	r2, r3, [r4, #100]	@ 0x64
  obqp->ptr       = NULL;
 8001e80:	e9c4 551b 	strd	r5, r5, [r4, #108]	@ 0x6c
  obqp->bcounter  = bqSizeX(obqp);
 8001e84:	6522      	str	r2, [r4, #80]	@ 0x50
  obqp->bwrptr    = obqp->buffers;
 8001e86:	e9c4 3315 	strd	r3, r3, [r4, #84]	@ 0x54
 8001e8a:	f7ff fca9 	bl	80017e0 <chThdDequeueAllI.constprop.0>
  chEvtBroadcastFlagsI(esp, flags);
 8001e8e:	2101      	movs	r1, #1
 8001e90:	1d20      	adds	r0, r4, #4
  bqResumeX(&sdup->obqueue);
 8001e92:	f884 504c 	strb.w	r5, [r4, #76]	@ 0x4c
 8001e96:	f7ff fb93 	bl	80015c0 <chEvtBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
 8001e9a:	4620      	mov	r0, r4
 8001e9c:	f7ff f810 	bl	8000ec0 <sdu_start_receive.isra.0>
 8001ea0:	f385 8811 	msr	BASEPRI, r5
}
 8001ea4:	bd38      	pop	{r3, r4, r5, pc}
 8001ea6:	bf00      	nop
 8001ea8:	24006778 	.word	0x24006778
 8001eac:	2400677c 	.word	0x2400677c
 8001eb0:	24006784 	.word	0x24006784
 8001eb4:	240067bc 	.word	0x240067bc
 8001eb8:	080070e4 	.word	0x080070e4
 8001ebc:	080070c0 	.word	0x080070c0

08001ec0 <get_history>:
    shp->sh_end -= shp->sh_size;
  *(shp->sh_buffer + shp->sh_end) = 0;
  shp->sh_cur = 0;
}

static int get_history(ShellHistory *shp, char *line, int dir) {
 8001ec0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (shp == NULL)
    return -1;

  /* Count the number of lines saved in the buffer */
  int idx = shp->sh_beg;
  while (idx != shp->sh_end) {
 8001ec4:	e9d0 4502 	ldrd	r4, r5, [r0, #8]
static int get_history(ShellHistory *shp, char *line, int dir) {
 8001ec8:	4606      	mov	r6, r0
 8001eca:	460f      	mov	r7, r1
  while (idx != shp->sh_end) {
 8001ecc:	42ac      	cmp	r4, r5
 8001ece:	d05b      	beq.n	8001f88 <get_history+0xc8>
  int idx = shp->sh_beg;
 8001ed0:	4623      	mov	r3, r4
  int count=0;
 8001ed2:	2100      	movs	r1, #0
    idx += *(shp->sh_buffer + idx) + 1;
    if (idx >= shp->sh_size)
 8001ed4:	e9d0 e000 	ldrd	lr, r0, [r0]
    idx += *(shp->sh_buffer + idx) + 1;
 8001ed8:	f81e c003 	ldrb.w	ip, [lr, r3]
      idx -= shp->sh_size;
    count++;
 8001edc:	3101      	adds	r1, #1
    idx += *(shp->sh_buffer + idx) + 1;
 8001ede:	f10c 0c01 	add.w	ip, ip, #1
 8001ee2:	4463      	add	r3, ip
    if (idx >= shp->sh_size)
 8001ee4:	4298      	cmp	r0, r3
      idx -= shp->sh_size;
 8001ee6:	bfd8      	it	le
 8001ee8:	1a1b      	suble	r3, r3, r0
  while (idx != shp->sh_end) {
 8001eea:	42ab      	cmp	r3, r5
 8001eec:	d1f4      	bne.n	8001ed8 <get_history+0x18>
  }

  if (dir == SHELL_HIST_DIR_FW) {
 8001eee:	2a01      	cmp	r2, #1
    if (shp->sh_cur > 0)
 8001ef0:	f8d6 e010 	ldr.w	lr, [r6, #16]
  if (dir == SHELL_HIST_DIR_FW) {
 8001ef4:	d040      	beq.n	8001f78 <get_history+0xb8>
      shp->sh_cur -= 2;
    else
      return 0;
  }

  if (count >= shp->sh_cur) {
 8001ef6:	4571      	cmp	r1, lr
 8001ef8:	db56      	blt.n	8001fa8 <get_history+0xe8>
    idx = shp->sh_beg;
    int i = 0;
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8001efa:	42ac      	cmp	r4, r5
      idx += *(shp->sh_buffer + idx) + 1;
 8001efc:	f8d6 9000 	ldr.w	r9, [r6]
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8001f00:	d015      	beq.n	8001f2e <get_history+0x6e>
 8001f02:	3901      	subs	r1, #1
 8001f04:	4571      	cmp	r1, lr
 8001f06:	d01e      	beq.n	8001f46 <get_history+0x86>
      if (idx >= shp->sh_size)
 8001f08:	f8d6 8004 	ldr.w	r8, [r6, #4]
    int i = 0;
 8001f0c:	2000      	movs	r0, #0
 8001f0e:	e001      	b.n	8001f14 <get_history+0x54>
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8001f10:	45f4      	cmp	ip, lr
 8001f12:	d018      	beq.n	8001f46 <get_history+0x86>
      idx += *(shp->sh_buffer + idx) + 1;
 8001f14:	f819 3004 	ldrb.w	r3, [r9, r4]
        idx -= shp->sh_size;
      i++;
 8001f18:	3001      	adds	r0, #1
      idx += *(shp->sh_buffer + idx) + 1;
 8001f1a:	3301      	adds	r3, #1
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8001f1c:	eba1 0c00 	sub.w	ip, r1, r0
      idx += *(shp->sh_buffer + idx) + 1;
 8001f20:	441c      	add	r4, r3
      if (idx >= shp->sh_size)
 8001f22:	45a0      	cmp	r8, r4
        idx -= shp->sh_size;
 8001f24:	bfd8      	it	le
 8001f26:	eba4 0408 	suble.w	r4, r4, r8
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8001f2a:	42ac      	cmp	r4, r5
 8001f2c:	d1f0      	bne.n	8001f10 <get_history+0x50>
    }

    int length = *(shp->sh_buffer + idx);
 8001f2e:	f819 4005 	ldrb.w	r4, [r9, r5]

    if (length > 0) {
 8001f32:	b96c      	cbnz	r4, 8001f50 <get_history+0x90>
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
        memcpy(line + part_len, shp->sh_buffer, length - part_len);
      }
      return length;
    }
    else if (dir == SHELL_HIST_DIR_FW) {
 8001f34:	2a01      	cmp	r2, #1
 8001f36:	d137      	bne.n	8001fa8 <get_history+0xe8>
      shp->sh_cur++;
 8001f38:	f10e 0301 	add.w	r3, lr, #1
 8001f3c:	6133      	str	r3, [r6, #16]
      return 0;
 8001f3e:	2400      	movs	r4, #0
      return 0;
    }
  }
  return -1;
}
 8001f40:	4620      	mov	r0, r4
 8001f42:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    idx = shp->sh_beg;
 8001f46:	4625      	mov	r5, r4
    int length = *(shp->sh_buffer + idx);
 8001f48:	f819 4005 	ldrb.w	r4, [r9, r5]
    if (length > 0) {
 8001f4c:	2c00      	cmp	r4, #0
 8001f4e:	d0f1      	beq.n	8001f34 <get_history+0x74>
      shp->sh_cur++;
 8001f50:	f10e 0301 	add.w	r3, lr, #1
      memset(line, 0, SHELL_MAX_LINE_LENGTH);
 8001f54:	2240      	movs	r2, #64	@ 0x40
 8001f56:	2100      	movs	r1, #0
 8001f58:	4638      	mov	r0, r7
      shp->sh_cur++;
 8001f5a:	6133      	str	r3, [r6, #16]
      memset(line, 0, SHELL_MAX_LINE_LENGTH);
 8001f5c:	f004 f968 	bl	8006230 <memset>
      if ((idx + length) < shp->sh_size) {
 8001f60:	6873      	ldr	r3, [r6, #4]
 8001f62:	1962      	adds	r2, r4, r5
        memcpy(line, (shp->sh_buffer + idx + 1), length);
 8001f64:	1c69      	adds	r1, r5, #1
      if ((idx + length) < shp->sh_size) {
 8001f66:	429a      	cmp	r2, r3
 8001f68:	da10      	bge.n	8001f8c <get_history+0xcc>
        memcpy(line, (shp->sh_buffer + idx + 1), length);
 8001f6a:	6833      	ldr	r3, [r6, #0]
 8001f6c:	4622      	mov	r2, r4
 8001f6e:	4638      	mov	r0, r7
 8001f70:	4419      	add	r1, r3
 8001f72:	f7fe fbc5 	bl	8000700 <memcpy>
 8001f76:	e7e3      	b.n	8001f40 <get_history+0x80>
    if (shp->sh_cur > 0)
 8001f78:	f1be 0f00 	cmp.w	lr, #0
 8001f7c:	dddf      	ble.n	8001f3e <get_history+0x7e>
      shp->sh_cur -= 2;
 8001f7e:	f1ae 0e02 	sub.w	lr, lr, #2
 8001f82:	f8c6 e010 	str.w	lr, [r6, #16]
 8001f86:	e7b6      	b.n	8001ef6 <get_history+0x36>
  int count=0;
 8001f88:	2100      	movs	r1, #0
 8001f8a:	e7b0      	b.n	8001eee <get_history+0x2e>
        int part_len = shp->sh_size - idx - 1;
 8001f8c:	1b5b      	subs	r3, r3, r5
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
 8001f8e:	4638      	mov	r0, r7
        int part_len = shp->sh_size - idx - 1;
 8001f90:	1e5d      	subs	r5, r3, #1
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
 8001f92:	6833      	ldr	r3, [r6, #0]
 8001f94:	462a      	mov	r2, r5
 8001f96:	4419      	add	r1, r3
 8001f98:	f7fe fbb2 	bl	8000700 <memcpy>
        memcpy(line + part_len, shp->sh_buffer, length - part_len);
 8001f9c:	1b62      	subs	r2, r4, r5
 8001f9e:	6831      	ldr	r1, [r6, #0]
 8001fa0:	1978      	adds	r0, r7, r5
 8001fa2:	f7fe fbad 	bl	8000700 <memcpy>
 8001fa6:	e7cb      	b.n	8001f40 <get_history+0x80>
    return -1;
 8001fa8:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
 8001fac:	e7c8      	b.n	8001f40 <get_history+0x80>
 8001fae:	bf00      	nop

08001fb0 <chSchGoSleepS>:
  thread_t *otp = __instance_get_currthread(oip);
 8001fb0:	4a1b      	ldr	r2, [pc, #108]	@ (8002020 <chSchGoSleepS+0x70>)
void chSchGoSleepS(tstate_t newstate) {
 8001fb2:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = threadref(currcore->rlist.pqueue.prev);
 8001fb4:	6853      	ldr	r3, [r2, #4]
  thread_t *otp = __instance_get_currthread(oip);
 8001fb6:	68d4      	ldr	r4, [r2, #12]
  chDbgAssert(tp->hdr.pqueue.prio == IDLEPRIO, "not idle thread");
 8001fb8:	6899      	ldr	r1, [r3, #8]
 8001fba:	2901      	cmp	r1, #1
 8001fbc:	d12d      	bne.n	800201a <chSchGoSleepS+0x6a>
  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 8001fbe:	429c      	cmp	r4, r3
 8001fc0:	d028      	beq.n	8002014 <chSchGoSleepS+0x64>
  chDbgAssert(otp->owner == oip, "invalid core");
 8001fc2:	69a3      	ldr	r3, [r4, #24]
 8001fc4:	4293      	cmp	r3, r2
 8001fc6:	d125      	bne.n	8002014 <chSchGoSleepS+0x64>
  ch_priority_queue_t *p = pqp->next;
 8001fc8:	681d      	ldr	r5, [r3, #0]
  otp->state = newstate;
 8001fca:	f884 0024 	strb.w	r0, [r4, #36]	@ 0x24
  pqp->next       = p->next;
 8001fce:	682a      	ldr	r2, [r5, #0]
  pqp->next->prev = pqp;
 8001fd0:	6053      	str	r3, [r2, #4]
  ntp->state = CH_STATE_CURRENT;
 8001fd2:	f885 1024 	strb.w	r1, [r5, #36]	@ 0x24
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8001fd6:	f8b3 1088 	ldrh.w	r1, [r3, #136]	@ 0x88
  pqp->next       = p->next;
 8001fda:	601a      	str	r2, [r3, #0]
 8001fdc:	078a      	lsls	r2, r1, #30
  __instance_set_currthread(oip, ntp);
 8001fde:	60dd      	str	r5, [r3, #12]
 8001fe0:	d505      	bpl.n	8001fee <chSchGoSleepS+0x3e>
  chSysSwitch(ntp, otp);
 8001fe2:	4621      	mov	r1, r4
 8001fe4:	4628      	mov	r0, r5
}
 8001fe6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(ntp, otp);
 8001fea:	f7fe b9f9 	b.w	80003e0 <__port_switch>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8001fee:	f894 2024 	ldrb.w	r2, [r4, #36]	@ 0x24
 8001ff2:	f8d3 108c 	ldr.w	r1, [r3, #140]	@ 0x8c
 8001ff6:	00d3      	lsls	r3, r2, #3
 8001ff8:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8001ffa:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8001ffe:	e9c1 5002 	strd	r5, r0, [r1, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002002:	700b      	strb	r3, [r1, #0]
    trace_next(oip);
 8002004:	f7fe fe84 	bl	8000d10 <trace_next.constprop.0>
 8002008:	4621      	mov	r1, r4
 800200a:	4628      	mov	r0, r5
}
 800200c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(ntp, otp);
 8002010:	f7fe b9e6 	b.w	80003e0 <__port_switch>
  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 8002014:	4803      	ldr	r0, [pc, #12]	@ (8002024 <chSchGoSleepS+0x74>)
 8002016:	f7fe fe9b 	bl	8000d50 <chSysHalt>
 800201a:	4803      	ldr	r0, [pc, #12]	@ (8002028 <chSchGoSleepS+0x78>)
 800201c:	f7fe fe98 	bl	8000d50 <chSysHalt>
 8002020:	24006e20 	.word	0x24006e20
 8002024:	08007250 	.word	0x08007250
 8002028:	0800723c 	.word	0x0800723c
 800202c:	00000000 	.word	0x00000000

08002030 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8002030:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (TIME_INFINITE != timeout) {
 8002034:	1c4b      	adds	r3, r1, #1
  thread_t *tp = __instance_get_currthread(currcore);
 8002036:	4e3c      	ldr	r6, [pc, #240]	@ (8002128 <chSchGoSleepTimeoutS+0xf8>)
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8002038:	b086      	sub	sp, #24
  thread_t *tp = __instance_get_currthread(currcore);
 800203a:	f8d6 900c 	ldr.w	r9, [r6, #12]
  if (TIME_INFINITE != timeout) {
 800203e:	d025      	beq.n	800208c <chSchGoSleepTimeoutS+0x5c>
  return (bool)(dlhp == dlhp->next);
 8002040:	46b0      	mov	r8, r6
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  /* Timer initialization.*/
  vtp->par     = par;
  vtp->func    = vtfunc;
 8002042:	4b3a      	ldr	r3, [pc, #232]	@ (800212c <chSchGoSleepTimeoutS+0xfc>)
 8002044:	4607      	mov	r7, r0
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
 8002046:	460a      	mov	r2, r1
 8002048:	f858 5f10 	ldr.w	r5, [r8, #16]!
  vtp->func    = vtfunc;
 800204c:	9303      	str	r3, [sp, #12]
  vtp->reload  = (sysinterval_t)0;
 800204e:	2300      	movs	r3, #0
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002050:	4545      	cmp	r5, r8
  vtp->par     = par;
 8002052:	f8cd 9010 	str.w	r9, [sp, #16]
  vtp->reload  = (sysinterval_t)0;
 8002056:	9305      	str	r3, [sp, #20]
 8002058:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800205c:	6a58      	ldr	r0, [r3, #36]	@ 0x24
    if (ch_dlist_isempty(&vtlp->dlist)) {
 800205e:	d058      	beq.n	8002112 <chSchGoSleepTimeoutS+0xe2>
 8002060:	69f4      	ldr	r4, [r6, #28]
    if (delta < vtlp->dlist.next->delta) {
 8002062:	68ab      	ldr	r3, [r5, #8]
 8002064:	1b04      	subs	r4, r0, r4
      delta = delay;
 8002066:	190c      	adds	r4, r1, r4
 8002068:	bf28      	it	cs
 800206a:	460c      	movcs	r4, r1
    if (delta < vtlp->dlist.next->delta) {
 800206c:	42a3      	cmp	r3, r4
 800206e:	d835      	bhi.n	80020dc <chSchGoSleepTimeoutS+0xac>
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
 8002070:	429c      	cmp	r4, r3
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");
 8002072:	46ea      	mov	sl, sp
  while (likely(dlp->delta < delta)) {
 8002074:	d805      	bhi.n	8002082 <chSchGoSleepTimeoutS+0x52>
 8002076:	e010      	b.n	800209a <chSchGoSleepTimeoutS+0x6a>

    delta -= dlp->delta;
    dlp = dlp->next;
 8002078:	682d      	ldr	r5, [r5, #0]
    delta -= dlp->delta;
 800207a:	1ae4      	subs	r4, r4, r3
  while (likely(dlp->delta < delta)) {
 800207c:	68ab      	ldr	r3, [r5, #8]
 800207e:	429c      	cmp	r4, r3
 8002080:	d90b      	bls.n	800209a <chSchGoSleepTimeoutS+0x6a>
    chDbgAssert(dlp != dlep, "element already in list");
 8002082:	4555      	cmp	r5, sl
 8002084:	d1f8      	bne.n	8002078 <chSchGoSleepTimeoutS+0x48>
 8002086:	482a      	ldr	r0, [pc, #168]	@ (8002130 <chSchGoSleepTimeoutS+0x100>)
 8002088:	f7fe fe62 	bl	8000d50 <chSysHalt>
    chSchGoSleepS(newstate);
 800208c:	f7ff ff90 	bl	8001fb0 <chSchGoSleepS>
}
 8002090:	f8d9 0028 	ldr.w	r0, [r9, #40]	@ 0x28
 8002094:	b006      	add	sp, #24
 8002096:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  dlp->delta      = delta;
 800209a:	9402      	str	r4, [sp, #8]

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 800209c:	68ab      	ldr	r3, [r5, #8]
  dlp->prev       = dlp->next->prev;
 800209e:	686a      	ldr	r2, [r5, #4]
  dlp->delta -= delta;
 80020a0:	1b1b      	subs	r3, r3, r4
  dlp->next       = dlhp;
 80020a2:	9500      	str	r5, [sp, #0]
  dlp->prev       = dlp->next->prev;
 80020a4:	9201      	str	r2, [sp, #4]
  dlp->prev->next = dlp;
 80020a6:	f8c2 a000 	str.w	sl, [r2]
  dlhp->prev      = dlp;
 80020aa:	e9c5 a301 	strd	sl, r3, [r5, #4]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 80020ae:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80020b2:	61b3      	str	r3, [r6, #24]
    chSchGoSleepS(newstate);
 80020b4:	4638      	mov	r0, r7
 80020b6:	f7ff ff7b 	bl	8001fb0 <chSchGoSleepS>
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {

  chDbgCheckClassI();

  return (bool)(vtp->dlist.next != NULL);
 80020ba:	9b00      	ldr	r3, [sp, #0]
    if (chVTIsArmedI(&vt)) {
 80020bc:	2b00      	cmp	r3, #0
 80020be:	d0e7      	beq.n	8002090 <chSchGoSleepTimeoutS+0x60>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 80020c0:	6932      	ldr	r2, [r6, #16]
 80020c2:	4552      	cmp	r2, sl
 80020c4:	d00e      	beq.n	80020e4 <chSchGoSleepTimeoutS+0xb4>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 80020c6:	689a      	ldr	r2, [r3, #8]
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
 80020c8:	e9dd 1001 	ldrd	r1, r0, [sp, #4]
 80020cc:	4402      	add	r2, r0
 80020ce:	600b      	str	r3, [r1, #0]
 80020d0:	e9c3 1201 	strd	r1, r2, [r3, #4]
    vtp->dlist.next = NULL;

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 80020d4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80020d8:	61b3      	str	r3, [r6, #24]

    return;
 80020da:	e7d9      	b.n	8002090 <chSchGoSleepTimeoutS+0x60>
      vt_set_alarm(now, delay);
 80020dc:	f7ff f860 	bl	80011a0 <vt_set_alarm>
  while (likely(dlp->delta < delta)) {
 80020e0:	68ab      	ldr	r3, [r5, #8]
 80020e2:	e7c5      	b.n	8002070 <chSchGoSleepTimeoutS+0x40>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
  vtp->dlist.next = NULL;
 80020e4:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 80020e6:	4543      	cmp	r3, r8
  dlhp->next       = dlp->next;
 80020e8:	6133      	str	r3, [r6, #16]
  vtp->dlist.next = NULL;
 80020ea:	9200      	str	r2, [sp, #0]
  dlhp->next->prev = dlhp;
 80020ec:	f8c3 8004 	str.w	r8, [r3, #4]
  if (ch_dlist_isempty(&vtlp->dlist)) {
 80020f0:	d015      	beq.n	800211e <chSchGoSleepTimeoutS+0xee>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 80020f2:	689a      	ldr	r2, [r3, #8]
 80020f4:	9802      	ldr	r0, [sp, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80020f6:	69f1      	ldr	r1, [r6, #28]
  vtlp->dlist.next->delta += vtp->dlist.delta;
 80020f8:	4402      	add	r2, r0
 80020fa:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 80020fe:	609a      	str	r2, [r3, #8]
 8002100:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 8002102:	1a43      	subs	r3, r0, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8002104:	429a      	cmp	r2, r3
 8002106:	d9c3      	bls.n	8002090 <chSchGoSleepTimeoutS+0x60>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8002108:	1a09      	subs	r1, r1, r0

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 800210a:	4411      	add	r1, r2
 800210c:	f7ff f848 	bl	80011a0 <vt_set_alarm>
 8002110:	e7be      	b.n	8002090 <chSchGoSleepTimeoutS+0x60>
      vt_insert_first(vtlp, vtp, now, delay);
 8002112:	46ea      	mov	sl, sp
 8002114:	4601      	mov	r1, r0
 8002116:	4650      	mov	r0, sl
 8002118:	f7ff f9ba 	bl	8001490 <vt_insert_first.constprop.0>
      return;
 800211c:	e7ca      	b.n	80020b4 <chSchGoSleepTimeoutS+0x84>
  STM32_ST_TIM->DIER = 0U;
 800211e:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002122:	60da      	str	r2, [r3, #12]
}
 8002124:	e7b4      	b.n	8002090 <chSchGoSleepTimeoutS+0x60>
 8002126:	bf00      	nop
 8002128:	24006e20 	.word	0x24006e20
 800212c:	08001571 	.word	0x08001571
 8002130:	0800737c 	.word	0x0800737c
	...

08002140 <obqGetEmptyBufferTimeoutS>:
  while (obqIsFullI(obqp)) {
 8002140:	68c3      	ldr	r3, [r0, #12]
                                sysinterval_t timeout) {
 8002142:	b570      	push	{r4, r5, r6, lr}
 8002144:	4604      	mov	r4, r0
  while (obqIsFullI(obqp)) {
 8002146:	b9bb      	cbnz	r3, 8002178 <obqGetEmptyBufferTimeoutS+0x38>
    if (obqp->suspended) {
 8002148:	7a03      	ldrb	r3, [r0, #8]
 800214a:	bb13      	cbnz	r3, 8002192 <obqGetEmptyBufferTimeoutS+0x52>
  return __sch_get_currthread();
 800214c:	4e14      	ldr	r6, [pc, #80]	@ (80021a0 <obqGetEmptyBufferTimeoutS+0x60>)
 800214e:	460d      	mov	r5, r1
 8002150:	68f3      	ldr	r3, [r6, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8002152:	b919      	cbnz	r1, 800215c <obqGetEmptyBufferTimeoutS+0x1c>
 8002154:	e01a      	b.n	800218c <obqGetEmptyBufferTimeoutS+0x4c>
 8002156:	7a23      	ldrb	r3, [r4, #8]
 8002158:	b9db      	cbnz	r3, 8002192 <obqGetEmptyBufferTimeoutS+0x52>
 800215a:	68f3      	ldr	r3, [r6, #12]
  p->prev       = qp->prev;
 800215c:	6862      	ldr	r2, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800215e:	4629      	mov	r1, r5
  p->next       = qp;
 8002160:	601c      	str	r4, [r3, #0]
 8002162:	2004      	movs	r0, #4
  p->prev       = qp->prev;
 8002164:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8002166:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
 8002168:	6063      	str	r3, [r4, #4]
 800216a:	f7ff ff61 	bl	8002030 <chSchGoSleepTimeoutS>
    if (msg < MSG_OK) {
 800216e:	2800      	cmp	r0, #0
 8002170:	db0b      	blt.n	800218a <obqGetEmptyBufferTimeoutS+0x4a>
  while (obqIsFullI(obqp)) {
 8002172:	68e3      	ldr	r3, [r4, #12]
 8002174:	2b00      	cmp	r3, #0
 8002176:	d0ee      	beq.n	8002156 <obqGetEmptyBufferTimeoutS+0x16>
  osalDbgAssert(!obqIsFullI(obqp), "still full");
 8002178:	68e3      	ldr	r3, [r4, #12]
 800217a:	b16b      	cbz	r3, 8002198 <obqGetEmptyBufferTimeoutS+0x58>
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800217c:	6923      	ldr	r3, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
 800217e:	2000      	movs	r0, #0
 8002180:	69e1      	ldr	r1, [r4, #28]
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8002182:	1d1a      	adds	r2, r3, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
 8002184:	440b      	add	r3, r1
 8002186:	e9c4 230a 	strd	r2, r3, [r4, #40]	@ 0x28
}
 800218a:	bd70      	pop	{r4, r5, r6, pc}
      return msg;
 800218c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 8002190:	bd70      	pop	{r4, r5, r6, pc}
      return MSG_RESET;
 8002192:	f06f 0001 	mvn.w	r0, #1
}
 8002196:	bd70      	pop	{r4, r5, r6, pc}
  osalDbgAssert(!obqIsFullI(obqp), "still full");
 8002198:	4802      	ldr	r0, [pc, #8]	@ (80021a4 <obqGetEmptyBufferTimeoutS+0x64>)
 800219a:	f7fe fdd9 	bl	8000d50 <chSysHalt>
 800219e:	bf00      	nop
 80021a0:	24006e20 	.word	0x24006e20
 80021a4:	08007500 	.word	0x08007500
	...

080021b0 <obqWriteTimeout>:
                       size_t n, sysinterval_t timeout) {
 80021b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80021b4:	b083      	sub	sp, #12
 80021b6:	4605      	mov	r5, r0
 80021b8:	460c      	mov	r4, r1
 80021ba:	4617      	mov	r7, r2
 80021bc:	f04f 0830 	mov.w	r8, #48	@ 0x30
 80021c0:	9301      	str	r3, [sp, #4]
 80021c2:	f388 8811 	msr	BASEPRI, r8
  size_t w = 0;
 80021c6:	2600      	movs	r6, #0
    if (obqp->ptr == NULL) {
 80021c8:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 80021ca:	f8df b0dc 	ldr.w	fp, [pc, #220]	@ 80022a8 <obqWriteTimeout+0xf8>
 80021ce:	46b1      	mov	r9, r6
 80021d0:	b3a0      	cbz	r0, 800223c <obqWriteTimeout+0x8c>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 80021d2:	6aea      	ldr	r2, [r5, #44]	@ 0x2c
    if (size > (n - w)) {
 80021d4:	1bbb      	subs	r3, r7, r6
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 80021d6:	1a12      	subs	r2, r2, r0
    if (size > (n - w)) {
 80021d8:	429a      	cmp	r2, r3
 80021da:	bf28      	it	cs
 80021dc:	461a      	movcs	r2, r3
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 80021de:	2a40      	cmp	r2, #64	@ 0x40
    if (size > (n - w)) {
 80021e0:	4692      	mov	sl, r2
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 80021e2:	d932      	bls.n	800224a <obqWriteTimeout+0x9a>
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
 80021e4:	4621      	mov	r1, r4
 80021e6:	f104 0e40 	add.w	lr, r4, #64	@ 0x40
 80021ea:	f8d1 c000 	ldr.w	ip, [r1]
 80021ee:	3110      	adds	r1, #16
 80021f0:	f851 4c0c 	ldr.w	r4, [r1, #-12]
 80021f4:	3010      	adds	r0, #16
 80021f6:	f851 2c08 	ldr.w	r2, [r1, #-8]
 80021fa:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80021fe:	4571      	cmp	r1, lr
 8002200:	f840 cc10 	str.w	ip, [r0, #-16]
 8002204:	f840 4c0c 	str.w	r4, [r0, #-12]
 8002208:	f840 2c08 	str.w	r2, [r0, #-8]
 800220c:	f840 3c04 	str.w	r3, [r0, #-4]
 8002210:	d1eb      	bne.n	80021ea <obqWriteTimeout+0x3a>
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8002212:	6aab      	ldr	r3, [r5, #40]	@ 0x28
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 8002214:	460c      	mov	r4, r1
    if (obqp->ptr >= obqp->top) {
 8002216:	6aea      	ldr	r2, [r5, #44]	@ 0x2c
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
 8002218:	3640      	adds	r6, #64	@ 0x40
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 800221a:	3340      	adds	r3, #64	@ 0x40
    if (obqp->ptr >= obqp->top) {
 800221c:	429a      	cmp	r2, r3
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 800221e:	62ab      	str	r3, [r5, #40]	@ 0x28
    if (obqp->ptr >= obqp->top) {
 8002220:	d91e      	bls.n	8002260 <obqWriteTimeout+0xb0>
 8002222:	f8db 3000 	ldr.w	r3, [fp]
 8002226:	455b      	cmp	r3, fp
 8002228:	d123      	bne.n	8002272 <obqWriteTimeout+0xc2>
 800222a:	f389 8811 	msr	BASEPRI, r9
    if (w >= n) {
 800222e:	42be      	cmp	r6, r7
 8002230:	d22f      	bcs.n	8002292 <obqWriteTimeout+0xe2>
 8002232:	f388 8811 	msr	BASEPRI, r8
    if (obqp->ptr == NULL) {
 8002236:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 8002238:	2800      	cmp	r0, #0
 800223a:	d1ca      	bne.n	80021d2 <obqWriteTimeout+0x22>
      msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800223c:	9901      	ldr	r1, [sp, #4]
 800223e:	4628      	mov	r0, r5
 8002240:	f7ff ff7e 	bl	8002140 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 8002244:	b9f0      	cbnz	r0, 8002284 <obqWriteTimeout+0xd4>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8002246:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 8002248:	e7c3      	b.n	80021d2 <obqWriteTimeout+0x22>
      memcpy(obqp->ptr, bp, size);
 800224a:	4621      	mov	r1, r4
      w         += size;
 800224c:	4456      	add	r6, sl
      memcpy(obqp->ptr, bp, size);
 800224e:	f7fe fa57 	bl	8000700 <memcpy>
      obqp->ptr += size;
 8002252:	6aab      	ldr	r3, [r5, #40]	@ 0x28
    if (obqp->ptr >= obqp->top) {
 8002254:	6aea      	ldr	r2, [r5, #44]	@ 0x2c
      bp        += size;
 8002256:	4454      	add	r4, sl
      obqp->ptr += size;
 8002258:	4453      	add	r3, sl
    if (obqp->ptr >= obqp->top) {
 800225a:	429a      	cmp	r2, r3
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 800225c:	62ab      	str	r3, [r5, #40]	@ 0x28
    if (obqp->ptr >= obqp->top) {
 800225e:	d8e0      	bhi.n	8002222 <obqWriteTimeout+0x72>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8002260:	69e9      	ldr	r1, [r5, #28]
 8002262:	4628      	mov	r0, r5
 8002264:	3904      	subs	r1, #4
 8002266:	f7fe fdf3 	bl	8000e50 <obqPostFullBufferS>
 800226a:	f8db 3000 	ldr.w	r3, [fp]
 800226e:	455b      	cmp	r3, fp
 8002270:	d0db      	beq.n	800222a <obqWriteTimeout+0x7a>
 8002272:	f8db 200c 	ldr.w	r2, [fp, #12]
 8002276:	689b      	ldr	r3, [r3, #8]
 8002278:	6892      	ldr	r2, [r2, #8]
 800227a:	429a      	cmp	r2, r3
 800227c:	d2d5      	bcs.n	800222a <obqWriteTimeout+0x7a>
 800227e:	480b      	ldr	r0, [pc, #44]	@ (80022ac <obqWriteTimeout+0xfc>)
 8002280:	f7fe fd66 	bl	8000d50 <chSysHalt>
 8002284:	f8db 3000 	ldr.w	r3, [fp]
 8002288:	455b      	cmp	r3, fp
 800228a:	d106      	bne.n	800229a <obqWriteTimeout+0xea>
 800228c:	2300      	movs	r3, #0
 800228e:	f383 8811 	msr	BASEPRI, r3
}
 8002292:	4630      	mov	r0, r6
 8002294:	b003      	add	sp, #12
 8002296:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800229a:	f8db 200c 	ldr.w	r2, [fp, #12]
 800229e:	689b      	ldr	r3, [r3, #8]
 80022a0:	6892      	ldr	r2, [r2, #8]
 80022a2:	429a      	cmp	r2, r3
 80022a4:	d2f2      	bcs.n	800228c <obqWriteTimeout+0xdc>
 80022a6:	e7ea      	b.n	800227e <obqWriteTimeout+0xce>
 80022a8:	24006e20 	.word	0x24006e20
 80022ac:	0800751c 	.word	0x0800751c

080022b0 <_write>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 80022b0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80022b4:	3044      	adds	r0, #68	@ 0x44
 80022b6:	f7ff bf7b 	b.w	80021b0 <obqWriteTimeout>
 80022ba:	bf00      	nop
 80022bc:	0000      	movs	r0, r0
	...

080022c0 <_writet>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 80022c0:	3044      	adds	r0, #68	@ 0x44
 80022c2:	f7ff bf75 	b.w	80021b0 <obqWriteTimeout>
 80022c6:	bf00      	nop
	...

080022d0 <_put>:
static msg_t _put(void *ip, uint8_t b) {
 80022d0:	b570      	push	{r4, r5, r6, lr}
 80022d2:	2330      	movs	r3, #48	@ 0x30
 80022d4:	4604      	mov	r4, r0
 80022d6:	460d      	mov	r5, r1
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 80022d8:	f100 0644 	add.w	r6, r0, #68	@ 0x44
 80022dc:	f383 8811 	msr	BASEPRI, r3
  if (obqp->ptr == NULL) {
 80022e0:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 80022e2:	b1a3      	cbz	r3, 800230e <_put+0x3e>
  *obqp->ptr = b;
 80022e4:	701d      	strb	r5, [r3, #0]
  if (obqp->ptr >= obqp->top) {
 80022e6:	e9d4 321b 	ldrd	r3, r2, [r4, #108]	@ 0x6c
  obqp->ptr++;
 80022ea:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 80022ec:	4293      	cmp	r3, r2
  obqp->ptr++;
 80022ee:	66e3      	str	r3, [r4, #108]	@ 0x6c
  if (obqp->ptr >= obqp->top) {
 80022f0:	d207      	bcs.n	8002302 <_put+0x32>
 80022f2:	4b16      	ldr	r3, [pc, #88]	@ (800234c <_put+0x7c>)
 80022f4:	681a      	ldr	r2, [r3, #0]
 80022f6:	429a      	cmp	r2, r3
 80022f8:	d111      	bne.n	800231e <_put+0x4e>
 80022fa:	2000      	movs	r0, #0
 80022fc:	f380 8811 	msr	BASEPRI, r0
}
 8002300:	bd70      	pop	{r4, r5, r6, pc}
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8002302:	6e21      	ldr	r1, [r4, #96]	@ 0x60
 8002304:	4630      	mov	r0, r6
 8002306:	3904      	subs	r1, #4
 8002308:	f7fe fda2 	bl	8000e50 <obqPostFullBufferS>
 800230c:	e7f1      	b.n	80022f2 <_put+0x22>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800230e:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8002312:	4630      	mov	r0, r6
 8002314:	f7ff ff14 	bl	8002140 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8002318:	b948      	cbnz	r0, 800232e <_put+0x5e>
  *obqp->ptr = b;
 800231a:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800231c:	e7e2      	b.n	80022e4 <_put+0x14>
 800231e:	68d9      	ldr	r1, [r3, #12]
 8002320:	6893      	ldr	r3, [r2, #8]
 8002322:	688a      	ldr	r2, [r1, #8]
 8002324:	429a      	cmp	r2, r3
 8002326:	d2e8      	bcs.n	80022fa <_put+0x2a>
 8002328:	4809      	ldr	r0, [pc, #36]	@ (8002350 <_put+0x80>)
 800232a:	f7fe fd11 	bl	8000d50 <chSysHalt>
 800232e:	4b07      	ldr	r3, [pc, #28]	@ (800234c <_put+0x7c>)
 8002330:	681a      	ldr	r2, [r3, #0]
 8002332:	429a      	cmp	r2, r3
 8002334:	d103      	bne.n	800233e <_put+0x6e>
 8002336:	2300      	movs	r3, #0
 8002338:	f383 8811 	msr	BASEPRI, r3
 800233c:	bd70      	pop	{r4, r5, r6, pc}
 800233e:	68d9      	ldr	r1, [r3, #12]
 8002340:	6893      	ldr	r3, [r2, #8]
 8002342:	688a      	ldr	r2, [r1, #8]
 8002344:	429a      	cmp	r2, r3
 8002346:	d2f6      	bcs.n	8002336 <_put+0x66>
 8002348:	e7ee      	b.n	8002328 <_put+0x58>
 800234a:	bf00      	nop
 800234c:	24006e20 	.word	0x24006e20
 8002350:	0800751c 	.word	0x0800751c
	...

08002360 <_putt>:
static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 8002360:	b570      	push	{r4, r5, r6, lr}
 8002362:	2330      	movs	r3, #48	@ 0x30
 8002364:	4604      	mov	r4, r0
 8002366:	460d      	mov	r5, r1
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8002368:	f100 0644 	add.w	r6, r0, #68	@ 0x44
 800236c:	f383 8811 	msr	BASEPRI, r3
  if (obqp->ptr == NULL) {
 8002370:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 8002372:	b1a3      	cbz	r3, 800239e <_putt+0x3e>
  *obqp->ptr = b;
 8002374:	701d      	strb	r5, [r3, #0]
  if (obqp->ptr >= obqp->top) {
 8002376:	e9d4 321b 	ldrd	r3, r2, [r4, #108]	@ 0x6c
  obqp->ptr++;
 800237a:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 800237c:	4293      	cmp	r3, r2
  obqp->ptr++;
 800237e:	66e3      	str	r3, [r4, #108]	@ 0x6c
  if (obqp->ptr >= obqp->top) {
 8002380:	d207      	bcs.n	8002392 <_putt+0x32>
 8002382:	4b15      	ldr	r3, [pc, #84]	@ (80023d8 <_putt+0x78>)
 8002384:	681a      	ldr	r2, [r3, #0]
 8002386:	429a      	cmp	r2, r3
 8002388:	d110      	bne.n	80023ac <_putt+0x4c>
 800238a:	2000      	movs	r0, #0
 800238c:	f380 8811 	msr	BASEPRI, r0
}
 8002390:	bd70      	pop	{r4, r5, r6, pc}
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8002392:	6e21      	ldr	r1, [r4, #96]	@ 0x60
 8002394:	4630      	mov	r0, r6
 8002396:	3904      	subs	r1, #4
 8002398:	f7fe fd5a 	bl	8000e50 <obqPostFullBufferS>
 800239c:	e7f1      	b.n	8002382 <_putt+0x22>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800239e:	4611      	mov	r1, r2
 80023a0:	4630      	mov	r0, r6
 80023a2:	f7ff fecd 	bl	8002140 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 80023a6:	b948      	cbnz	r0, 80023bc <_putt+0x5c>
  *obqp->ptr = b;
 80023a8:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 80023aa:	e7e3      	b.n	8002374 <_putt+0x14>
 80023ac:	68d9      	ldr	r1, [r3, #12]
 80023ae:	6893      	ldr	r3, [r2, #8]
 80023b0:	688a      	ldr	r2, [r1, #8]
 80023b2:	429a      	cmp	r2, r3
 80023b4:	d2e9      	bcs.n	800238a <_putt+0x2a>
 80023b6:	4809      	ldr	r0, [pc, #36]	@ (80023dc <_putt+0x7c>)
 80023b8:	f7fe fcca 	bl	8000d50 <chSysHalt>
 80023bc:	4b06      	ldr	r3, [pc, #24]	@ (80023d8 <_putt+0x78>)
 80023be:	681a      	ldr	r2, [r3, #0]
 80023c0:	429a      	cmp	r2, r3
 80023c2:	d103      	bne.n	80023cc <_putt+0x6c>
 80023c4:	2300      	movs	r3, #0
 80023c6:	f383 8811 	msr	BASEPRI, r3
 80023ca:	bd70      	pop	{r4, r5, r6, pc}
 80023cc:	68d9      	ldr	r1, [r3, #12]
 80023ce:	6893      	ldr	r3, [r2, #8]
 80023d0:	688a      	ldr	r2, [r1, #8]
 80023d2:	429a      	cmp	r2, r3
 80023d4:	d2f6      	bcs.n	80023c4 <_putt+0x64>
 80023d6:	e7ee      	b.n	80023b6 <_putt+0x56>
 80023d8:	24006e20 	.word	0x24006e20
 80023dc:	0800751c 	.word	0x0800751c

080023e0 <ibqGetFullBufferTimeoutS>:
  while (ibqIsEmptyI(ibqp)) {
 80023e0:	68c3      	ldr	r3, [r0, #12]
                                 sysinterval_t timeout) {
 80023e2:	b570      	push	{r4, r5, r6, lr}
 80023e4:	4604      	mov	r4, r0
  while (ibqIsEmptyI(ibqp)) {
 80023e6:	b9bb      	cbnz	r3, 8002418 <ibqGetFullBufferTimeoutS+0x38>
    if (ibqp->suspended) {
 80023e8:	7a03      	ldrb	r3, [r0, #8]
 80023ea:	bb13      	cbnz	r3, 8002432 <ibqGetFullBufferTimeoutS+0x52>
 80023ec:	4e14      	ldr	r6, [pc, #80]	@ (8002440 <ibqGetFullBufferTimeoutS+0x60>)
 80023ee:	460d      	mov	r5, r1
 80023f0:	68f3      	ldr	r3, [r6, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 80023f2:	b919      	cbnz	r1, 80023fc <ibqGetFullBufferTimeoutS+0x1c>
 80023f4:	e01a      	b.n	800242c <ibqGetFullBufferTimeoutS+0x4c>
 80023f6:	7a23      	ldrb	r3, [r4, #8]
 80023f8:	b9db      	cbnz	r3, 8002432 <ibqGetFullBufferTimeoutS+0x52>
 80023fa:	68f3      	ldr	r3, [r6, #12]
  p->prev       = qp->prev;
 80023fc:	6862      	ldr	r2, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80023fe:	4629      	mov	r1, r5
  p->next       = qp;
 8002400:	601c      	str	r4, [r3, #0]
 8002402:	2004      	movs	r0, #4
  p->prev       = qp->prev;
 8002404:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8002406:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
 8002408:	6063      	str	r3, [r4, #4]
 800240a:	f7ff fe11 	bl	8002030 <chSchGoSleepTimeoutS>
    if (msg < MSG_OK) {
 800240e:	2800      	cmp	r0, #0
 8002410:	db0b      	blt.n	800242a <ibqGetFullBufferTimeoutS+0x4a>
  while (ibqIsEmptyI(ibqp)) {
 8002412:	68e3      	ldr	r3, [r4, #12]
 8002414:	2b00      	cmp	r3, #0
 8002416:	d0ee      	beq.n	80023f6 <ibqGetFullBufferTimeoutS+0x16>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 8002418:	68e3      	ldr	r3, [r4, #12]
 800241a:	b16b      	cbz	r3, 8002438 <ibqGetFullBufferTimeoutS+0x58>
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 800241c:	6963      	ldr	r3, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)(void *)ibqp->brdptr);
 800241e:	2000      	movs	r0, #0
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8002420:	1d1a      	adds	r2, r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)(void *)ibqp->brdptr);
 8002422:	681b      	ldr	r3, [r3, #0]
 8002424:	4413      	add	r3, r2
 8002426:	e9c4 230a 	strd	r2, r3, [r4, #40]	@ 0x28
}
 800242a:	bd70      	pop	{r4, r5, r6, pc}
       return msg;
 800242c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 8002430:	bd70      	pop	{r4, r5, r6, pc}
      return MSG_RESET;
 8002432:	f06f 0001 	mvn.w	r0, #1
}
 8002436:	bd70      	pop	{r4, r5, r6, pc}
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 8002438:	4802      	ldr	r0, [pc, #8]	@ (8002444 <ibqGetFullBufferTimeoutS+0x64>)
 800243a:	f7fe fc89 	bl	8000d50 <chSysHalt>
 800243e:	bf00      	nop
 8002440:	24006e20 	.word	0x24006e20
 8002444:	08007540 	.word	0x08007540
	...

08002450 <ibqReadTimeout>:
                      size_t n, sysinterval_t timeout) {
 8002450:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002454:	b083      	sub	sp, #12
 8002456:	4604      	mov	r4, r0
 8002458:	460e      	mov	r6, r1
 800245a:	4617      	mov	r7, r2
 800245c:	f04f 0830 	mov.w	r8, #48	@ 0x30
 8002460:	9301      	str	r3, [sp, #4]
 8002462:	f388 8811 	msr	BASEPRI, r8
  size_t r = 0;
 8002466:	2500      	movs	r5, #0
    if (ibqp->ptr == NULL) {
 8002468:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800246a:	f8df a0dc 	ldr.w	sl, [pc, #220]	@ 8002548 <ibqReadTimeout+0xf8>
 800246e:	46a9      	mov	r9, r5
 8002470:	b3a9      	cbz	r1, 80024de <ibqReadTimeout+0x8e>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8002472:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
    if (size > (n - r)) {
 8002474:	1b7b      	subs	r3, r7, r5
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8002476:	eba2 0b01 	sub.w	fp, r2, r1
    if (size > (n - r)) {
 800247a:	459b      	cmp	fp, r3
 800247c:	bf28      	it	cs
 800247e:	469b      	movcs	fp, r3
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8002480:	f1bb 0f40 	cmp.w	fp, #64	@ 0x40
 8002484:	d932      	bls.n	80024ec <ibqReadTimeout+0x9c>
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
 8002486:	4633      	mov	r3, r6
 8002488:	f101 0b40 	add.w	fp, r1, #64	@ 0x40
 800248c:	f8d1 e000 	ldr.w	lr, [r1]
 8002490:	3110      	adds	r1, #16
 8002492:	f851 cc0c 	ldr.w	ip, [r1, #-12]
 8002496:	3310      	adds	r3, #16
 8002498:	f851 0c08 	ldr.w	r0, [r1, #-8]
 800249c:	f851 2c04 	ldr.w	r2, [r1, #-4]
 80024a0:	4559      	cmp	r1, fp
 80024a2:	f843 ec10 	str.w	lr, [r3, #-16]
 80024a6:	f843 cc0c 	str.w	ip, [r3, #-12]
 80024aa:	f843 0c08 	str.w	r0, [r3, #-8]
 80024ae:	f843 2c04 	str.w	r2, [r3, #-4]
 80024b2:	d1eb      	bne.n	800248c <ibqReadTimeout+0x3c>
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 80024b4:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 80024b6:	3640      	adds	r6, #64	@ 0x40
    if (ibqp->ptr >= ibqp->top) {
 80024b8:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
 80024ba:	3540      	adds	r5, #64	@ 0x40
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 80024bc:	3340      	adds	r3, #64	@ 0x40
    if (ibqp->ptr >= ibqp->top) {
 80024be:	429a      	cmp	r2, r3
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 80024c0:	62a3      	str	r3, [r4, #40]	@ 0x28
    if (ibqp->ptr >= ibqp->top) {
 80024c2:	d91f      	bls.n	8002504 <ibqReadTimeout+0xb4>
 80024c4:	f8da 3000 	ldr.w	r3, [sl]
 80024c8:	4553      	cmp	r3, sl
 80024ca:	d122      	bne.n	8002512 <ibqReadTimeout+0xc2>
 80024cc:	f389 8811 	msr	BASEPRI, r9
    if (r >= n) {
 80024d0:	42bd      	cmp	r5, r7
 80024d2:	d22e      	bcs.n	8002532 <ibqReadTimeout+0xe2>
 80024d4:	f388 8811 	msr	BASEPRI, r8
    if (ibqp->ptr == NULL) {
 80024d8:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 80024da:	2900      	cmp	r1, #0
 80024dc:	d1c9      	bne.n	8002472 <ibqReadTimeout+0x22>
      msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80024de:	9901      	ldr	r1, [sp, #4]
 80024e0:	4620      	mov	r0, r4
 80024e2:	f7ff ff7d 	bl	80023e0 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 80024e6:	b9e8      	cbnz	r0, 8002524 <ibqReadTimeout+0xd4>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 80024e8:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 80024ea:	e7c2      	b.n	8002472 <ibqReadTimeout+0x22>
      memcpy(bp, ibqp->ptr, size);
 80024ec:	465a      	mov	r2, fp
 80024ee:	4630      	mov	r0, r6
 80024f0:	f7fe f906 	bl	8000700 <memcpy>
      ibqp->ptr += size;
 80024f4:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
    if (ibqp->ptr >= ibqp->top) {
 80024f6:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
      bp        += size;
 80024f8:	445e      	add	r6, fp
      ibqp->ptr += size;
 80024fa:	445b      	add	r3, fp
      r         += size;
 80024fc:	445d      	add	r5, fp
    if (ibqp->ptr >= ibqp->top) {
 80024fe:	429a      	cmp	r2, r3
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8002500:	62a3      	str	r3, [r4, #40]	@ 0x28
    if (ibqp->ptr >= ibqp->top) {
 8002502:	d8df      	bhi.n	80024c4 <ibqReadTimeout+0x74>
      ibqReleaseEmptyBufferS(ibqp);
 8002504:	4620      	mov	r0, r4
 8002506:	f7fe fc83 	bl	8000e10 <ibqReleaseEmptyBufferS>
 800250a:	f8da 3000 	ldr.w	r3, [sl]
 800250e:	4553      	cmp	r3, sl
 8002510:	d0dc      	beq.n	80024cc <ibqReadTimeout+0x7c>
 8002512:	f8da 200c 	ldr.w	r2, [sl, #12]
 8002516:	689b      	ldr	r3, [r3, #8]
 8002518:	6892      	ldr	r2, [r2, #8]
 800251a:	429a      	cmp	r2, r3
 800251c:	d2d6      	bcs.n	80024cc <ibqReadTimeout+0x7c>
 800251e:	480b      	ldr	r0, [pc, #44]	@ (800254c <ibqReadTimeout+0xfc>)
 8002520:	f7fe fc16 	bl	8000d50 <chSysHalt>
 8002524:	f8da 3000 	ldr.w	r3, [sl]
 8002528:	4553      	cmp	r3, sl
 800252a:	d106      	bne.n	800253a <ibqReadTimeout+0xea>
 800252c:	2300      	movs	r3, #0
 800252e:	f383 8811 	msr	BASEPRI, r3
}
 8002532:	4628      	mov	r0, r5
 8002534:	b003      	add	sp, #12
 8002536:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800253a:	f8da 200c 	ldr.w	r2, [sl, #12]
 800253e:	689b      	ldr	r3, [r3, #8]
 8002540:	6892      	ldr	r2, [r2, #8]
 8002542:	429a      	cmp	r2, r3
 8002544:	d2f2      	bcs.n	800252c <ibqReadTimeout+0xdc>
 8002546:	e7ea      	b.n	800251e <ibqReadTimeout+0xce>
 8002548:	24006e20 	.word	0x24006e20
 800254c:	0800751c 	.word	0x0800751c

08002550 <_read>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 8002550:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8002554:	300c      	adds	r0, #12
 8002556:	f7ff bf7b 	b.w	8002450 <ibqReadTimeout>
 800255a:	bf00      	nop
 800255c:	0000      	movs	r0, r0
	...

08002560 <_readt>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 8002560:	300c      	adds	r0, #12
 8002562:	f7ff bf75 	b.w	8002450 <ibqReadTimeout>
 8002566:	bf00      	nop
	...

08002570 <_gett>:
static msg_t _gett(void *ip, sysinterval_t timeout) {
 8002570:	b570      	push	{r4, r5, r6, lr}
 8002572:	2330      	movs	r3, #48	@ 0x30
 8002574:	4604      	mov	r4, r0
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 8002576:	f100 060c 	add.w	r6, r0, #12
 800257a:	f383 8811 	msr	BASEPRI, r3
  if (ibqp->ptr == NULL) {
 800257e:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 8002580:	b1eb      	cbz	r3, 80025be <_gett+0x4e>
  msg = (msg_t)*ibqp->ptr;
 8002582:	f813 5b01 	ldrb.w	r5, [r3], #1
  if (ibqp->ptr >= ibqp->top) {
 8002586:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
  ibqp->ptr++;
 8002588:	6363      	str	r3, [r4, #52]	@ 0x34
  if (ibqp->ptr >= ibqp->top) {
 800258a:	4293      	cmp	r3, r2
 800258c:	d208      	bcs.n	80025a0 <_gett+0x30>
 800258e:	4b10      	ldr	r3, [pc, #64]	@ (80025d0 <_gett+0x60>)
 8002590:	681a      	ldr	r2, [r3, #0]
 8002592:	429a      	cmp	r2, r3
 8002594:	d10b      	bne.n	80025ae <_gett+0x3e>
 8002596:	2300      	movs	r3, #0
 8002598:	f383 8811 	msr	BASEPRI, r3
}
 800259c:	4628      	mov	r0, r5
 800259e:	bd70      	pop	{r4, r5, r6, pc}
    ibqReleaseEmptyBufferS(ibqp);
 80025a0:	4630      	mov	r0, r6
 80025a2:	f7fe fc35 	bl	8000e10 <ibqReleaseEmptyBufferS>
 80025a6:	4b0a      	ldr	r3, [pc, #40]	@ (80025d0 <_gett+0x60>)
 80025a8:	681a      	ldr	r2, [r3, #0]
 80025aa:	429a      	cmp	r2, r3
 80025ac:	d0f3      	beq.n	8002596 <_gett+0x26>
 80025ae:	68d9      	ldr	r1, [r3, #12]
 80025b0:	6893      	ldr	r3, [r2, #8]
 80025b2:	688a      	ldr	r2, [r1, #8]
 80025b4:	429a      	cmp	r2, r3
 80025b6:	d2ee      	bcs.n	8002596 <_gett+0x26>
 80025b8:	4806      	ldr	r0, [pc, #24]	@ (80025d4 <_gett+0x64>)
 80025ba:	f7fe fbc9 	bl	8000d50 <chSysHalt>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80025be:	4630      	mov	r0, r6
 80025c0:	f7ff ff0e 	bl	80023e0 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 80025c4:	4605      	mov	r5, r0
 80025c6:	2800      	cmp	r0, #0
 80025c8:	d1e1      	bne.n	800258e <_gett+0x1e>
  msg = (msg_t)*ibqp->ptr;
 80025ca:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 80025cc:	e7d9      	b.n	8002582 <_gett+0x12>
 80025ce:	bf00      	nop
 80025d0:	24006e20 	.word	0x24006e20
 80025d4:	0800751c 	.word	0x0800751c
	...

080025e0 <_get>:
static msg_t _get(void *ip) {
 80025e0:	b570      	push	{r4, r5, r6, lr}
 80025e2:	2330      	movs	r3, #48	@ 0x30
 80025e4:	4604      	mov	r4, r0
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 80025e6:	f100 060c 	add.w	r6, r0, #12
 80025ea:	f383 8811 	msr	BASEPRI, r3
  if (ibqp->ptr == NULL) {
 80025ee:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 80025f0:	b1eb      	cbz	r3, 800262e <_get+0x4e>
  msg = (msg_t)*ibqp->ptr;
 80025f2:	f813 5b01 	ldrb.w	r5, [r3], #1
  if (ibqp->ptr >= ibqp->top) {
 80025f6:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
  ibqp->ptr++;
 80025f8:	6363      	str	r3, [r4, #52]	@ 0x34
  if (ibqp->ptr >= ibqp->top) {
 80025fa:	4293      	cmp	r3, r2
 80025fc:	d208      	bcs.n	8002610 <_get+0x30>
 80025fe:	4b11      	ldr	r3, [pc, #68]	@ (8002644 <_get+0x64>)
 8002600:	681a      	ldr	r2, [r3, #0]
 8002602:	429a      	cmp	r2, r3
 8002604:	d10b      	bne.n	800261e <_get+0x3e>
 8002606:	2300      	movs	r3, #0
 8002608:	f383 8811 	msr	BASEPRI, r3
}
 800260c:	4628      	mov	r0, r5
 800260e:	bd70      	pop	{r4, r5, r6, pc}
    ibqReleaseEmptyBufferS(ibqp);
 8002610:	4630      	mov	r0, r6
 8002612:	f7fe fbfd 	bl	8000e10 <ibqReleaseEmptyBufferS>
 8002616:	4b0b      	ldr	r3, [pc, #44]	@ (8002644 <_get+0x64>)
 8002618:	681a      	ldr	r2, [r3, #0]
 800261a:	429a      	cmp	r2, r3
 800261c:	d0f3      	beq.n	8002606 <_get+0x26>
 800261e:	68d9      	ldr	r1, [r3, #12]
 8002620:	6893      	ldr	r3, [r2, #8]
 8002622:	688a      	ldr	r2, [r1, #8]
 8002624:	429a      	cmp	r2, r3
 8002626:	d2ee      	bcs.n	8002606 <_get+0x26>
 8002628:	4807      	ldr	r0, [pc, #28]	@ (8002648 <_get+0x68>)
 800262a:	f7fe fb91 	bl	8000d50 <chSysHalt>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 800262e:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8002632:	4630      	mov	r0, r6
 8002634:	f7ff fed4 	bl	80023e0 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 8002638:	4605      	mov	r5, r0
 800263a:	2800      	cmp	r0, #0
 800263c:	d1df      	bne.n	80025fe <_get+0x1e>
  msg = (msg_t)*ibqp->ptr;
 800263e:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8002640:	e7d7      	b.n	80025f2 <_get+0x12>
 8002642:	bf00      	nop
 8002644:	24006e20 	.word	0x24006e20
 8002648:	0800751c 	.word	0x0800751c
 800264c:	00000000 	.word	0x00000000

08002650 <Thread1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8002650:	4c15      	ldr	r4, [pc, #84]	@ (80026a8 <Thread1+0x58>)
  palSetLine(LINE_LED);
 8002652:	f04f 0880 	mov.w	r8, #128	@ 0x80
 8002656:	4a15      	ldr	r2, [pc, #84]	@ (80026ac <Thread1+0x5c>)
 8002658:	2630      	movs	r6, #48	@ 0x30
 800265a:	68e3      	ldr	r3, [r4, #12]
 800265c:	4d14      	ldr	r5, [pc, #80]	@ (80026b0 <Thread1+0x60>)
static THD_FUNCTION(Thread1, arg) {
 800265e:	b580      	push	{r7, lr}
 8002660:	61da      	str	r2, [r3, #28]
  palSetLine(LINE_LED);
 8002662:	4f14      	ldr	r7, [pc, #80]	@ (80026b4 <Thread1+0x64>)
 8002664:	f8a5 8018 	strh.w	r8, [r5, #24]
 8002668:	e010      	b.n	800268c <Thread1+0x3c>
      palToggleLine(LINE_LED);
 800266a:	696b      	ldr	r3, [r5, #20]
 800266c:	f083 0380 	eor.w	r3, r3, #128	@ 0x80
 8002670:	616b      	str	r3, [r5, #20]
 8002672:	f386 8811 	msr	BASEPRI, r6
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8002676:	f44f 61fa 	mov.w	r1, #2000	@ 0x7d0
 800267a:	2008      	movs	r0, #8
 800267c:	f7ff fcd8 	bl	8002030 <chSchGoSleepTimeoutS>
 8002680:	6823      	ldr	r3, [r4, #0]
 8002682:	42a3      	cmp	r3, r4
 8002684:	d108      	bne.n	8002698 <Thread1+0x48>
 8002686:	2300      	movs	r3, #0
 8002688:	f383 8811 	msr	BASEPRI, r3
    if (blink)
 800268c:	783b      	ldrb	r3, [r7, #0]
 800268e:	2b00      	cmp	r3, #0
 8002690:	d1eb      	bne.n	800266a <Thread1+0x1a>
      palSetLine(LINE_LED);
 8002692:	f8a5 8018 	strh.w	r8, [r5, #24]
 8002696:	e7ec      	b.n	8002672 <Thread1+0x22>
 8002698:	68e2      	ldr	r2, [r4, #12]
 800269a:	689b      	ldr	r3, [r3, #8]
 800269c:	6892      	ldr	r2, [r2, #8]
 800269e:	429a      	cmp	r2, r3
 80026a0:	d2f1      	bcs.n	8002686 <Thread1+0x36>
 80026a2:	4805      	ldr	r0, [pc, #20]	@ (80026b8 <Thread1+0x68>)
 80026a4:	f7fe fb54 	bl	8000d50 <chSysHalt>
 80026a8:	24006e20 	.word	0x24006e20
 80026ac:	080068cc 	.word	0x080068cc
 80026b0:	58021800 	.word	0x58021800
 80026b4:	24000000 	.word	0x24000000
 80026b8:	08007224 	.word	0x08007224
 80026bc:	00000000 	.word	0x00000000

080026c0 <chThdExitS>:
void chThdExitS(msg_t msg) {
 80026c0:	b508      	push	{r3, lr}
  return __sch_get_currthread();
 80026c2:	4b11      	ldr	r3, [pc, #68]	@ (8002708 <chThdExitS+0x48>)
 80026c4:	68dc      	ldr	r4, [r3, #12]
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80026c6:	f104 052c 	add.w	r5, r4, #44	@ 0x2c
  return (bool)(lp->next != lp);
 80026ca:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  currtp->u.exitcode = msg;
 80026cc:	62a0      	str	r0, [r4, #40]	@ 0x28
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80026ce:	42ab      	cmp	r3, r5
 80026d0:	d108      	bne.n	80026e4 <chThdExitS+0x24>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 80026d2:	f894 3026 	ldrb.w	r3, [r4, #38]	@ 0x26
 80026d6:	b173      	cbz	r3, 80026f6 <chThdExitS+0x36>
  chSchGoSleepS(CH_STATE_FINAL);
 80026d8:	200f      	movs	r0, #15
 80026da:	f7ff fc69 	bl	8001fb0 <chSchGoSleepS>
  chDbgAssert(false, "zombies apocalypse");
 80026de:	480b      	ldr	r0, [pc, #44]	@ (800270c <chThdExitS+0x4c>)
 80026e0:	f7fe fb36 	bl	8000d50 <chSysHalt>
  lp->next = p->next;
 80026e4:	681a      	ldr	r2, [r3, #0]
  return __sch_ready_behind(tp);
 80026e6:	4618      	mov	r0, r3
 80026e8:	62e2      	str	r2, [r4, #44]	@ 0x2c
 80026ea:	f7fe ff11 	bl	8001510 <__sch_ready_behind.isra.0>
  return (bool)(lp->next != lp);
 80026ee:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80026f0:	42ab      	cmp	r3, r5
 80026f2:	d0ee      	beq.n	80026d2 <chThdExitS+0x12>
 80026f4:	e7f6      	b.n	80026e4 <chThdExitS+0x24>
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 80026f6:	f894 3025 	ldrb.w	r3, [r4, #37]	@ 0x25
 80026fa:	079b      	lsls	r3, r3, #30
 80026fc:	d1ec      	bne.n	80026d8 <chThdExitS+0x18>
  p->prev->next = p->next;
 80026fe:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8002702:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8002704:	605a      	str	r2, [r3, #4]
  return p;
 8002706:	e7e7      	b.n	80026d8 <chThdExitS+0x18>
 8002708:	24006e20 	.word	0x24006e20
 800270c:	08007230 	.word	0x08007230

08002710 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8002710:	b570      	push	{r4, r5, r6, lr}
 8002712:	4b34      	ldr	r3, [pc, #208]	@ (80027e4 <chMtxLockS+0xd4>)
 8002714:	4604      	mov	r4, r0

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8002716:	6880      	ldr	r0, [r0, #8]
 8002718:	68dd      	ldr	r5, [r3, #12]
 800271a:	2800      	cmp	r0, #0
 800271c:	d041      	beq.n	80027a2 <chMtxLockS+0x92>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 800271e:	68aa      	ldr	r2, [r5, #8]
 8002720:	6883      	ldr	r3, [r0, #8]
 8002722:	429a      	cmp	r2, r3
 8002724:	d910      	bls.n	8002748 <chMtxLockS+0x38>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8002726:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 800272a:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 800272c:	2b06      	cmp	r3, #6
 800272e:	d03d      	beq.n	80027ac <chMtxLockS+0x9c>
 8002730:	2b07      	cmp	r3, #7
 8002732:	d022      	beq.n	800277a <chMtxLockS+0x6a>
 8002734:	b943      	cbnz	r3, 8002748 <chMtxLockS+0x38>
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8002736:	2101      	movs	r1, #1
  p->prev->next = p->next;
 8002738:	e9d0 3200 	ldrd	r3, r2, [r0]
 800273c:	f880 1024 	strb.w	r1, [r0, #36]	@ 0x24
 8002740:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8002742:	605a      	str	r2, [r3, #4]
 8002744:	f7fe fee4 	bl	8001510 <__sch_ready_behind.isra.0>
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
 8002748:	4623      	mov	r3, r4
 800274a:	e003      	b.n	8002754 <chMtxLockS+0x44>
  do {
    cp = cp->next;
  } while ((cp != qp) &&
 800274c:	6899      	ldr	r1, [r3, #8]
 800274e:	68aa      	ldr	r2, [r5, #8]
 8002750:	4291      	cmp	r1, r2
 8002752:	d302      	bcc.n	800275a <chMtxLockS+0x4a>
    cp = cp->next;
 8002754:	681b      	ldr	r3, [r3, #0]
  } while ((cp != qp) &&
 8002756:	429c      	cmp	r4, r3
 8002758:	d1f8      	bne.n	800274c <chMtxLockS+0x3c>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
  tp->next       = cp;
  tp->prev       = cp->prev;
 800275a:	685a      	ldr	r2, [r3, #4]
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
      currtp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800275c:	2006      	movs	r0, #6
  tp->next       = cp;
 800275e:	602b      	str	r3, [r5, #0]
  tp->prev       = cp->prev;
 8002760:	606a      	str	r2, [r5, #4]
  tp->prev->next = tp;
 8002762:	6015      	str	r5, [r2, #0]
  cp->prev       = tp;
 8002764:	605d      	str	r5, [r3, #4]
      currtp->u.wtmtxp = mp;
 8002766:	62ac      	str	r4, [r5, #40]	@ 0x28
      chSchGoSleepS(CH_STATE_WTMTX);
 8002768:	f7ff fc22 	bl	8001fb0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == currtp, "not owner");
 800276c:	68a3      	ldr	r3, [r4, #8]
 800276e:	42ab      	cmp	r3, r5
 8002770:	d135      	bne.n	80027de <chMtxLockS+0xce>
      chDbgAssert(currtp->mtxlist == mp, "not owned");
 8002772:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
 8002774:	42a3      	cmp	r3, r4
 8002776:	d132      	bne.n	80027de <chMtxLockS+0xce>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 8002778:	bd70      	pop	{r4, r5, r6, pc}
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 800277a:	6a86      	ldr	r6, [r0, #40]	@ 0x28
  p->prev->next = p->next;
 800277c:	e9d0 3200 	ldrd	r3, r2, [r0]
 8002780:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8002782:	605a      	str	r2, [r3, #4]
  ch_queue_t *cp = qp;
 8002784:	4633      	mov	r3, r6
 8002786:	e003      	b.n	8002790 <chMtxLockS+0x80>
  } while ((cp != qp) &&
 8002788:	6899      	ldr	r1, [r3, #8]
 800278a:	6882      	ldr	r2, [r0, #8]
 800278c:	4291      	cmp	r1, r2
 800278e:	d302      	bcc.n	8002796 <chMtxLockS+0x86>
    cp = cp->next;
 8002790:	681b      	ldr	r3, [r3, #0]
  } while ((cp != qp) &&
 8002792:	429e      	cmp	r6, r3
 8002794:	d1f8      	bne.n	8002788 <chMtxLockS+0x78>
  tp->prev       = cp->prev;
 8002796:	685a      	ldr	r2, [r3, #4]
 8002798:	e9c0 3200 	strd	r3, r2, [r0]
  tp->prev->next = tp;
 800279c:	6010      	str	r0, [r2, #0]
  cp->prev       = tp;
 800279e:	6058      	str	r0, [r3, #4]
}
 80027a0:	e7d2      	b.n	8002748 <chMtxLockS+0x38>
    mp->next = currtp->mtxlist;
 80027a2:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
 80027a4:	e9c4 5302 	strd	r5, r3, [r4, #8]
    currtp->mtxlist = mp;
 80027a8:	63ec      	str	r4, [r5, #60]	@ 0x3c
}
 80027aa:	bd70      	pop	{r4, r5, r6, pc}
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 80027ac:	6a86      	ldr	r6, [r0, #40]	@ 0x28
  p->prev->next = p->next;
 80027ae:	e9d0 3200 	ldrd	r3, r2, [r0]
 80027b2:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 80027b4:	605a      	str	r2, [r3, #4]
  ch_queue_t *cp = qp;
 80027b6:	4633      	mov	r3, r6
 80027b8:	e003      	b.n	80027c2 <chMtxLockS+0xb2>
  } while ((cp != qp) &&
 80027ba:	6899      	ldr	r1, [r3, #8]
 80027bc:	6882      	ldr	r2, [r0, #8]
 80027be:	4291      	cmp	r1, r2
 80027c0:	d302      	bcc.n	80027c8 <chMtxLockS+0xb8>
    cp = cp->next;
 80027c2:	681b      	ldr	r3, [r3, #0]
  } while ((cp != qp) &&
 80027c4:	429e      	cmp	r6, r3
 80027c6:	d1f8      	bne.n	80027ba <chMtxLockS+0xaa>
  tp->prev       = cp->prev;
 80027c8:	685a      	ldr	r2, [r3, #4]
  tp->next       = cp;
 80027ca:	6003      	str	r3, [r0, #0]
  tp->prev       = cp->prev;
 80027cc:	6042      	str	r2, [r0, #4]
  tp->prev->next = tp;
 80027ce:	6010      	str	r0, [r2, #0]
  cp->prev       = tp;
 80027d0:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 80027d2:	68b0      	ldr	r0, [r6, #8]
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 80027d4:	68aa      	ldr	r2, [r5, #8]
 80027d6:	6883      	ldr	r3, [r0, #8]
 80027d8:	4293      	cmp	r3, r2
 80027da:	d3a4      	bcc.n	8002726 <chMtxLockS+0x16>
 80027dc:	e7b4      	b.n	8002748 <chMtxLockS+0x38>
      chDbgAssert(mp->owner == currtp, "not owner");
 80027de:	4802      	ldr	r0, [pc, #8]	@ (80027e8 <chMtxLockS+0xd8>)
 80027e0:	f7fe fab6 	bl	8000d50 <chSysHalt>
 80027e4:	24006e20 	.word	0x24006e20
 80027e8:	080071c8 	.word	0x080071c8
 80027ec:	00000000 	.word	0x00000000

080027f0 <chSchWakeupS.constprop.0>:
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80027f0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = __instance_get_currthread(oip);
 80027f2:	4e1e      	ldr	r6, [pc, #120]	@ (800286c <chSchWakeupS.constprop.0+0x7c>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80027f4:	4604      	mov	r4, r0
  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 80027f6:	6832      	ldr	r2, [r6, #0]
  thread_t *otp = __instance_get_currthread(oip);
 80027f8:	68f3      	ldr	r3, [r6, #12]
  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 80027fa:	42b2      	cmp	r2, r6
 80027fc:	6899      	ldr	r1, [r3, #8]
 80027fe:	d129      	bne.n	8002854 <chSchWakeupS.constprop.0+0x64>
  ntp->u.rdymsg = msg;
 8002800:	2200      	movs	r2, #0
 8002802:	62a2      	str	r2, [r4, #40]	@ 0x28
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 8002804:	68a2      	ldr	r2, [r4, #8]
 8002806:	4291      	cmp	r1, r2
 8002808:	d22a      	bcs.n	8002860 <chSchWakeupS.constprop.0+0x70>
    otp = __sch_ready_ahead(otp);
 800280a:	4618      	mov	r0, r3
 800280c:	f7fe fcf8 	bl	8001200 <__sch_ready_ahead>
    ntp->state = CH_STATE_CURRENT;
 8002810:	2301      	movs	r3, #1
    otp = __sch_ready_ahead(otp);
 8002812:	4605      	mov	r5, r0
    __instance_set_currthread(oip, ntp);
 8002814:	60f4      	str	r4, [r6, #12]
    ntp->state = CH_STATE_CURRENT;
 8002816:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800281a:	f8b6 3088 	ldrh.w	r3, [r6, #136]	@ 0x88
 800281e:	079b      	lsls	r3, r3, #30
 8002820:	d505      	bpl.n	800282e <chSchWakeupS.constprop.0+0x3e>
    chSysSwitch(ntp, otp);
 8002822:	4629      	mov	r1, r5
 8002824:	4620      	mov	r0, r4
}
 8002826:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSysSwitch(ntp, otp);
 800282a:	f7fd bdd9 	b.w	80003e0 <__port_switch>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800282e:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 8002832:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 8002834:	00db      	lsls	r3, r3, #3
 8002836:	f8d6 208c 	ldr.w	r2, [r6, #140]	@ 0x8c
 800283a:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800283e:	e9c2 4102 	strd	r4, r1, [r2, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002842:	7013      	strb	r3, [r2, #0]
    trace_next(oip);
 8002844:	f7fe fa64 	bl	8000d10 <trace_next.constprop.0>
 8002848:	4629      	mov	r1, r5
 800284a:	4620      	mov	r0, r4
}
 800284c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSysSwitch(ntp, otp);
 8002850:	f7fd bdc6 	b.w	80003e0 <__port_switch>
  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 8002854:	6892      	ldr	r2, [r2, #8]
 8002856:	428a      	cmp	r2, r1
 8002858:	d9d2      	bls.n	8002800 <chSchWakeupS.constprop.0+0x10>
 800285a:	4805      	ldr	r0, [pc, #20]	@ (8002870 <chSchWakeupS.constprop.0+0x80>)
 800285c:	f7fe fa78 	bl	8000d50 <chSysHalt>
    (void) __sch_ready_behind(ntp);
 8002860:	4620      	mov	r0, r4
}
 8002862:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    (void) __sch_ready_behind(ntp);
 8002866:	f7fe be53 	b.w	8001510 <__sch_ready_behind.isra.0>
 800286a:	bf00      	nop
 800286c:	24006e20 	.word	0x24006e20
 8002870:	08006e18 	.word	0x08006e18
	...

08002880 <chprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8002880:	b40e      	push	{r1, r2, r3}
 8002882:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002886:	b086      	sub	sp, #24
 8002888:	ab0f      	add	r3, sp, #60	@ 0x3c
 800288a:	f853 bb04 	ldr.w	fp, [r3], #4
    c = *fmt++;
 800288e:	465d      	mov	r5, fp
 8002890:	9300      	str	r3, [sp, #0]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8002892:	9302      	str	r3, [sp, #8]
    c = *fmt++;
 8002894:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 8002898:	2900      	cmp	r1, #0
 800289a:	f000 8222 	beq.w	8002ce2 <chprintf+0x462>
 800289e:	4604      	mov	r4, r0
  int n = 0;
 80028a0:	f04f 0900 	mov.w	r9, #0
 80028a4:	e00c      	b.n	80028c0 <chprintf+0x40>
      streamPut(chp, (uint8_t)c);
 80028a6:	6823      	ldr	r3, [r4, #0]
      n++;
 80028a8:	f109 0901 	add.w	r9, r9, #1
    c = *fmt++;
 80028ac:	46ab      	mov	fp, r5
      streamPut(chp, (uint8_t)c);
 80028ae:	4620      	mov	r0, r4
 80028b0:	68db      	ldr	r3, [r3, #12]
 80028b2:	4798      	blx	r3
    c = *fmt++;
 80028b4:	465d      	mov	r5, fp
 80028b6:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 80028ba:	2900      	cmp	r1, #0
 80028bc:	f000 80ea 	beq.w	8002a94 <chprintf+0x214>
    if (c != '%') {
 80028c0:	2925      	cmp	r1, #37	@ 0x25
 80028c2:	d1f0      	bne.n	80028a6 <chprintf+0x26>
    if (*fmt == '-') {
 80028c4:	f89b 3001 	ldrb.w	r3, [fp, #1]
 80028c8:	2b2d      	cmp	r3, #45	@ 0x2d
 80028ca:	f000 80cc 	beq.w	8002a66 <chprintf+0x1e6>
    left_align = false;
 80028ce:	2200      	movs	r2, #0
    if (*fmt == '+') {
 80028d0:	7828      	ldrb	r0, [r5, #0]
 80028d2:	282b      	cmp	r0, #43	@ 0x2b
 80028d4:	f000 80c3 	beq.w	8002a5e <chprintf+0x1de>
    do_sign = false;
 80028d8:	2700      	movs	r7, #0
    if (*fmt == '0') {
 80028da:	2830      	cmp	r0, #48	@ 0x30
 80028dc:	f000 80bb 	beq.w	8002a56 <chprintf+0x1d6>
    filler = ' ';
 80028e0:	2620      	movs	r6, #32
    if ( *fmt == '*') {
 80028e2:	282a      	cmp	r0, #42	@ 0x2a
 80028e4:	d151      	bne.n	800298a <chprintf+0x10a>
      c = *fmt++;
 80028e6:	7868      	ldrb	r0, [r5, #1]
 80028e8:	f105 0b02 	add.w	fp, r5, #2
      width = va_arg(ap, int);
 80028ec:	f8dd c000 	ldr.w	ip, [sp]
    if (c == '.') {
 80028f0:	282e      	cmp	r0, #46	@ 0x2e
      width = va_arg(ap, int);
 80028f2:	f85c 3b04 	ldr.w	r3, [ip], #4
    if (c == '.') {
 80028f6:	d060      	beq.n	80029ba <chprintf+0x13a>
    precision = 0;
 80028f8:	f04f 0e00 	mov.w	lr, #0
    if (c == 'l' || c == 'L') {
 80028fc:	f000 01df 	and.w	r1, r0, #223	@ 0xdf
 8002900:	294c      	cmp	r1, #76	@ 0x4c
 8002902:	d16a      	bne.n	80029da <chprintf+0x15a>
      c = *fmt++;
 8002904:	f89b 0000 	ldrb.w	r0, [fp]
      if (c == 0) {
 8002908:	2800      	cmp	r0, #0
 800290a:	f000 80c3 	beq.w	8002a94 <chprintf+0x214>
    switch (c) {
 800290e:	f1a0 0144 	sub.w	r1, r0, #68	@ 0x44
      c = *fmt++;
 8002912:	f10b 0b01 	add.w	fp, fp, #1
    switch (c) {
 8002916:	2934      	cmp	r1, #52	@ 0x34
 8002918:	f200 80c2 	bhi.w	8002aa0 <chprintf+0x220>
 800291c:	e8df f011 	tbh	[pc, r1, lsl #1]
 8002920:	00c001a1 	.word	0x00c001a1
 8002924:	00c000c0 	.word	0x00c000c0
 8002928:	01a100c0 	.word	0x01a100c0
 800292c:	00c000c0 	.word	0x00c000c0
 8002930:	00c000c0 	.word	0x00c000c0
 8002934:	01d200c0 	.word	0x01d200c0
 8002938:	00c001b0 	.word	0x00c001b0
 800293c:	00c000c0 	.word	0x00c000c0
 8002940:	01cd00c0 	.word	0x01cd00c0
 8002944:	00c000c0 	.word	0x00c000c0
 8002948:	00c001b0 	.word	0x00c001b0
 800294c:	00c000c0 	.word	0x00c000c0
 8002950:	00c000c0 	.word	0x00c000c0
 8002954:	00c000c0 	.word	0x00c000c0
 8002958:	00c000c0 	.word	0x00c000c0
 800295c:	015700c0 	.word	0x015700c0
 8002960:	00c001a1 	.word	0x00c001a1
 8002964:	00c000c0 	.word	0x00c000c0
 8002968:	01a100c0 	.word	0x01a100c0
 800296c:	00c000c0 	.word	0x00c000c0
 8002970:	00c000c0 	.word	0x00c000c0
 8002974:	01d200c0 	.word	0x01d200c0
 8002978:	00c001b0 	.word	0x00c001b0
 800297c:	013900c0 	.word	0x013900c0
 8002980:	01cd00c0 	.word	0x01cd00c0
 8002984:	00c000c0 	.word	0x00c000c0
 8002988:	01b0      	.short	0x01b0
        c = *fmt++;
 800298a:	3501      	adds	r5, #1
        if (c == 0) {
 800298c:	2800      	cmp	r0, #0
 800298e:	f000 8081 	beq.w	8002a94 <chprintf+0x214>
      width = 0;
 8002992:	2300      	movs	r3, #0
 8002994:	e005      	b.n	80029a2 <chprintf+0x122>
        c = *fmt++;
 8002996:	f815 0b01 	ldrb.w	r0, [r5], #1
          width = width * 10 + c;
 800299a:	eb01 034c 	add.w	r3, r1, ip, lsl #1
        if (c == 0) {
 800299e:	2800      	cmp	r0, #0
 80029a0:	d078      	beq.n	8002a94 <chprintf+0x214>
        if (c >= '0' && c <= '9') {
 80029a2:	f1a0 0130 	sub.w	r1, r0, #48	@ 0x30
 80029a6:	46ab      	mov	fp, r5
          width = width * 10 + c;
 80029a8:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
        if (c >= '0' && c <= '9') {
 80029ac:	b2c9      	uxtb	r1, r1
 80029ae:	2909      	cmp	r1, #9
 80029b0:	d9f1      	bls.n	8002996 <chprintf+0x116>
    if (c == '.') {
 80029b2:	282e      	cmp	r0, #46	@ 0x2e
 80029b4:	f8dd c000 	ldr.w	ip, [sp]
 80029b8:	d19e      	bne.n	80028f8 <chprintf+0x78>
      c = *fmt++;
 80029ba:	f89b 0000 	ldrb.w	r0, [fp]
      if (c == 0) {
 80029be:	2800      	cmp	r0, #0
 80029c0:	d068      	beq.n	8002a94 <chprintf+0x214>
      if (c == '*') {
 80029c2:	282a      	cmp	r0, #42	@ 0x2a
 80029c4:	d153      	bne.n	8002a6e <chprintf+0x1ee>
        c = *fmt++;
 80029c6:	f89b 0001 	ldrb.w	r0, [fp, #1]
 80029ca:	f10b 0b02 	add.w	fp, fp, #2
        precision = va_arg(ap, int);
 80029ce:	f85c eb04 	ldr.w	lr, [ip], #4
    if (c == 'l' || c == 'L') {
 80029d2:	f000 01df 	and.w	r1, r0, #223	@ 0xdf
 80029d6:	294c      	cmp	r1, #76	@ 0x4c
 80029d8:	d094      	beq.n	8002904 <chprintf+0x84>
      is_long = (c >= 'A') && (c <= 'Z');
 80029da:	f1a0 0541 	sub.w	r5, r0, #65	@ 0x41
    switch (c) {
 80029de:	f1a0 0144 	sub.w	r1, r0, #68	@ 0x44
      is_long = (c >= 'A') && (c <= 'Z');
 80029e2:	b2ed      	uxtb	r5, r5
    switch (c) {
 80029e4:	2934      	cmp	r1, #52	@ 0x34
 80029e6:	d85b      	bhi.n	8002aa0 <chprintf+0x220>
 80029e8:	e8df f011 	tbh	[pc, r1, lsl #1]
 80029ec:	005a0106 	.word	0x005a0106
 80029f0:	005a005a 	.word	0x005a005a
 80029f4:	0106005a 	.word	0x0106005a
 80029f8:	005a005a 	.word	0x005a005a
 80029fc:	005a005a 	.word	0x005a005a
 8002a00:	015d005a 	.word	0x015d005a
 8002a04:	005a0139 	.word	0x005a0139
 8002a08:	005a005a 	.word	0x005a005a
 8002a0c:	009c005a 	.word	0x009c005a
 8002a10:	005a005a 	.word	0x005a005a
 8002a14:	005a0139 	.word	0x005a0139
 8002a18:	005a005a 	.word	0x005a005a
 8002a1c:	005a005a 	.word	0x005a005a
 8002a20:	005a005a 	.word	0x005a005a
 8002a24:	005a005a 	.word	0x005a005a
 8002a28:	00f1005a 	.word	0x00f1005a
 8002a2c:	005a0106 	.word	0x005a0106
 8002a30:	005a005a 	.word	0x005a005a
 8002a34:	0106005a 	.word	0x0106005a
 8002a38:	005a005a 	.word	0x005a005a
 8002a3c:	005a005a 	.word	0x005a005a
 8002a40:	015d005a 	.word	0x015d005a
 8002a44:	005a0139 	.word	0x005a0139
 8002a48:	00d3005a 	.word	0x00d3005a
 8002a4c:	009c005a 	.word	0x009c005a
 8002a50:	005a005a 	.word	0x005a005a
 8002a54:	0139      	.short	0x0139
      fmt++;
 8002a56:	3501      	adds	r5, #1
      filler = '0';
 8002a58:	4606      	mov	r6, r0
    if ( *fmt == '*') {
 8002a5a:	7828      	ldrb	r0, [r5, #0]
 8002a5c:	e741      	b.n	80028e2 <chprintf+0x62>
    if (*fmt == '0') {
 8002a5e:	7868      	ldrb	r0, [r5, #1]
      do_sign = true;
 8002a60:	2701      	movs	r7, #1
      fmt++;
 8002a62:	3501      	adds	r5, #1
 8002a64:	e739      	b.n	80028da <chprintf+0x5a>
      fmt++;
 8002a66:	f10b 0502 	add.w	r5, fp, #2
      left_align = true;
 8002a6a:	2201      	movs	r2, #1
 8002a6c:	e730      	b.n	80028d0 <chprintf+0x50>
      c = *fmt++;
 8002a6e:	f10b 0501 	add.w	r5, fp, #1
    precision = 0;
 8002a72:	f04f 0e00 	mov.w	lr, #0
        while (c >= '0' && c <= '9') {
 8002a76:	f1a0 0130 	sub.w	r1, r0, #48	@ 0x30
 8002a7a:	46ab      	mov	fp, r5
          precision = precision * 10 + c;
 8002a7c:	eb0e 088e 	add.w	r8, lr, lr, lsl #2
        while (c >= '0' && c <= '9') {
 8002a80:	b2c9      	uxtb	r1, r1
 8002a82:	2909      	cmp	r1, #9
 8002a84:	f63f af3a 	bhi.w	80028fc <chprintf+0x7c>
          c = *fmt++;
 8002a88:	f815 0b01 	ldrb.w	r0, [r5], #1
          precision = precision * 10 + c;
 8002a8c:	eb01 0e48 	add.w	lr, r1, r8, lsl #1
          if (c == 0) {
 8002a90:	2800      	cmp	r0, #0
 8002a92:	d1f0      	bne.n	8002a76 <chprintf+0x1f6>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8002a94:	4648      	mov	r0, r9
 8002a96:	b006      	add	sp, #24
 8002a98:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002a9c:	b003      	add	sp, #12
 8002a9e:	4770      	bx	lr
    if ((width -= i) < 0) {
 8002aa0:	f103 38ff 	add.w	r8, r3, #4294967295	@ 0xffffffff
      break;
 8002aa4:	f8cd c000 	str.w	ip, [sp]
      *p++ = c;
 8002aa8:	f88d 000c 	strb.w	r0, [sp, #12]
    if ((width -= i) < 0) {
 8002aac:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
    if (left_align == false) {
 8002ab0:	2a00      	cmp	r2, #0
 8002ab2:	f040 809b 	bne.w	8002bec <chprintf+0x36c>
    if (width < 0) {
 8002ab6:	2b01      	cmp	r3, #1
 8002ab8:	4692      	mov	sl, r2
 8002aba:	ad03      	add	r5, sp, #12
 8002abc:	f340 809a 	ble.w	8002bf4 <chprintf+0x374>
      if ((*s == '-' || *s == '+') && filler == '0') {
 8002ac0:	7829      	ldrb	r1, [r5, #0]
 8002ac2:	292b      	cmp	r1, #43	@ 0x2b
 8002ac4:	bf18      	it	ne
 8002ac6:	292d      	cmpne	r1, #45	@ 0x2d
 8002ac8:	d102      	bne.n	8002ad0 <chprintf+0x250>
 8002aca:	2e30      	cmp	r6, #48	@ 0x30
 8002acc:	f000 80e1 	beq.w	8002c92 <chprintf+0x412>
      width = -width;
 8002ad0:	f1c8 0700 	rsb	r7, r8, #0
        streamPut(chp, (uint8_t)filler);
 8002ad4:	6823      	ldr	r3, [r4, #0]
 8002ad6:	4631      	mov	r1, r6
 8002ad8:	4620      	mov	r0, r4
 8002ada:	68db      	ldr	r3, [r3, #12]
 8002adc:	4798      	blx	r3
      } while (++width != 0);
 8002ade:	3701      	adds	r7, #1
 8002ae0:	d1f8      	bne.n	8002ad4 <chprintf+0x254>
 8002ae2:	44c1      	add	r9, r8
 8002ae4:	46b8      	mov	r8, r7
    while (--i >= 0) {
 8002ae6:	f1ba 0f00 	cmp.w	sl, #0
 8002aea:	db0d      	blt.n	8002b08 <chprintf+0x288>
 8002aec:	f10a 0701 	add.w	r7, sl, #1
 8002af0:	442f      	add	r7, r5
      streamPut(chp, (uint8_t)*s++);
 8002af2:	6823      	ldr	r3, [r4, #0]
 8002af4:	4620      	mov	r0, r4
 8002af6:	f815 1b01 	ldrb.w	r1, [r5], #1
 8002afa:	68db      	ldr	r3, [r3, #12]
 8002afc:	4798      	blx	r3
    while (--i >= 0) {
 8002afe:	42bd      	cmp	r5, r7
 8002b00:	d1f7      	bne.n	8002af2 <chprintf+0x272>
 8002b02:	f109 0901 	add.w	r9, r9, #1
 8002b06:	44d1      	add	r9, sl
    while (width) {
 8002b08:	f1b8 0f00 	cmp.w	r8, #0
 8002b0c:	f43f aed2 	beq.w	80028b4 <chprintf+0x34>
 8002b10:	4645      	mov	r5, r8
      streamPut(chp, (uint8_t)filler);
 8002b12:	6823      	ldr	r3, [r4, #0]
 8002b14:	4631      	mov	r1, r6
 8002b16:	4620      	mov	r0, r4
 8002b18:	68db      	ldr	r3, [r3, #12]
 8002b1a:	4798      	blx	r3
    while (width) {
 8002b1c:	3d01      	subs	r5, #1
 8002b1e:	d1f8      	bne.n	8002b12 <chprintf+0x292>
 8002b20:	44c1      	add	r9, r8
 8002b22:	e6c7      	b.n	80028b4 <chprintf+0x34>
      goto unsigned_common;
 8002b24:	270a      	movs	r7, #10
        l = va_arg(ap, int);
 8002b26:	f10c 0104 	add.w	r1, ip, #4
 8002b2a:	9100      	str	r1, [sp, #0]
        l = va_arg(ap, unsigned int);
 8002b2c:	f8dc 1000 	ldr.w	r1, [ip]
  q = p + MAX_FILLER;
 8002b30:	f10d 0c17 	add.w	ip, sp, #23
 8002b34:	4660      	mov	r0, ip
    i = (int)(l % radix);
 8002b36:	460d      	mov	r5, r1
 8002b38:	fbb1 f1f7 	udiv	r1, r1, r7
 8002b3c:	fb07 5811 	mls	r8, r7, r1, r5
    i += '0';
 8002b40:	f108 0e30 	add.w	lr, r8, #48	@ 0x30
    if (i > '9') {
 8002b44:	f1be 0f39 	cmp.w	lr, #57	@ 0x39
      i += 'A' - '0' - 10;
 8002b48:	bfc8      	it	gt
 8002b4a:	f108 0e37 	addgt.w	lr, r8, #55	@ 0x37
  } while ((ll /= radix) != 0);
 8002b4e:	42af      	cmp	r7, r5
    *--q = i;
 8002b50:	f800 ed01 	strb.w	lr, [r0, #-1]!
  } while ((ll /= radix) != 0);
 8002b54:	d9ef      	bls.n	8002b36 <chprintf+0x2b6>
 8002b56:	ad03      	add	r5, sp, #12
  i = (int)(p + MAX_FILLER - q);
 8002b58:	ebac 0700 	sub.w	r7, ip, r0
 8002b5c:	4629      	mov	r1, r5
    *p++ = *q++;
 8002b5e:	f810 eb01 	ldrb.w	lr, [r0], #1
  while (--i);
 8002b62:	4560      	cmp	r0, ip
    *p++ = *q++;
 8002b64:	f801 eb01 	strb.w	lr, [r1], #1
  while (--i);
 8002b68:	d1f9      	bne.n	8002b5e <chprintf+0x2de>
      p = ch_ltoa(p, l, c);
 8002b6a:	eb05 0a07 	add.w	sl, r5, r7
    i = (int)(p - s);
 8002b6e:	ebaa 0a05 	sub.w	sl, sl, r5
    if ((width -= i) < 0) {
 8002b72:	eba3 030a 	sub.w	r3, r3, sl
        i--;
 8002b76:	f10a 3aff 	add.w	sl, sl, #4294967295	@ 0xffffffff
    if ((width -= i) < 0) {
 8002b7a:	ea23 78e3 	bic.w	r8, r3, r3, asr #31
    if (left_align == false) {
 8002b7e:	2a00      	cmp	r2, #0
 8002b80:	d1b1      	bne.n	8002ae6 <chprintf+0x266>
    if (width < 0) {
 8002b82:	2b00      	cmp	r3, #0
 8002b84:	dc9c      	bgt.n	8002ac0 <chprintf+0x240>
    while (--i >= 0) {
 8002b86:	f1ba 0f00 	cmp.w	sl, #0
 8002b8a:	f6ff ae93 	blt.w	80028b4 <chprintf+0x34>
 8002b8e:	4690      	mov	r8, r2
 8002b90:	e7ac      	b.n	8002aec <chprintf+0x26c>
      if ((s = va_arg(ap, char *)) == 0) {
 8002b92:	4661      	mov	r1, ip
 8002b94:	f851 5b04 	ldr.w	r5, [r1], #4
 8002b98:	9100      	str	r1, [sp, #0]
 8002b9a:	2d00      	cmp	r5, #0
 8002b9c:	f000 8085 	beq.w	8002caa <chprintf+0x42a>
      for (p = s; *p && (--precision >= 0); p++)
 8002ba0:	7829      	ldrb	r1, [r5, #0]
      if (precision == 0) {
 8002ba2:	f1be 0f00 	cmp.w	lr, #0
 8002ba6:	d070      	beq.n	8002c8a <chprintf+0x40a>
      for (p = s; *p && (--precision >= 0); p++)
 8002ba8:	2900      	cmp	r1, #0
 8002baa:	f000 8090 	beq.w	8002cce <chprintf+0x44e>
 8002bae:	f1be 0001 	subs.w	r0, lr, #1
 8002bb2:	f100 808c 	bmi.w	8002cce <chprintf+0x44e>
 8002bb6:	3001      	adds	r0, #1
 8002bb8:	46aa      	mov	sl, r5
 8002bba:	4428      	add	r0, r5
 8002bbc:	e001      	b.n	8002bc2 <chprintf+0x342>
 8002bbe:	4582      	cmp	sl, r0
 8002bc0:	d003      	beq.n	8002bca <chprintf+0x34a>
 8002bc2:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
 8002bc6:	2900      	cmp	r1, #0
 8002bc8:	d1f9      	bne.n	8002bbe <chprintf+0x33e>
      filler = ' ';
 8002bca:	2620      	movs	r6, #32
 8002bcc:	e7cf      	b.n	8002b6e <chprintf+0x2ee>
      *p++ = va_arg(ap, int);
 8002bce:	4661      	mov	r1, ip
    if ((width -= i) < 0) {
 8002bd0:	f103 38ff 	add.w	r8, r3, #4294967295	@ 0xffffffff
      filler = ' ';
 8002bd4:	2620      	movs	r6, #32
      *p++ = va_arg(ap, int);
 8002bd6:	f851 0b04 	ldr.w	r0, [r1], #4
    if ((width -= i) < 0) {
 8002bda:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
      *p++ = va_arg(ap, int);
 8002bde:	b2c0      	uxtb	r0, r0
 8002be0:	9100      	str	r1, [sp, #0]
      *p++ = c;
 8002be2:	f88d 000c 	strb.w	r0, [sp, #12]
    if (left_align == false) {
 8002be6:	2a00      	cmp	r2, #0
 8002be8:	f43f af65 	beq.w	8002ab6 <chprintf+0x236>
    while (--i >= 0) {
 8002bec:	f04f 0a00 	mov.w	sl, #0
    if (left_align == false) {
 8002bf0:	ad03      	add	r5, sp, #12
 8002bf2:	e77b      	b.n	8002aec <chprintf+0x26c>
    if (width < 0) {
 8002bf4:	4690      	mov	r8, r2
 8002bf6:	e779      	b.n	8002aec <chprintf+0x26c>
        l = va_arg(ap, int);
 8002bf8:	4660      	mov	r0, ip
      if (is_long) {
 8002bfa:	2d19      	cmp	r5, #25
        l = va_arg(ap, int);
 8002bfc:	f850 1b04 	ldr.w	r1, [r0], #4
 8002c00:	9000      	str	r0, [sp, #0]
      if (is_long) {
 8002c02:	d930      	bls.n	8002c66 <chprintf+0x3e6>
      if (l < 0) {
 8002c04:	2900      	cmp	r1, #0
 8002c06:	db33      	blt.n	8002c70 <chprintf+0x3f0>
        if (do_sign) {
 8002c08:	2f00      	cmp	r7, #0
 8002c0a:	d053      	beq.n	8002cb4 <chprintf+0x434>
          *p++ = '+';
 8002c0c:	202b      	movs	r0, #43	@ 0x2b
 8002c0e:	f10d 070d 	add.w	r7, sp, #13
 8002c12:	ad03      	add	r5, sp, #12
 8002c14:	f88d 000c 	strb.w	r0, [sp, #12]
  q = p + MAX_FILLER;
 8002c18:	f107 0c0b 	add.w	ip, r7, #11
    i = (int)(l % radix);
 8002c1c:	f8df e0cc 	ldr.w	lr, [pc, #204]	@ 8002cec <chprintf+0x46c>
  q = p + MAX_FILLER;
 8002c20:	9301      	str	r3, [sp, #4]
 8002c22:	4660      	mov	r0, ip
    i = (int)(l % radix);
 8002c24:	fbae 8301 	umull	r8, r3, lr, r1
 8002c28:	4688      	mov	r8, r1
 8002c2a:	08db      	lsrs	r3, r3, #3
  } while ((ll /= radix) != 0);
 8002c2c:	f1b8 0f09 	cmp.w	r8, #9
    i = (int)(l % radix);
 8002c30:	eb03 0a83 	add.w	sl, r3, r3, lsl #2
 8002c34:	4619      	mov	r1, r3
 8002c36:	eba8 034a 	sub.w	r3, r8, sl, lsl #1
    i += '0';
 8002c3a:	f103 0330 	add.w	r3, r3, #48	@ 0x30
    *--q = i;
 8002c3e:	f800 3d01 	strb.w	r3, [r0, #-1]!
  } while ((ll /= radix) != 0);
 8002c42:	dcef      	bgt.n	8002c24 <chprintf+0x3a4>
 8002c44:	9b01      	ldr	r3, [sp, #4]
 8002c46:	1e79      	subs	r1, r7, #1
  i = (int)(p + MAX_FILLER - q);
 8002c48:	ebac 0800 	sub.w	r8, ip, r0
    *p++ = *q++;
 8002c4c:	f810 eb01 	ldrb.w	lr, [r0], #1
  while (--i);
 8002c50:	4584      	cmp	ip, r0
    *p++ = *q++;
 8002c52:	f801 ef01 	strb.w	lr, [r1, #1]!
  while (--i);
 8002c56:	d1f9      	bne.n	8002c4c <chprintf+0x3cc>
      p = ch_ltoa(p, l, 10);
 8002c58:	eb07 0a08 	add.w	sl, r7, r8
 8002c5c:	e787      	b.n	8002b6e <chprintf+0x2ee>
    switch (c) {
 8002c5e:	2710      	movs	r7, #16
 8002c60:	e761      	b.n	8002b26 <chprintf+0x2a6>
 8002c62:	f10c 0004 	add.w	r0, ip, #4
        l = va_arg(ap, long);
 8002c66:	f8dc 1000 	ldr.w	r1, [ip]
 8002c6a:	9000      	str	r0, [sp, #0]
      if (l < 0) {
 8002c6c:	2900      	cmp	r1, #0
 8002c6e:	dacb      	bge.n	8002c08 <chprintf+0x388>
        *p++ = '-';
 8002c70:	202d      	movs	r0, #45	@ 0x2d
        l = -l;
 8002c72:	4249      	negs	r1, r1
        *p++ = '-';
 8002c74:	f10d 070d 	add.w	r7, sp, #13
 8002c78:	ad03      	add	r5, sp, #12
 8002c7a:	f88d 000c 	strb.w	r0, [sp, #12]
        l = -l;
 8002c7e:	e7cb      	b.n	8002c18 <chprintf+0x398>
        l = va_arg(ap, int);
 8002c80:	f10c 0104 	add.w	r1, ip, #4
 8002c84:	2710      	movs	r7, #16
 8002c86:	9100      	str	r1, [sp, #0]
 8002c88:	e750      	b.n	8002b2c <chprintf+0x2ac>
      for (p = s; *p && (--precision >= 0); p++)
 8002c8a:	b301      	cbz	r1, 8002cce <chprintf+0x44e>
 8002c8c:	f647 70fe 	movw	r0, #32766	@ 0x7ffe
 8002c90:	e791      	b.n	8002bb6 <chprintf+0x336>
        streamPut(chp, (uint8_t)*s++);
 8002c92:	6823      	ldr	r3, [r4, #0]
 8002c94:	4620      	mov	r0, r4
      n++;
 8002c96:	f109 0901 	add.w	r9, r9, #1
        streamPut(chp, (uint8_t)*s++);
 8002c9a:	3501      	adds	r5, #1
 8002c9c:	68db      	ldr	r3, [r3, #12]
    while (--i >= 0) {
 8002c9e:	f10a 3aff 	add.w	sl, sl, #4294967295	@ 0xffffffff
        streamPut(chp, (uint8_t)*s++);
 8002ca2:	4798      	blx	r3
        i--;
 8002ca4:	e714      	b.n	8002ad0 <chprintf+0x250>
    switch (c) {
 8002ca6:	2708      	movs	r7, #8
 8002ca8:	e73d      	b.n	8002b26 <chprintf+0x2a6>
        s = "(null)";
 8002caa:	4d11      	ldr	r5, [pc, #68]	@ (8002cf0 <chprintf+0x470>)
      if (precision == 0) {
 8002cac:	f1be 0f00 	cmp.w	lr, #0
 8002cb0:	d0ec      	beq.n	8002c8c <chprintf+0x40c>
 8002cb2:	e77c      	b.n	8002bae <chprintf+0x32e>
    p = tmpbuf;
 8002cb4:	ad03      	add	r5, sp, #12
 8002cb6:	462f      	mov	r7, r5
 8002cb8:	e7ae      	b.n	8002c18 <chprintf+0x398>
        l = va_arg(ap, int);
 8002cba:	f10c 0104 	add.w	r1, ip, #4
 8002cbe:	270a      	movs	r7, #10
 8002cc0:	9100      	str	r1, [sp, #0]
 8002cc2:	e733      	b.n	8002b2c <chprintf+0x2ac>
 8002cc4:	f10c 0104 	add.w	r1, ip, #4
 8002cc8:	2708      	movs	r7, #8
 8002cca:	9100      	str	r1, [sp, #0]
 8002ccc:	e72e      	b.n	8002b2c <chprintf+0x2ac>
    if ((width -= i) < 0) {
 8002cce:	ea23 78e3 	bic.w	r8, r3, r3, asr #31
    if (left_align == false) {
 8002cd2:	b942      	cbnz	r2, 8002ce6 <chprintf+0x466>
    if (width < 0) {
 8002cd4:	2b00      	cmp	r3, #0
 8002cd6:	f77f aded 	ble.w	80028b4 <chprintf+0x34>
 8002cda:	2620      	movs	r6, #32
 8002cdc:	f04f 3aff 	mov.w	sl, #4294967295	@ 0xffffffff
 8002ce0:	e6f6      	b.n	8002ad0 <chprintf+0x250>
  int n = 0;
 8002ce2:	4689      	mov	r9, r1
  return formatted_bytes;
 8002ce4:	e6d6      	b.n	8002a94 <chprintf+0x214>
    if (left_align == false) {
 8002ce6:	2620      	movs	r6, #32
 8002ce8:	e70e      	b.n	8002b08 <chprintf+0x288>
 8002cea:	bf00      	nop
 8002cec:	cccccccd 	.word	0xcccccccd
 8002cf0:	080068d4 	.word	0x080068d4
	...

08002d00 <cmd_exit>:
#if ((SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(__CHIBIOS_NIL__)) ||        \
    defined(__DOXYGEN__)
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8002d00:	2900      	cmp	r1, #0
 8002d02:	dc0a      	bgt.n	8002d1a <cmd_exit+0x1a>
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002d04:	b508      	push	{r3, lr}
 8002d06:	2330      	movs	r3, #48	@ 0x30
 8002d08:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8002d0c:	4805      	ldr	r0, [pc, #20]	@ (8002d24 <cmd_exit+0x24>)
 8002d0e:	2100      	movs	r1, #0
 8002d10:	f7fe fc56 	bl	80015c0 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 8002d14:	2000      	movs	r0, #0
 8002d16:	f7ff fcd3 	bl	80026c0 <chThdExitS>
    shellUsage(chp, "exit");
 8002d1a:	4a03      	ldr	r2, [pc, #12]	@ (8002d28 <cmd_exit+0x28>)
 8002d1c:	4903      	ldr	r1, [pc, #12]	@ (8002d2c <cmd_exit+0x2c>)
 8002d1e:	f7ff bdaf 	b.w	8002880 <chprintf>
 8002d22:	bf00      	nop
 8002d24:	24006c24 	.word	0x24006c24
 8002d28:	080068dc 	.word	0x080068dc
 8002d2c:	080068e4 	.word	0x080068e4

08002d30 <cmd_info>:

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8002d30:	2900      	cmp	r1, #0
 8002d32:	dc2e      	bgt.n	8002d92 <cmd_info+0x62>
    shellUsage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8002d34:	4a19      	ldr	r2, [pc, #100]	@ (8002d9c <cmd_info+0x6c>)
 8002d36:	491a      	ldr	r1, [pc, #104]	@ (8002da0 <cmd_info+0x70>)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002d38:	b530      	push	{r4, r5, lr}
 8002d3a:	4604      	mov	r4, r0
 8002d3c:	b083      	sub	sp, #12
  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8002d3e:	f7ff fd9f 	bl	8002880 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s" SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
 8002d42:	4a18      	ldr	r2, [pc, #96]	@ (8002da4 <cmd_info+0x74>)
 8002d44:	4918      	ldr	r1, [pc, #96]	@ (8002da8 <cmd_info+0x78>)
 8002d46:	4620      	mov	r0, r4
 8002d48:	f7ff fd9a 	bl	8002880 <chprintf>
#endif
  chprintf(chp, "Architecture: %s" SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 8002d4c:	4a17      	ldr	r2, [pc, #92]	@ (8002dac <cmd_info+0x7c>)
 8002d4e:	4918      	ldr	r1, [pc, #96]	@ (8002db0 <cmd_info+0x80>)
 8002d50:	4620      	mov	r0, r4
 8002d52:	f7ff fd95 	bl	8002880 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s" SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
 8002d56:	4a17      	ldr	r2, [pc, #92]	@ (8002db4 <cmd_info+0x84>)
 8002d58:	4917      	ldr	r1, [pc, #92]	@ (8002db8 <cmd_info+0x88>)
 8002d5a:	4620      	mov	r0, r4
 8002d5c:	f7ff fd90 	bl	8002880 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s" SHELL_NEWLINE_STR, PORT_INFO);
 8002d60:	4a16      	ldr	r2, [pc, #88]	@ (8002dbc <cmd_info+0x8c>)
 8002d62:	4917      	ldr	r1, [pc, #92]	@ (8002dc0 <cmd_info+0x90>)
 8002d64:	4620      	mov	r0, r4
 8002d66:	f7ff fd8b 	bl	8002880 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s" SHELL_NEWLINE_STR, PLATFORM_NAME);
 8002d6a:	4a16      	ldr	r2, [pc, #88]	@ (8002dc4 <cmd_info+0x94>)
 8002d6c:	4916      	ldr	r1, [pc, #88]	@ (8002dc8 <cmd_info+0x98>)
 8002d6e:	4620      	mov	r0, r4
 8002d70:	f7ff fd86 	bl	8002880 <chprintf>
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s" SHELL_NEWLINE_STR, BOARD_NAME);
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s" SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 8002d74:	4d15      	ldr	r5, [pc, #84]	@ (8002dcc <cmd_info+0x9c>)
  chprintf(chp, "Board:        %s" SHELL_NEWLINE_STR, BOARD_NAME);
 8002d76:	4a16      	ldr	r2, [pc, #88]	@ (8002dd0 <cmd_info+0xa0>)
 8002d78:	4620      	mov	r0, r4
 8002d7a:	4916      	ldr	r1, [pc, #88]	@ (8002dd4 <cmd_info+0xa4>)
 8002d7c:	f7ff fd80 	bl	8002880 <chprintf>
  chprintf(chp, "Build time:   %s%s%s" SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 8002d80:	4b15      	ldr	r3, [pc, #84]	@ (8002dd8 <cmd_info+0xa8>)
 8002d82:	4a16      	ldr	r2, [pc, #88]	@ (8002ddc <cmd_info+0xac>)
 8002d84:	4620      	mov	r0, r4
 8002d86:	4916      	ldr	r1, [pc, #88]	@ (8002de0 <cmd_info+0xb0>)
 8002d88:	9500      	str	r5, [sp, #0]
 8002d8a:	f7ff fd79 	bl	8002880 <chprintf>
#endif
#endif
}
 8002d8e:	b003      	add	sp, #12
 8002d90:	bd30      	pop	{r4, r5, pc}
    shellUsage(chp, "info");
 8002d92:	4a14      	ldr	r2, [pc, #80]	@ (8002de4 <cmd_info+0xb4>)
 8002d94:	4914      	ldr	r1, [pc, #80]	@ (8002de8 <cmd_info+0xb8>)
 8002d96:	f7ff bd73 	b.w	8002880 <chprintf>
 8002d9a:	bf00      	nop
 8002d9c:	080068f8 	.word	0x080068f8
 8002da0:	08006900 	.word	0x08006900
 8002da4:	08006914 	.word	0x08006914
 8002da8:	08006928 	.word	0x08006928
 8002dac:	0800693c 	.word	0x0800693c
 8002db0:	08006948 	.word	0x08006948
 8002db4:	0800695c 	.word	0x0800695c
 8002db8:	08006968 	.word	0x08006968
 8002dbc:	0800697c 	.word	0x0800697c
 8002dc0:	08006994 	.word	0x08006994
 8002dc4:	080069a8 	.word	0x080069a8
 8002dc8:	080069e8 	.word	0x080069e8
 8002dcc:	08006a4c 	.word	0x08006a4c
 8002dd0:	080069fc 	.word	0x080069fc
 8002dd4:	08006a10 	.word	0x08006a10
 8002dd8:	08006a24 	.word	0x08006a24
 8002ddc:	08006a28 	.word	0x08006a28
 8002de0:	08006a34 	.word	0x08006a34
 8002de4:	080068f0 	.word	0x080068f0
 8002de8:	080068e4 	.word	0x080068e4
 8002dec:	00000000 	.word	0x00000000

08002df0 <cmd_echo>:

#if (SHELL_CMD_ECHO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_echo(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc != 1) {
 8002df0:	2901      	cmp	r1, #1
 8002df2:	d003      	beq.n	8002dfc <cmd_echo+0xc>
    shellUsage(chp, "echo \"message\"");
 8002df4:	4a03      	ldr	r2, [pc, #12]	@ (8002e04 <cmd_echo+0x14>)
 8002df6:	4904      	ldr	r1, [pc, #16]	@ (8002e08 <cmd_echo+0x18>)
 8002df8:	f7ff bd42 	b.w	8002880 <chprintf>
    return;
  }
  chprintf(chp, "%s" SHELL_NEWLINE_STR, argv[0]);
 8002dfc:	6812      	ldr	r2, [r2, #0]
 8002dfe:	4903      	ldr	r1, [pc, #12]	@ (8002e0c <cmd_echo+0x1c>)
 8002e00:	f7ff bd3e 	b.w	8002880 <chprintf>
 8002e04:	08006a58 	.word	0x08006a58
 8002e08:	080068e4 	.word	0x080068e4
 8002e0c:	08006a68 	.word	0x08006a68

08002e10 <cmd_systime>:

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8002e10:	2900      	cmp	r1, #0
 8002e12:	dc05      	bgt.n	8002e20 <cmd_systime+0x10>
  return (systime_t)STM32_ST_TIM->CNT;
 8002e14:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
    shellUsage(chp, "systime");
    return;
  }
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTimeX());
 8002e18:	4903      	ldr	r1, [pc, #12]	@ (8002e28 <cmd_systime+0x18>)
 8002e1a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8002e1c:	f7ff bd30 	b.w	8002880 <chprintf>
    shellUsage(chp, "systime");
 8002e20:	4a02      	ldr	r2, [pc, #8]	@ (8002e2c <cmd_systime+0x1c>)
 8002e22:	4903      	ldr	r1, [pc, #12]	@ (8002e30 <cmd_systime+0x20>)
 8002e24:	f7ff bd2c 	b.w	8002880 <chprintf>
 8002e28:	08006a78 	.word	0x08006a78
 8002e2c:	08006a70 	.word	0x08006a70
 8002e30:	080068e4 	.word	0x080068e4
	...

08002e40 <cmd_clock>:
static void cmd_clock(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002e40:	b510      	push	{r4, lr}
 8002e42:	4604      	mov	r4, r0
  chprintf(chp, "STM32_SYS_CK: %d\r\n", STM32_SYS_CK);
 8002e44:	4a07      	ldr	r2, [pc, #28]	@ (8002e64 <cmd_clock+0x24>)
 8002e46:	4908      	ldr	r1, [pc, #32]	@ (8002e68 <cmd_clock+0x28>)
 8002e48:	f7ff fd1a 	bl	8002880 <chprintf>
  chprintf(chp, "STM32_HCLK: %d\r\n", STM32_HCLK);
 8002e4c:	4a07      	ldr	r2, [pc, #28]	@ (8002e6c <cmd_clock+0x2c>)
 8002e4e:	4908      	ldr	r1, [pc, #32]	@ (8002e70 <cmd_clock+0x30>)
 8002e50:	4620      	mov	r0, r4
 8002e52:	f7ff fd15 	bl	8002880 <chprintf>
  chprintf(chp, "STM32_HSECLK: %d\r\n", STM32_HSECLK);
 8002e56:	4620      	mov	r0, r4
 8002e58:	4a06      	ldr	r2, [pc, #24]	@ (8002e74 <cmd_clock+0x34>)
 8002e5a:	4907      	ldr	r1, [pc, #28]	@ (8002e78 <cmd_clock+0x38>)
}
 8002e5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chprintf(chp, "STM32_HSECLK: %d\r\n", STM32_HSECLK);
 8002e60:	f7ff bd0e 	b.w	8002880 <chprintf>
 8002e64:	10b07600 	.word	0x10b07600
 8002e68:	08006a80 	.word	0x08006a80
 8002e6c:	08583b00 	.word	0x08583b00
 8002e70:	08006a94 	.word	0x08006a94
 8002e74:	017d7840 	.word	0x017d7840
 8002e78:	08006aa8 	.word	0x08006aa8
 8002e7c:	00000000 	.word	0x00000000

08002e80 <parse_arguments>:
static char *parse_arguments(char *str, char **saveptr) {
 8002e80:	b538      	push	{r3, r4, r5, lr}
 8002e82:	460d      	mov	r5, r1
  if (str != NULL)
 8002e84:	b1b0      	cbz	r0, 8002eb4 <parse_arguments+0x34>
 8002e86:	4604      	mov	r4, r0
    *saveptr = str;
 8002e88:	6028      	str	r0, [r5, #0]
  p += strspn(p, " \t");
 8002e8a:	4911      	ldr	r1, [pc, #68]	@ (8002ed0 <parse_arguments+0x50>)
 8002e8c:	4620      	mov	r0, r4
 8002e8e:	f003 faa5 	bl	80063dc <strspn>
  if (*p == '"') {
 8002e92:	5c21      	ldrb	r1, [r4, r0]
  p += strspn(p, " \t");
 8002e94:	4404      	add	r4, r0
  if (*p == '"') {
 8002e96:	2922      	cmp	r1, #34	@ 0x22
 8002e98:	d012      	beq.n	8002ec0 <parse_arguments+0x40>
    *saveptr = strpbrk(p, " \t");
 8002e9a:	490d      	ldr	r1, [pc, #52]	@ (8002ed0 <parse_arguments+0x50>)
 8002e9c:	4620      	mov	r0, r4
 8002e9e:	f003 fa81 	bl	80063a4 <strpbrk>
  if (*saveptr != NULL) {
 8002ea2:	b198      	cbz	r0, 8002ecc <parse_arguments+0x4c>
    *(*saveptr)++ = '\0';
 8002ea4:	1c42      	adds	r2, r0, #1
 8002ea6:	2300      	movs	r3, #0
 8002ea8:	602a      	str	r2, [r5, #0]
 8002eaa:	7003      	strb	r3, [r0, #0]
  return *p != '\0' ? p : NULL;
 8002eac:	7823      	ldrb	r3, [r4, #0]
 8002eae:	b123      	cbz	r3, 8002eba <parse_arguments+0x3a>
}
 8002eb0:	4620      	mov	r0, r4
 8002eb2:	bd38      	pop	{r3, r4, r5, pc}
  p = *saveptr;
 8002eb4:	680c      	ldr	r4, [r1, #0]
  if (!p) {
 8002eb6:	2c00      	cmp	r4, #0
 8002eb8:	d1e7      	bne.n	8002e8a <parse_arguments+0xa>
    return NULL;
 8002eba:	2400      	movs	r4, #0
}
 8002ebc:	4620      	mov	r0, r4
 8002ebe:	bd38      	pop	{r3, r4, r5, pc}
    p++;
 8002ec0:	3401      	adds	r4, #1
    *saveptr = strpbrk(p, "\"");
 8002ec2:	4620      	mov	r0, r4
 8002ec4:	f003 fa06 	bl	80062d4 <strchr>
  if (*saveptr != NULL) {
 8002ec8:	2800      	cmp	r0, #0
 8002eca:	d1eb      	bne.n	8002ea4 <parse_arguments+0x24>
 8002ecc:	6028      	str	r0, [r5, #0]
 8002ece:	e7ed      	b.n	8002eac <parse_arguments+0x2c>
 8002ed0:	08006abc 	.word	0x08006abc
	...

08002ee0 <shellThread>:
 8002ee0:	4aa5      	ldr	r2, [pc, #660]	@ (8003178 <shellThread+0x298>)
  *(scfg->sc_histbuf) = 0;
 8002ee2:	2300      	movs	r3, #0
 8002ee4:	4ca5      	ldr	r4, [pc, #660]	@ (800317c <shellThread+0x29c>)
 8002ee6:	68d1      	ldr	r1, [r2, #12]
  const ShellCommand *scp = scfg->sc_commands;
 8002ee8:	e9d0 9201 	ldrd	r9, r2, [r0, #4]
THD_FUNCTION(shellThread, p) {
 8002eec:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  BaseSequentialStream *chp = scfg->sc_channel;
 8002ef0:	f8d0 b000 	ldr.w	fp, [r0]
THD_FUNCTION(shellThread, p) {
 8002ef4:	b0a7      	sub	sp, #156	@ 0x9c
 8002ef6:	61cc      	str	r4, [r1, #28]
  *(scfg->sc_histbuf) = 0;
 8002ef8:	7013      	strb	r3, [r2, #0]
                       scfg->sc_histbuf,
 8002efa:	6884      	ldr	r4, [r0, #8]
                       scfg->sc_histsize,
 8002efc:	68c7      	ldr	r7, [r0, #12]
  chprintf(chp, SHELL_NEWLINE_STR);
 8002efe:	49a0      	ldr	r1, [pc, #640]	@ (8003180 <shellThread+0x2a0>)
THD_FUNCTION(shellThread, p) {
 8002f00:	9002      	str	r0, [sp, #8]
  chprintf(chp, SHELL_NEWLINE_STR);
 8002f02:	4658      	mov	r0, fp
  ShellHistory hist = {
 8002f04:	9310      	str	r3, [sp, #64]	@ 0x40
 8002f06:	46b8      	mov	r8, r7
 8002f08:	940c      	str	r4, [sp, #48]	@ 0x30
 8002f0a:	970d      	str	r7, [sp, #52]	@ 0x34
 8002f0c:	e9cd 330e 	strd	r3, r3, [sp, #56]	@ 0x38
  chprintf(chp, SHELL_NEWLINE_STR);
 8002f10:	f7ff fcb6 	bl	8002880 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
 8002f14:	499b      	ldr	r1, [pc, #620]	@ (8003184 <shellThread+0x2a4>)
 8002f16:	4658      	mov	r0, fp
 8002f18:	f7ff fcb2 	bl	8002880 <chprintf>
  while (!chThdShouldTerminateX()) {
 8002f1c:	f8cd 901c 	str.w	r9, [sp, #28]
 8002f20:	46a1      	mov	r9, r4
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8002f22:	4b95      	ldr	r3, [pc, #596]	@ (8003178 <shellThread+0x298>)
 8002f24:	68db      	ldr	r3, [r3, #12]
 8002f26:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 8002f2a:	075b      	lsls	r3, r3, #29
 8002f2c:	f100 80f9 	bmi.w	8003122 <shellThread+0x242>
    chprintf(chp, SHELL_PROMPT_STR);
 8002f30:	4995      	ldr	r1, [pc, #596]	@ (8003188 <shellThread+0x2a8>)
 8002f32:	4658      	mov	r0, fp
 8002f34:	f7ff fca4 	bl	8002880 <chprintf>
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
  char *p = line;
 8002f38:	ae16      	add	r6, sp, #88	@ 0x58
  BaseSequentialStream *chp = scfg->sc_channel;
 8002f3a:	9b02      	ldr	r3, [sp, #8]
  char *p = line;
 8002f3c:	4635      	mov	r5, r6
  BaseSequentialStream *chp = scfg->sc_channel;
 8002f3e:	681c      	ldr	r4, [r3, #0]
#endif

  while (true) {
    char c;

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8002f40:	6823      	ldr	r3, [r4, #0]
 8002f42:	2201      	movs	r2, #1
 8002f44:	f10d 0123 	add.w	r1, sp, #35	@ 0x23
 8002f48:	4620      	mov	r0, r4
 8002f4a:	689b      	ldr	r3, [r3, #8]
 8002f4c:	4798      	blx	r3
 8002f4e:	2800      	cmp	r0, #0
 8002f50:	f000 80df 	beq.w	8003112 <shellThread+0x232>
      }
      continue;
    }
#endif
#if (SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(__CHIBIOS_NIL__)
    if (c == 4) {
 8002f54:	f89d 1023 	ldrb.w	r1, [sp, #35]	@ 0x23
 8002f58:	2904      	cmp	r1, #4
 8002f5a:	f000 80d6 	beq.w	800310a <shellThread+0x22a>
      chprintf(chp, "^D");
      return true;
    }
#endif
    if ((c == 8) || (c == 127)) {
 8002f5e:	297f      	cmp	r1, #127	@ 0x7f
 8002f60:	bf18      	it	ne
 8002f62:	2908      	cmpne	r1, #8
 8002f64:	bf0c      	ite	eq
 8002f66:	2201      	moveq	r2, #1
 8002f68:	2200      	movne	r2, #0
 8002f6a:	d019      	beq.n	8002fa0 <shellThread+0xc0>
        streamPut(chp, 0x08);
        p--;
      }
      continue;
    }
    if (c == '\r') {
 8002f6c:	290d      	cmp	r1, #13
 8002f6e:	f000 80e4 	beq.w	800313a <shellThread+0x25a>
#endif
      *p = 0;
      return false;
    }
#if SHELL_USE_COMPLETION == TRUE
    if (c == '\t') {
 8002f72:	2909      	cmp	r1, #9
 8002f74:	d027      	beq.n	8002fc6 <shellThread+0xe6>
      }
      continue;
    }
#endif
#if SHELL_USE_HISTORY == TRUE
    if (c == 14) {
 8002f76:	290e      	cmp	r1, #14
 8002f78:	f000 80a5 	beq.w	80030c6 <shellThread+0x1e6>
        chprintf(chp, "%s", line);
        p = line + len;
      }
      continue;
    }
    if (c == 16) {
 8002f7c:	2910      	cmp	r1, #16
 8002f7e:	f000 80bc 	beq.w	80030fa <shellThread+0x21a>
        p = line + len;
      }
      continue;
    }
#endif
    if (c < 0x20)
 8002f82:	291f      	cmp	r1, #31
        streamPut(chp, 0x08);
 8002f84:	6823      	ldr	r3, [r4, #0]
    if (c < 0x20)
 8002f86:	d9db      	bls.n	8002f40 <shellThread+0x60>
      continue;
    if (p < line + size - 1) {
 8002f88:	f10d 0297 	add.w	r2, sp, #151	@ 0x97
 8002f8c:	4295      	cmp	r5, r2
 8002f8e:	d2d7      	bcs.n	8002f40 <shellThread+0x60>
      streamPut(chp, c);
 8002f90:	68db      	ldr	r3, [r3, #12]
 8002f92:	4620      	mov	r0, r4
 8002f94:	4798      	blx	r3
      *p++ = (char)c;
 8002f96:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
 8002f9a:	f805 3b01 	strb.w	r3, [r5], #1
 8002f9e:	e7cf      	b.n	8002f40 <shellThread+0x60>
      if (p != line) {
 8002fa0:	42b5      	cmp	r5, r6
 8002fa2:	d0cd      	beq.n	8002f40 <shellThread+0x60>
        streamPut(chp, 0x08);
 8002fa4:	6823      	ldr	r3, [r4, #0]
 8002fa6:	2108      	movs	r1, #8
 8002fa8:	4620      	mov	r0, r4
        p--;
 8002faa:	3d01      	subs	r5, #1
        streamPut(chp, 0x08);
 8002fac:	68db      	ldr	r3, [r3, #12]
 8002fae:	4798      	blx	r3
        streamPut(chp, 0x20);
 8002fb0:	6823      	ldr	r3, [r4, #0]
 8002fb2:	2120      	movs	r1, #32
 8002fb4:	4620      	mov	r0, r4
 8002fb6:	68db      	ldr	r3, [r3, #12]
 8002fb8:	4798      	blx	r3
        streamPut(chp, 0x08);
 8002fba:	6823      	ldr	r3, [r4, #0]
 8002fbc:	2108      	movs	r1, #8
 8002fbe:	4620      	mov	r0, r4
 8002fc0:	68db      	ldr	r3, [r3, #12]
 8002fc2:	4798      	blx	r3
 8002fc4:	e7bc      	b.n	8002f40 <shellThread+0x60>
      if (p < line + size - 1) {
 8002fc6:	f10d 0397 	add.w	r3, sp, #151	@ 0x97
 8002fca:	429d      	cmp	r5, r3
 8002fcc:	d2b8      	bcs.n	8002f40 <shellThread+0x60>
  char help_cmp[] = "help";
 8002fce:	4b6f      	ldr	r3, [pc, #444]	@ (800318c <shellThread+0x2ac>)
  if (strstr(help_cmp, line) == help_cmp) {
 8002fd0:	f10d 0a28 	add.w	sl, sp, #40	@ 0x28
        *p = 0;
 8002fd4:	702a      	strb	r2, [r5, #0]
  if (strstr(help_cmp, line) == help_cmp) {
 8002fd6:	4631      	mov	r1, r6
  char help_cmp[] = "help";
 8002fd8:	930a      	str	r3, [sp, #40]	@ 0x28
  if (strstr(help_cmp, line) == help_cmp) {
 8002fda:	4650      	mov	r0, sl
 8002fdc:	9b02      	ldr	r3, [sp, #8]
  char help_cmp[] = "help";
 8002fde:	f88d 202c 	strb.w	r2, [sp, #44]	@ 0x2c
 8002fe2:	691f      	ldr	r7, [r3, #16]
 8002fe4:	685a      	ldr	r2, [r3, #4]
 8002fe6:	9701      	str	r7, [sp, #4]
 8002fe8:	9203      	str	r2, [sp, #12]
  if (strstr(help_cmp, line) == help_cmp) {
 8002fea:	f003 fb79 	bl	80066e0 <strstr>
    *scmp++ = help_cmp;
 8002fee:	463b      	mov	r3, r7
  if (strstr(help_cmp, line) == help_cmp) {
 8002ff0:	4550      	cmp	r0, sl
    *scmp++ = help_cmp;
 8002ff2:	f103 0304 	add.w	r3, r3, #4
 8002ff6:	9304      	str	r3, [sp, #16]
  if (strstr(help_cmp, line) == help_cmp) {
 8002ff8:	f000 8162 	beq.w	80032c0 <shellThread+0x3e0>
  char **scmp = scfg->sc_completion;
 8002ffc:	f8dd a004 	ldr.w	sl, [sp, #4]
 8003000:	4a63      	ldr	r2, [pc, #396]	@ (8003190 <shellThread+0x2b0>)
  while (lcp->sc_name != NULL) {
 8003002:	9405      	str	r4, [sp, #20]
 8003004:	4f63      	ldr	r7, [pc, #396]	@ (8003194 <shellThread+0x2b4>)
 8003006:	4614      	mov	r4, r2
    if (strstr(lcp->sc_name, line) == lcp->sc_name) {
 8003008:	4638      	mov	r0, r7
 800300a:	4631      	mov	r1, r6
 800300c:	f003 fb68 	bl	80066e0 <strstr>
 8003010:	4287      	cmp	r7, r0
      *scmp++ = (char *)lcp->sc_name;
 8003012:	bf08      	it	eq
 8003014:	f84a 7b04 	streq.w	r7, [sl], #4
  while (lcp->sc_name != NULL) {
 8003018:	f854 7f08 	ldr.w	r7, [r4, #8]!
 800301c:	2f00      	cmp	r7, #0
 800301e:	d1f3      	bne.n	8003008 <shellThread+0x128>
  if (scp != NULL) {
 8003020:	9a03      	ldr	r2, [sp, #12]
 8003022:	9c05      	ldr	r4, [sp, #20]
 8003024:	b18a      	cbz	r2, 800304a <shellThread+0x16a>
    while (scp->sc_name != NULL) {
 8003026:	6813      	ldr	r3, [r2, #0]
 8003028:	b17b      	cbz	r3, 800304a <shellThread+0x16a>
 800302a:	9403      	str	r4, [sp, #12]
 800302c:	461f      	mov	r7, r3
 800302e:	4614      	mov	r4, r2
      if (strstr(scp->sc_name, line) == scp->sc_name) {
 8003030:	4638      	mov	r0, r7
 8003032:	4631      	mov	r1, r6
 8003034:	f003 fb54 	bl	80066e0 <strstr>
 8003038:	4287      	cmp	r7, r0
        *scmp++ = (char *)scp->sc_name;
 800303a:	bf08      	it	eq
 800303c:	f84a 7b04 	streq.w	r7, [sl], #4
    while (scp->sc_name != NULL) {
 8003040:	f854 7f08 	ldr.w	r7, [r4, #8]!
 8003044:	2f00      	cmp	r7, #0
 8003046:	d1f3      	bne.n	8003030 <shellThread+0x150>
 8003048:	9c03      	ldr	r4, [sp, #12]
  *scmp = NULL;
 800304a:	2000      	movs	r0, #0
  if (*scmp != NULL) {
 800304c:	9b01      	ldr	r3, [sp, #4]
  *scmp = NULL;
 800304e:	f8ca 0000 	str.w	r0, [sl]
  if (*scmp != NULL) {
 8003052:	f8d3 a000 	ldr.w	sl, [r3]
 8003056:	f1ba 0f00 	cmp.w	sl, #0
 800305a:	f43f af71 	beq.w	8002f40 <shellThread+0x60>
        int len = process_completions(scfg, line, p - line, size);
 800305e:	1baa      	subs	r2, r5, r6
    if (*cmp == NULL) {
 8003060:	685b      	ldr	r3, [r3, #4]
        int len = process_completions(scfg, line, p - line, size);
 8003062:	9203      	str	r2, [sp, #12]
    if (*cmp == NULL) {
 8003064:	2b00      	cmp	r3, #0
 8003066:	f000 816b 	beq.w	8003340 <shellThread+0x460>
      while (*(*scmp + clen) != 0) {
 800306a:	f89a c000 	ldrb.w	ip, [sl]
 800306e:	f1bc 0f00 	cmp.w	ip, #0
 8003072:	f000 81ba 	beq.w	80033ea <shellThread+0x50a>
  char *c = line + length;
 8003076:	4667      	mov	r7, ip
 8003078:	46ae      	mov	lr, r5
 800307a:	f8dd c004 	ldr.w	ip, [sp, #4]
 800307e:	e9cd 9805 	strd	r9, r8, [sp, #20]
 8003082:	e9dd 8903 	ldrd	r8, r9, [sp, #12]
               (*(*cmp + clen) != 0) && (*cmp != NULL)) {
 8003086:	5c1a      	ldrb	r2, [r3, r0]
 8003088:	42ba      	cmp	r2, r7
 800308a:	d106      	bne.n	800309a <shellThread+0x1ba>
 800308c:	464a      	mov	r2, r9
 800308e:	b13b      	cbz	r3, 80030a0 <shellThread+0x1c0>
        while ((*(*scmp + clen) == *(*cmp + clen)) &&
 8003090:	f852 3f04 	ldr.w	r3, [r2, #4]!
               (*(*cmp + clen) != 0) && (*cmp != NULL)) {
 8003094:	5c19      	ldrb	r1, [r3, r0]
 8003096:	42b9      	cmp	r1, r7
 8003098:	d0f9      	beq.n	800308e <shellThread+0x1ae>
        if (*cmp == NULL) {
 800309a:	2b00      	cmp	r3, #0
 800309c:	f040 8114 	bne.w	80032c8 <shellThread+0x3e8>
          if ((c < line + size - 1) && (clen >= length))
 80030a0:	4540      	cmp	r0, r8
 80030a2:	db07      	blt.n	80030b4 <shellThread+0x1d4>
 80030a4:	f10d 0397 	add.w	r3, sp, #151	@ 0x97
 80030a8:	459e      	cmp	lr, r3
 80030aa:	d203      	bcs.n	80030b4 <shellThread+0x1d4>
            *c++ = *(*scmp + clen);
 80030ac:	f80e 7b01 	strb.w	r7, [lr], #1
 80030b0:	f8dc a000 	ldr.w	sl, [ip]
          clen++;
 80030b4:	3001      	adds	r0, #1
      while (*(*scmp + clen) != 0) {
 80030b6:	f81a 7000 	ldrb.w	r7, [sl, r0]
 80030ba:	2f00      	cmp	r7, #0
 80030bc:	f000 813b 	beq.w	8003336 <shellThread+0x456>
        while ((*(*scmp + clen) == *(*cmp + clen)) &&
 80030c0:	f8dc 3004 	ldr.w	r3, [ip, #4]
 80030c4:	e7df      	b.n	8003086 <shellThread+0x1a6>
      int len = get_history(shp, line, SHELL_HIST_DIR_FW);
 80030c6:	2201      	movs	r2, #1
 80030c8:	4631      	mov	r1, r6
 80030ca:	a80c      	add	r0, sp, #48	@ 0x30
 80030cc:	f7fe fef8 	bl	8001ec0 <get_history>
      if (len == 0)
 80030d0:	1e07      	subs	r7, r0, #0
 80030d2:	d130      	bne.n	8003136 <shellThread+0x256>
        *line = 0;
 80030d4:	f88d 7058 	strb.w	r7, [sp, #88]	@ 0x58
        _shell_reset_cur(chp);
 80030d8:	2302      	movs	r3, #2
 80030da:	2244      	movs	r2, #68	@ 0x44
 80030dc:	492e      	ldr	r1, [pc, #184]	@ (8003198 <shellThread+0x2b8>)
 80030de:	4620      	mov	r0, r4
 80030e0:	f7ff fbce 	bl	8002880 <chprintf>
        _shell_clr_line(chp);
 80030e4:	492d      	ldr	r1, [pc, #180]	@ (800319c <shellThread+0x2bc>)
 80030e6:	4620      	mov	r0, r4
        p = line + len;
 80030e8:	19f5      	adds	r5, r6, r7
        _shell_clr_line(chp);
 80030ea:	f7ff fbc9 	bl	8002880 <chprintf>
        chprintf(chp, "%s", line);
 80030ee:	4632      	mov	r2, r6
 80030f0:	492b      	ldr	r1, [pc, #172]	@ (80031a0 <shellThread+0x2c0>)
 80030f2:	4620      	mov	r0, r4
 80030f4:	f7ff fbc4 	bl	8002880 <chprintf>
 80030f8:	e722      	b.n	8002f40 <shellThread+0x60>
      int len = get_history(shp, line, SHELL_HIST_DIR_BK);
 80030fa:	4631      	mov	r1, r6
 80030fc:	a80c      	add	r0, sp, #48	@ 0x30
 80030fe:	f7fe fedf 	bl	8001ec0 <get_history>
      if (len > 0) {
 8003102:	1e07      	subs	r7, r0, #0
 8003104:	f77f af1c 	ble.w	8002f40 <shellThread+0x60>
 8003108:	e7e6      	b.n	80030d8 <shellThread+0x1f8>
      chprintf(chp, "^D");
 800310a:	4926      	ldr	r1, [pc, #152]	@ (80031a4 <shellThread+0x2c4>)
 800310c:	4620      	mov	r0, r4
 800310e:	f7ff fbb7 	bl	8002880 <chprintf>
      chprintf(chp, SHELL_NEWLINE_STR);
 8003112:	491b      	ldr	r1, [pc, #108]	@ (8003180 <shellThread+0x2a0>)
 8003114:	4658      	mov	r0, fp
 8003116:	f7ff fbb3 	bl	8002880 <chprintf>
      chprintf(chp, "logout");
 800311a:	4923      	ldr	r1, [pc, #140]	@ (80031a8 <shellThread+0x2c8>)
 800311c:	4658      	mov	r0, fp
 800311e:	f7ff fbaf 	bl	8002880 <chprintf>
 8003122:	2330      	movs	r3, #48	@ 0x30
 8003124:	f383 8811 	msr	BASEPRI, r3
 8003128:	4820      	ldr	r0, [pc, #128]	@ (80031ac <shellThread+0x2cc>)
 800312a:	2100      	movs	r1, #0
 800312c:	f7fe fa48 	bl	80015c0 <chEvtBroadcastFlagsI>
  chThdExitS(msg);
 8003130:	2000      	movs	r0, #0
 8003132:	f7ff fac5 	bl	80026c0 <chThdExitS>
      if (len >= 0) {
 8003136:	dacf      	bge.n	80030d8 <shellThread+0x1f8>
 8003138:	e702      	b.n	8002f40 <shellThread+0x60>
      chprintf(chp, SHELL_NEWLINE_STR);
 800313a:	4620      	mov	r0, r4
 800313c:	4910      	ldr	r1, [pc, #64]	@ (8003180 <shellThread+0x2a0>)
 800313e:	4692      	mov	sl, r2
      save_history(shp, line, p - line);
 8003140:	1bac      	subs	r4, r5, r6
      chprintf(chp, SHELL_NEWLINE_STR);
 8003142:	f7ff fb9d 	bl	8002880 <chprintf>
  if (length > shp->sh_size - 2)
 8003146:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
 800314a:	429c      	cmp	r4, r3
 800314c:	da65      	bge.n	800321a <shellThread+0x33a>
  while ((*(line + length -1) == ' ') && (length > 0))
 800314e:	1e63      	subs	r3, r4, #1
 8003150:	5cf1      	ldrb	r1, [r6, r3]
 8003152:	18f2      	adds	r2, r6, r3
 8003154:	2920      	cmp	r1, #32
 8003156:	d10a      	bne.n	800316e <shellThread+0x28e>
 8003158:	2c00      	cmp	r4, #0
 800315a:	dc03      	bgt.n	8003164 <shellThread+0x284>
 800315c:	e05d      	b.n	800321a <shellThread+0x33a>
 800315e:	2b00      	cmp	r3, #0
 8003160:	dd05      	ble.n	800316e <shellThread+0x28e>
 8003162:	3b01      	subs	r3, #1
 8003164:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    length--;
 8003168:	461c      	mov	r4, r3
  while ((*(line + length -1) == ' ') && (length > 0))
 800316a:	2920      	cmp	r1, #32
 800316c:	d0f7      	beq.n	800315e <shellThread+0x27e>
  if (length <= 0)
 800316e:	2c00      	cmp	r4, #0
 8003170:	dd53      	ble.n	800321a <shellThread+0x33a>
 8003172:	e9dd 370e 	ldrd	r3, r7, [sp, #56]	@ 0x38
 8003176:	e02b      	b.n	80031d0 <shellThread+0x2f0>
 8003178:	24006e20 	.word	0x24006e20
 800317c:	08006ac0 	.word	0x08006ac0
 8003180:	08006a90 	.word	0x08006a90
 8003184:	08006ac8 	.word	0x08006ac8
 8003188:	08006adc 	.word	0x08006adc
 800318c:	706c6568 	.word	0x706c6568
 8003190:	08007178 	.word	0x08007178
 8003194:	080068dc 	.word	0x080068dc
 8003198:	08006aec 	.word	0x08006aec
 800319c:	08006af8 	.word	0x08006af8
 80031a0:	08006ae4 	.word	0x08006ae4
 80031a4:	08006ae0 	.word	0x08006ae0
 80031a8:	08006afc 	.word	0x08006afc
 80031ac:	24006c24 	.word	0x24006c24
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
 80031b0:	1afa      	subs	r2, r7, r3
 80031b2:	3201      	adds	r2, #1
 80031b4:	eba8 0202 	sub.w	r2, r8, r2
 80031b8:	42a2      	cmp	r2, r4
 80031ba:	dc0f      	bgt.n	80031dc <shellThread+0x2fc>
  int pos = shp->sh_beg + *(shp->sh_buffer + shp->sh_beg) + 1;
 80031bc:	f819 2003 	ldrb.w	r2, [r9, r3]
}
 80031c0:	f04f 0a01 	mov.w	sl, #1
  int pos = shp->sh_beg + *(shp->sh_buffer + shp->sh_beg) + 1;
 80031c4:	4413      	add	r3, r2
 80031c6:	3301      	adds	r3, #1
  if (pos >= shp->sh_size)
 80031c8:	4598      	cmp	r8, r3
    pos -= shp->sh_size;
 80031ca:	bfd8      	it	le
 80031cc:	eba3 0308 	suble.w	r3, r3, r8
  if (shp->sh_end >= shp->sh_beg) {
 80031d0:	429f      	cmp	r7, r3
 80031d2:	daed      	bge.n	80031b0 <shellThread+0x2d0>
    if (length < (shp->sh_beg - shp->sh_end - 1))
 80031d4:	1bda      	subs	r2, r3, r7
 80031d6:	3a01      	subs	r2, #1
 80031d8:	42a2      	cmp	r2, r4
 80031da:	ddef      	ble.n	80031bc <shellThread+0x2dc>
 80031dc:	f1ba 0f00 	cmp.w	sl, #0
 80031e0:	d000      	beq.n	80031e4 <shellThread+0x304>
 80031e2:	930e      	str	r3, [sp, #56]	@ 0x38
  if (length < shp->sh_size - shp->sh_end - 1)
 80031e4:	eba8 0a07 	sub.w	sl, r8, r7
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 80031e8:	1c78      	adds	r0, r7, #1
  if (length < shp->sh_size - shp->sh_end - 1)
 80031ea:	f10a 3aff 	add.w	sl, sl, #4294967295	@ 0xffffffff
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 80031ee:	4448      	add	r0, r9
  if (length < shp->sh_size - shp->sh_end - 1)
 80031f0:	45a2      	cmp	sl, r4
 80031f2:	f340 80d5 	ble.w	80033a0 <shellThread+0x4c0>
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 80031f6:	4622      	mov	r2, r4
 80031f8:	4631      	mov	r1, r6
 80031fa:	f7fd fa81 	bl	8000700 <memcpy>
  shp->sh_end += length + 1;
 80031fe:	1c63      	adds	r3, r4, #1
  *(shp->sh_buffer + shp->sh_end) = 0;
 8003200:	2200      	movs	r2, #0
  *(shp->sh_buffer + shp->sh_end) = (char)length;
 8003202:	b2e4      	uxtb	r4, r4
  shp->sh_end += length + 1;
 8003204:	443b      	add	r3, r7
  shp->sh_cur = 0;
 8003206:	9210      	str	r2, [sp, #64]	@ 0x40
  *(shp->sh_buffer + shp->sh_end) = (char)length;
 8003208:	f809 4007 	strb.w	r4, [r9, r7]
  if (shp->sh_end >= shp->sh_size)
 800320c:	4598      	cmp	r8, r3
    shp->sh_end -= shp->sh_size;
 800320e:	bfd8      	it	le
 8003210:	eba3 0308 	suble.w	r3, r3, r8
  shp->sh_end += length + 1;
 8003214:	930f      	str	r3, [sp, #60]	@ 0x3c
  *(shp->sh_buffer + shp->sh_end) = 0;
 8003216:	f809 2003 	strb.w	r2, [r9, r3]
      *p = 0;
 800321a:	2700      	movs	r7, #0
    lp = parse_arguments(line, &tokp);
 800321c:	a909      	add	r1, sp, #36	@ 0x24
 800321e:	4630      	mov	r0, r6
 8003220:	ac11      	add	r4, sp, #68	@ 0x44
      *p = 0;
 8003222:	702f      	strb	r7, [r5, #0]
    lp = parse_arguments(line, &tokp);
 8003224:	f7ff fe2c 	bl	8002e80 <parse_arguments>
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8003228:	a909      	add	r1, sp, #36	@ 0x24
    lp = parse_arguments(line, &tokp);
 800322a:	4605      	mov	r5, r0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 800322c:	2000      	movs	r0, #0
 800322e:	f7ff fe27 	bl	8002e80 <parse_arguments>
 8003232:	b150      	cbz	r0, 800324a <shellThread+0x36a>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8003234:	2f04      	cmp	r7, #4
 8003236:	d03c      	beq.n	80032b2 <shellThread+0x3d2>
      args[n++] = lp;
 8003238:	f844 0b04 	str.w	r0, [r4], #4
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 800323c:	a909      	add	r1, sp, #36	@ 0x24
 800323e:	2000      	movs	r0, #0
      args[n++] = lp;
 8003240:	3701      	adds	r7, #1
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8003242:	f7ff fe1d 	bl	8002e80 <parse_arguments>
 8003246:	2800      	cmp	r0, #0
 8003248:	d1f4      	bne.n	8003234 <shellThread+0x354>
    args[n] = NULL;
 800324a:	ab26      	add	r3, sp, #152	@ 0x98
 800324c:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 8003250:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 8003254:	2d00      	cmp	r5, #0
 8003256:	f43f ae64 	beq.w	8002f22 <shellThread+0x42>
      if (strcmp(cmd, "help") == 0) {
 800325a:	4976      	ldr	r1, [pc, #472]	@ (8003434 <shellThread+0x554>)
 800325c:	4628      	mov	r0, r5
 800325e:	f7fd f8df 	bl	8000420 <strcmp>
 8003262:	2800      	cmp	r0, #0
 8003264:	f040 80b0 	bne.w	80033c8 <shellThread+0x4e8>
        if (n > 0) {
 8003268:	2f00      	cmp	r7, #0
 800326a:	f040 80c3 	bne.w	80033f4 <shellThread+0x514>
        chprintf(chp, "Commands: help ");
 800326e:	4972      	ldr	r1, [pc, #456]	@ (8003438 <shellThread+0x558>)
 8003270:	4658      	mov	r0, fp
 8003272:	f7ff fb05 	bl	8002880 <chprintf>
  while (scp->sc_name != NULL) {
 8003276:	4c71      	ldr	r4, [pc, #452]	@ (800343c <shellThread+0x55c>)
 8003278:	4a71      	ldr	r2, [pc, #452]	@ (8003440 <shellThread+0x560>)
    chprintf(chp, "%s ", scp->sc_name);
 800327a:	4d72      	ldr	r5, [pc, #456]	@ (8003444 <shellThread+0x564>)
 800327c:	4629      	mov	r1, r5
 800327e:	4658      	mov	r0, fp
 8003280:	f7ff fafe 	bl	8002880 <chprintf>
  while (scp->sc_name != NULL) {
 8003284:	f854 2f08 	ldr.w	r2, [r4, #8]!
 8003288:	2a00      	cmp	r2, #0
 800328a:	d1f7      	bne.n	800327c <shellThread+0x39c>
        if (scp != NULL)
 800328c:	9b07      	ldr	r3, [sp, #28]
 800328e:	b15b      	cbz	r3, 80032a8 <shellThread+0x3c8>
  while (scp->sc_name != NULL) {
 8003290:	9c07      	ldr	r4, [sp, #28]
 8003292:	6822      	ldr	r2, [r4, #0]
 8003294:	b142      	cbz	r2, 80032a8 <shellThread+0x3c8>
    chprintf(chp, "%s ", scp->sc_name);
 8003296:	4d6b      	ldr	r5, [pc, #428]	@ (8003444 <shellThread+0x564>)
 8003298:	4629      	mov	r1, r5
 800329a:	4658      	mov	r0, fp
 800329c:	f7ff faf0 	bl	8002880 <chprintf>
  while (scp->sc_name != NULL) {
 80032a0:	f854 2f08 	ldr.w	r2, [r4, #8]!
 80032a4:	2a00      	cmp	r2, #0
 80032a6:	d1f7      	bne.n	8003298 <shellThread+0x3b8>
        chprintf(chp, SHELL_NEWLINE_STR);
 80032a8:	4967      	ldr	r1, [pc, #412]	@ (8003448 <shellThread+0x568>)
 80032aa:	4658      	mov	r0, fp
 80032ac:	f7ff fae8 	bl	8002880 <chprintf>
 80032b0:	e637      	b.n	8002f22 <shellThread+0x42>
        chprintf(chp, "too many arguments" SHELL_NEWLINE_STR);
 80032b2:	4966      	ldr	r1, [pc, #408]	@ (800344c <shellThread+0x56c>)
 80032b4:	4658      	mov	r0, fp
 80032b6:	f7ff fae3 	bl	8002880 <chprintf>
    args[n] = NULL;
 80032ba:	2300      	movs	r3, #0
 80032bc:	9315      	str	r3, [sp, #84]	@ 0x54
    if (cmd != NULL) {
 80032be:	e630      	b.n	8002f22 <shellThread+0x42>
    *scmp++ = help_cmp;
 80032c0:	f8dd a010 	ldr.w	sl, [sp, #16]
 80032c4:	6038      	str	r0, [r7, #0]
 80032c6:	e69b      	b.n	8003000 <shellThread+0x120>
    *(line + clen) = 0;
 80032c8:	e9dd 9805 	ldrd	r9, r8, [sp, #20]
 80032cc:	1833      	adds	r3, r6, r0
 80032ce:	2200      	movs	r2, #0
 80032d0:	701a      	strb	r2, [r3, #0]
        if (len > 0) {
 80032d2:	2800      	cmp	r0, #0
 80032d4:	f43f ae34 	beq.w	8002f40 <shellThread+0x60>
  if (*(scmp + 1) != NULL) {
 80032d8:	9f01      	ldr	r7, [sp, #4]
 80032da:	9902      	ldr	r1, [sp, #8]
 80032dc:	687a      	ldr	r2, [r7, #4]
 80032de:	f8d1 a000 	ldr.w	sl, [r1]
static void write_completions(ShellConfig *scfg, char *line, int pos) {
 80032e2:	9301      	str	r3, [sp, #4]
  if (*(scmp + 1) != NULL) {
 80032e4:	2a00      	cmp	r2, #0
 80032e6:	d067      	beq.n	80033b8 <shellThread+0x4d8>
    chprintf(chp, SHELL_NEWLINE_STR);
 80032e8:	4957      	ldr	r1, [pc, #348]	@ (8003448 <shellThread+0x568>)
 80032ea:	4650      	mov	r0, sl
 80032ec:	f7ff fac8 	bl	8002880 <chprintf>
    while (*scmp != NULL)
 80032f0:	683a      	ldr	r2, [r7, #0]
 80032f2:	9b01      	ldr	r3, [sp, #4]
 80032f4:	b172      	cbz	r2, 8003314 <shellThread+0x434>
 80032f6:	9401      	str	r4, [sp, #4]
 80032f8:	461f      	mov	r7, r3
      chprintf(chp, " %s", *scmp++);
 80032fa:	4d55      	ldr	r5, [pc, #340]	@ (8003450 <shellThread+0x570>)
 80032fc:	9c04      	ldr	r4, [sp, #16]
 80032fe:	e000      	b.n	8003302 <shellThread+0x422>
 8003300:	3404      	adds	r4, #4
 8003302:	4629      	mov	r1, r5
 8003304:	4650      	mov	r0, sl
 8003306:	f7ff fabb 	bl	8002880 <chprintf>
    while (*scmp != NULL)
 800330a:	6822      	ldr	r2, [r4, #0]
 800330c:	2a00      	cmp	r2, #0
 800330e:	d1f7      	bne.n	8003300 <shellThread+0x420>
 8003310:	9c01      	ldr	r4, [sp, #4]
 8003312:	463b      	mov	r3, r7
    chprintf(chp, SHELL_NEWLINE_STR);
 8003314:	494c      	ldr	r1, [pc, #304]	@ (8003448 <shellThread+0x568>)
 8003316:	4650      	mov	r0, sl
 8003318:	9301      	str	r3, [sp, #4]
 800331a:	f7ff fab1 	bl	8002880 <chprintf>
    chprintf(chp, SHELL_PROMPT_STR);
 800331e:	494d      	ldr	r1, [pc, #308]	@ (8003454 <shellThread+0x574>)
 8003320:	4650      	mov	r0, sl
 8003322:	f7ff faad 	bl	8002880 <chprintf>
    chprintf(chp, "%s", line);
 8003326:	4632      	mov	r2, r6
 8003328:	4650      	mov	r0, sl
 800332a:	494b      	ldr	r1, [pc, #300]	@ (8003458 <shellThread+0x578>)
 800332c:	f7ff faa8 	bl	8002880 <chprintf>
 8003330:	9b01      	ldr	r3, [sp, #4]
          p = line + len;
 8003332:	461d      	mov	r5, r3
 8003334:	e604      	b.n	8002f40 <shellThread+0x60>
    *(line + clen) = 0;
 8003336:	e9dd 9805 	ldrd	r9, r8, [sp, #20]
 800333a:	1833      	adds	r3, r6, r0
 800333c:	5437      	strb	r7, [r6, r0]
 800333e:	e7cb      	b.n	80032d8 <shellThread+0x3f8>
      clen = strlen(*scmp);
 8003340:	4650      	mov	r0, sl
 8003342:	f7fd fa7d 	bl	8000840 <strlen>
      while ((c < line + clen) && (c < line + size - 1))
 8003346:	1833      	adds	r3, r6, r0
      clen = strlen(*scmp);
 8003348:	4602      	mov	r2, r0
      while ((c < line + clen) && (c < line + size - 1))
 800334a:	429d      	cmp	r5, r3
 800334c:	d250      	bcs.n	80033f0 <shellThread+0x510>
        *c++ = *(*scmp + i++);
 800334e:	1baf      	subs	r7, r5, r6
 8003350:	4629      	mov	r1, r5
 8003352:	f81a c007 	ldrb.w	ip, [sl, r7]
 8003356:	f801 cb01 	strb.w	ip, [r1], #1
      while ((c < line + clen) && (c < line + size - 1))
 800335a:	428b      	cmp	r3, r1
 800335c:	d915      	bls.n	800338a <shellThread+0x4aa>
 800335e:	f10d 0c97 	add.w	ip, sp, #151	@ 0x97
 8003362:	4561      	cmp	r1, ip
 8003364:	d2b3      	bcs.n	80032ce <shellThread+0x3ee>
 8003366:	eba7 0e05 	sub.w	lr, r7, r5
 800336a:	f8dd c004 	ldr.w	ip, [sp, #4]
        *c++ = *(*scmp + i++);
 800336e:	eb01 0a0e 	add.w	sl, r1, lr
 8003372:	f8dc 7000 	ldr.w	r7, [ip]
 8003376:	f817 700a 	ldrb.w	r7, [r7, sl]
 800337a:	f801 7b01 	strb.w	r7, [r1], #1
      while ((c < line + clen) && (c < line + size - 1))
 800337e:	f10d 0797 	add.w	r7, sp, #151	@ 0x97
 8003382:	42b9      	cmp	r1, r7
 8003384:	d2a3      	bcs.n	80032ce <shellThread+0x3ee>
 8003386:	428b      	cmp	r3, r1
 8003388:	d8f1      	bhi.n	800336e <shellThread+0x48e>
      if (c < line + size -1) {
 800338a:	f10d 0797 	add.w	r7, sp, #151	@ 0x97
 800338e:	42b9      	cmp	r1, r7
 8003390:	d29d      	bcs.n	80032ce <shellThread+0x3ee>
        *c = ' ';
 8003392:	2320      	movs	r3, #32
        clen++;
 8003394:	3201      	adds	r2, #1
        *c = ' ';
 8003396:	700b      	strb	r3, [r1, #0]
    *(line + clen) = 0;
 8003398:	2300      	movs	r3, #0
 800339a:	54b3      	strb	r3, [r6, r2]
 800339c:	18b3      	adds	r3, r6, r2
 800339e:	e79b      	b.n	80032d8 <shellThread+0x3f8>
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, part_len);
 80033a0:	4652      	mov	r2, sl
 80033a2:	4631      	mov	r1, r6
 80033a4:	f7fd f9ac 	bl	8000700 <memcpy>
    memcpy(shp->sh_buffer, line + part_len, length - part_len);
 80033a8:	eba4 020a 	sub.w	r2, r4, sl
 80033ac:	eb06 010a 	add.w	r1, r6, sl
 80033b0:	4648      	mov	r0, r9
 80033b2:	f7fd f9a5 	bl	8000700 <memcpy>
 80033b6:	e722      	b.n	80031fe <shellThread+0x31e>
    chprintf(chp, "%s", line + pos);
 80033b8:	462a      	mov	r2, r5
 80033ba:	4650      	mov	r0, sl
 80033bc:	4926      	ldr	r1, [pc, #152]	@ (8003458 <shellThread+0x578>)
 80033be:	f7ff fa5f 	bl	8002880 <chprintf>
 80033c2:	9b01      	ldr	r3, [sp, #4]
          p = line + len;
 80033c4:	461d      	mov	r5, r3
 80033c6:	e5bb      	b.n	8002f40 <shellThread+0x60>
 80033c8:	4c1c      	ldr	r4, [pc, #112]	@ (800343c <shellThread+0x55c>)
  while (scp->sc_name != NULL) {
 80033ca:	481d      	ldr	r0, [pc, #116]	@ (8003440 <shellThread+0x560>)
 80033cc:	e002      	b.n	80033d4 <shellThread+0x4f4>
 80033ce:	f854 0f08 	ldr.w	r0, [r4, #8]!
 80033d2:	b1a8      	cbz	r0, 8003400 <shellThread+0x520>
    if (strcmp(scp->sc_name, name) == 0) {
 80033d4:	4629      	mov	r1, r5
 80033d6:	f7fd f823 	bl	8000420 <strcmp>
 80033da:	2800      	cmp	r0, #0
 80033dc:	d1f7      	bne.n	80033ce <shellThread+0x4ee>
      scp->sc_function(chp, argc, argv);
 80033de:	6863      	ldr	r3, [r4, #4]
 80033e0:	aa11      	add	r2, sp, #68	@ 0x44
 80033e2:	4639      	mov	r1, r7
 80033e4:	4658      	mov	r0, fp
 80033e6:	4798      	blx	r3
      return false;
 80033e8:	e59b      	b.n	8002f22 <shellThread+0x42>
    *(line + clen) = 0;
 80033ea:	f88d c058 	strb.w	ip, [sp, #88]	@ 0x58
 80033ee:	e5a7      	b.n	8002f40 <shellThread+0x60>
  char *c = line + length;
 80033f0:	4629      	mov	r1, r5
 80033f2:	e7ce      	b.n	8003392 <shellThread+0x4b2>
          shellUsage(chp, "help");
 80033f4:	4a0f      	ldr	r2, [pc, #60]	@ (8003434 <shellThread+0x554>)
 80033f6:	4658      	mov	r0, fp
 80033f8:	4918      	ldr	r1, [pc, #96]	@ (800345c <shellThread+0x57c>)
 80033fa:	f7ff fa41 	bl	8002880 <chprintf>
          continue;
 80033fe:	e590      	b.n	8002f22 <shellThread+0x42>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 8003400:	9b07      	ldr	r3, [sp, #28]
 8003402:	b163      	cbz	r3, 800341e <shellThread+0x53e>
  while (scp->sc_name != NULL) {
 8003404:	6818      	ldr	r0, [r3, #0]
 8003406:	b150      	cbz	r0, 800341e <shellThread+0x53e>
 8003408:	461c      	mov	r4, r3
 800340a:	e002      	b.n	8003412 <shellThread+0x532>
 800340c:	f854 0f08 	ldr.w	r0, [r4, #8]!
 8003410:	b128      	cbz	r0, 800341e <shellThread+0x53e>
    if (strcmp(scp->sc_name, name) == 0) {
 8003412:	4629      	mov	r1, r5
 8003414:	f7fd f804 	bl	8000420 <strcmp>
 8003418:	2800      	cmp	r0, #0
 800341a:	d1f7      	bne.n	800340c <shellThread+0x52c>
 800341c:	e7df      	b.n	80033de <shellThread+0x4fe>
        chprintf(chp, "%s", cmd);
 800341e:	462a      	mov	r2, r5
 8003420:	490d      	ldr	r1, [pc, #52]	@ (8003458 <shellThread+0x578>)
 8003422:	4658      	mov	r0, fp
 8003424:	f7ff fa2c 	bl	8002880 <chprintf>
        chprintf(chp, " ?" SHELL_NEWLINE_STR);
 8003428:	490d      	ldr	r1, [pc, #52]	@ (8003460 <shellThread+0x580>)
 800342a:	4658      	mov	r0, fp
 800342c:	f7ff fa28 	bl	8002880 <chprintf>
 8003430:	e577      	b.n	8002f22 <shellThread+0x42>
 8003432:	bf00      	nop
 8003434:	08006b1c 	.word	0x08006b1c
 8003438:	08006b24 	.word	0x08006b24
 800343c:	08007178 	.word	0x08007178
 8003440:	080068dc 	.word	0x080068dc
 8003444:	08006b34 	.word	0x08006b34
 8003448:	08006a90 	.word	0x08006a90
 800344c:	08006b04 	.word	0x08006b04
 8003450:	08006ae8 	.word	0x08006ae8
 8003454:	08006adc 	.word	0x08006adc
 8003458:	08006ae4 	.word	0x08006ae4
 800345c:	080068e4 	.word	0x080068e4
 8003460:	08006b38 	.word	0x08006b38
	...

08003470 <cmd_ws2812>:

static void cmd_ws2812(BaseSequentialStream *chp, int argc, char *argv[]) {
  if (argc == 3) {
 8003470:	2903      	cmp	r1, #3
 8003472:	d000      	beq.n	8003476 <cmd_ws2812+0x6>
 8003474:	4770      	bx	lr
static void cmd_ws2812(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003476:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800347a:	4614      	mov	r4, r2
 800347c:	af00      	add	r7, sp, #0
    uint8_t r = atoi(argv[0]);
 800347e:	6810      	ldr	r0, [r2, #0]
  for (int i = 0; i < WS2812_BUFFER_SIZE_DMA; i++) {
    ws2812_frame_buffer_dma[i] = 0;
  }
}

void ws2812_fill_rgb(uint8_t r, uint8_t g, uint8_t b) {
 8003480:	46e9      	mov	r9, sp
 8003482:	f002 fe23 	bl	80060cc <atoi>
 8003486:	4682      	mov	sl, r0
    uint8_t g = atoi(argv[1]);
 8003488:	6860      	ldr	r0, [r4, #4]
 800348a:	f002 fe1f 	bl	80060cc <atoi>
 800348e:	4680      	mov	r8, r0
    uint8_t b = atoi(argv[2]);
 8003490:	68a0      	ldr	r0, [r4, #8]
 8003492:	2400      	movs	r4, #0
 8003494:	f002 fe1a 	bl	80060cc <atoi>
  int size = WS2812_LED_WIDTH * WS2812_LED_HEIGHT;
  uint8_t img_arr[size * 3];
 8003498:	f5ad 7d40 	sub.w	sp, sp, #768	@ 0x300
 800349c:	4621      	mov	r1, r4
 800349e:	4622      	mov	r2, r4
 80034a0:	b2c3      	uxtb	r3, r0
 80034a2:	4626      	mov	r6, r4
    uint8_t g = atoi(argv[1]);
 80034a4:	fa5f f888 	uxtb.w	r8, r8
 80034a8:	460d      	mov	r5, r1
    uint8_t r = atoi(argv[0]);
 80034aa:	fa5f fa8a 	uxtb.w	sl, sl
 80034ae:	4610      	mov	r0, r2
 80034b0:	f368 0407 	bfi	r4, r8, #0, #8
 80034b4:	f363 0607 	bfi	r6, r3, #0, #8
 80034b8:	f363 0107 	bfi	r1, r3, #0, #8
 80034bc:	f368 0007 	bfi	r0, r8, #0, #8
 80034c0:	f36a 0507 	bfi	r5, sl, #0, #8
 80034c4:	f36a 0207 	bfi	r2, sl, #0, #8
 80034c8:	f363 240f 	bfi	r4, r3, #8, #8
 80034cc:	f363 200f 	bfi	r0, r3, #8, #8
 80034d0:	f368 250f 	bfi	r5, r8, #8, #8
 80034d4:	f368 220f 	bfi	r2, r8, #8, #8
 80034d8:	f36a 260f 	bfi	r6, sl, #8, #8
 80034dc:	f36a 210f 	bfi	r1, sl, #8, #8
 80034e0:	f363 4517 	bfi	r5, r3, #16, #8
 80034e4:	f363 4217 	bfi	r2, r3, #16, #8
 80034e8:	f368 4617 	bfi	r6, r8, #16, #8
 80034ec:	f368 4117 	bfi	r1, r8, #16, #8
 80034f0:	f36a 4417 	bfi	r4, sl, #16, #8
 80034f4:	f36a 4017 	bfi	r0, sl, #16, #8
 80034f8:	f363 661f 	bfi	r6, r3, #24, #8
 80034fc:	f363 611f 	bfi	r1, r3, #24, #8
 8003500:	f368 641f 	bfi	r4, r8, #24, #8
 8003504:	f368 601f 	bfi	r0, r8, #24, #8
 8003508:	f36a 651f 	bfi	r5, sl, #24, #8
 800350c:	f36a 621f 	bfi	r2, sl, #24, #8
 8003510:	46e8      	mov	r8, sp
  for (int i = 0; i < size; i++) {
 8003512:	46cc      	mov	ip, r9
  uint8_t img_arr[size * 3];
 8003514:	466b      	mov	r3, sp
    img_arr[i * 3] = g;
 8003516:	601a      	str	r2, [r3, #0]
 8003518:	3318      	adds	r3, #24
 800351a:	f843 0c14 	str.w	r0, [r3, #-20]
 800351e:	f843 1c10 	str.w	r1, [r3, #-16]
 8003522:	f843 5c0c 	str.w	r5, [r3, #-12]
 8003526:	f843 4c08 	str.w	r4, [r3, #-8]
 800352a:	f843 6c04 	str.w	r6, [r3, #-4]
  for (int i = 0; i < size; i++) {
 800352e:	4563      	cmp	r3, ip
 8003530:	d1f1      	bne.n	8003516 <cmd_ws2812+0xa6>
 8003532:	f108 36ff 	add.w	r6, r8, #4294967295	@ 0xffffffff
  }
  ws2812_latch_grbarr(img_arr, size * 3);
}

void ws2812_latch_grbarr(uint8_t *img_arr, int length) {
  int fb_idx = 0;
 8003536:	2500      	movs	r5, #0
 8003538:	f208 28ff 	addw	r8, r8, #767	@ 0x2ff
 800353c:	f8df a060 	ldr.w	sl, [pc, #96]	@ 80035a0 <cmd_ws2812+0x130>
  for (int i = 0; i < length; i++) {
    for (int j = 0; j < 8; j++) {
      if (fb_idx >= WS2812_COLOR_BITS) {
        return;
      }
      ws2812_frame_buffer_dma[fb_idx] = (img_arr[i] & (128 >> j)) ? WS2812_PWM_WIDTH_1 : WS2812_PWM_WIDTH_0;
 8003540:	2480      	movs	r4, #128	@ 0x80
 8003542:	f816 cf01 	ldrb.w	ip, [r6, #1]!
 8003546:	eb0a 0085 	add.w	r0, sl, r5, lsl #2
 800354a:	f5c5 5ec0 	rsb	lr, r5, #6144	@ 0x1800
    for (int j = 0; j < 8; j++) {
 800354e:	2300      	movs	r3, #0
 8003550:	e002      	b.n	8003558 <cmd_ws2812+0xe8>
      if (fb_idx >= WS2812_COLOR_BITS) {
 8003552:	458e      	cmp	lr, r1
 8003554:	460b      	mov	r3, r1
 8003556:	d012      	beq.n	800357e <cmd_ws2812+0x10e>
      ws2812_frame_buffer_dma[fb_idx] = (img_arr[i] & (128 >> j)) ? WS2812_PWM_WIDTH_1 : WS2812_PWM_WIDTH_0;
 8003558:	fa44 f203 	asr.w	r2, r4, r3
    for (int j = 0; j < 8; j++) {
 800355c:	1c59      	adds	r1, r3, #1
      ws2812_frame_buffer_dma[fb_idx] = (img_arr[i] & (128 >> j)) ? WS2812_PWM_WIDTH_1 : WS2812_PWM_WIDTH_0;
 800355e:	ea12 0f0c 	tst.w	r2, ip
 8003562:	bf0c      	ite	eq
 8003564:	2201      	moveq	r2, #1
 8003566:	2204      	movne	r2, #4
    for (int j = 0; j < 8; j++) {
 8003568:	2b07      	cmp	r3, #7
      ws2812_frame_buffer_dma[fb_idx] = (img_arr[i] & (128 >> j)) ? WS2812_PWM_WIDTH_1 : WS2812_PWM_WIDTH_0;
 800356a:	f840 2b04 	str.w	r2, [r0], #4
    for (int j = 0; j < 8; j++) {
 800356e:	d1f0      	bne.n	8003552 <cmd_ws2812+0xe2>
  for (int i = 0; i < length; i++) {
 8003570:	4546      	cmp	r6, r8
 8003572:	d008      	beq.n	8003586 <cmd_ws2812+0x116>
      fb_idx++;
 8003574:	3501      	adds	r5, #1
 8003576:	441d      	add	r5, r3
      if (fb_idx >= WS2812_COLOR_BITS) {
 8003578:	f5b5 5fc0 	cmp.w	r5, #6144	@ 0x1800
 800357c:	d1e1      	bne.n	8003542 <cmd_ws2812+0xd2>
 800357e:	46cd      	mov	sp, r9
    ws2812_fill_rgb(g, r, b);
  }
}
 8003580:	46bd      	mov	sp, r7
 8003582:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
  }
  dmaStreamClearInterrupt(dma);
 8003586:	4a07      	ldr	r2, [pc, #28]	@ (80035a4 <cmd_ws2812+0x134>)
 8003588:	233d      	movs	r3, #61	@ 0x3d
 800358a:	6812      	ldr	r2, [r2, #0]
 800358c:	7b10      	ldrb	r0, [r2, #12]
  dmaStreamEnable(dma);
 800358e:	e9d2 2100 	ldrd	r2, r1, [r2]
  dmaStreamClearInterrupt(dma);
 8003592:	4083      	lsls	r3, r0
 8003594:	600b      	str	r3, [r1, #0]
  dmaStreamEnable(dma);
 8003596:	6813      	ldr	r3, [r2, #0]
 8003598:	f043 0301 	orr.w	r3, r3, #1
 800359c:	6013      	str	r3, [r2, #0]
 800359e:	e7ee      	b.n	800357e <cmd_ws2812+0x10e>
 80035a0:	24000150 	.word	0x24000150
 80035a4:	24006770 	.word	0x24006770
	...

080035b0 <__cpu_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __cpu_init(void) {
 80035b0:	b510      	push	{r4, lr}
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80035b2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80035b6:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80035ba:	481c      	ldr	r0, [pc, #112]	@ (800362c <__cpu_init+0x7c>)
 80035bc:	2200      	movs	r2, #0
 80035be:	f8c0 2250 	str.w	r2, [r0, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 80035c2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80035c6:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 80035ca:	6943      	ldr	r3, [r0, #20]
 80035cc:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80035d0:	6143      	str	r3, [r0, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 80035d2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80035d6:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 80035da:	f8c0 2084 	str.w	r2, [r0, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 80035de:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 80035e2:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80035e6:	f643 74e0 	movw	r4, #16352	@ 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 80035ea:	f3c3 3c4e 	ubfx	ip, r3, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80035ee:	f3c3 0ec9 	ubfx	lr, r3, #3, #10
 80035f2:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80035f6:	ea0c 0104 	and.w	r1, ip, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80035fa:	4673      	mov	r3, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80035fc:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 8003600:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8003602:	f8c0 2260 	str.w	r2, [r0, #608]	@ 0x260
      } while (ways-- != 0U);
 8003606:	1c5a      	adds	r2, r3, #1
 8003608:	d1f8      	bne.n	80035fc <__cpu_init+0x4c>
    } while(sets-- != 0U);
 800360a:	f1ac 0c20 	sub.w	ip, ip, #32
 800360e:	f11c 0f20 	cmn.w	ip, #32
 8003612:	d1f0      	bne.n	80035f6 <__cpu_init+0x46>
 8003614:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8003618:	6943      	ldr	r3, [r0, #20]
 800361a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800361e:	6143      	str	r3, [r0, #20]
 8003620:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8003624:	f3bf 8f6f 	isb	sy

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8003628:	bd10      	pop	{r4, pc}
 800362a:	bf00      	nop
 800362c:	e000ed00 	.word	0xe000ed00

08003630 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8003630:	4770      	bx	lr
 8003632:	bf00      	nop
	...

08003640 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 8003640:	e7fe      	b.n	8003640 <__default_exit>
 8003642:	bf00      	nop
	...

08003650 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8003650:	b570      	push	{r4, r5, r6, lr}
 8003652:	4d13      	ldr	r5, [pc, #76]	@ (80036a0 <__init_ram_areas+0x50>)
 8003654:	f105 0480 	add.w	r4, r5, #128	@ 0x80
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8003658:	f855 2c10 	ldr.w	r2, [r5, #-16]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800365c:	e955 0103 	ldrd	r0, r1, [r5, #-12]
 8003660:	4288      	cmp	r0, r1
 8003662:	d20d      	bcs.n	8003680 <__init_ram_areas+0x30>
 8003664:	3a04      	subs	r2, #4
    uint32_t *p = rap->init_area;
 8003666:	4603      	mov	r3, r0
      *p = *tp;
 8003668:	f852 6f04 	ldr.w	r6, [r2, #4]!
 800366c:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->clear_area) {
 8003670:	428b      	cmp	r3, r1
 8003672:	d3f9      	bcc.n	8003668 <__init_ram_areas+0x18>
 8003674:	1e4b      	subs	r3, r1, #1
 8003676:	1a1b      	subs	r3, r3, r0
 8003678:	f023 0303 	bic.w	r3, r3, #3
 800367c:	3304      	adds	r3, #4
 800367e:	4418      	add	r0, r3
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8003680:	f855 3c04 	ldr.w	r3, [r5, #-4]
 8003684:	4283      	cmp	r3, r0
 8003686:	d907      	bls.n	8003698 <__init_ram_areas+0x48>
      *p = 0;
 8003688:	3b01      	subs	r3, #1
 800368a:	2100      	movs	r1, #0
 800368c:	1a1b      	subs	r3, r3, r0
 800368e:	f023 0203 	bic.w	r2, r3, #3
 8003692:	3204      	adds	r2, #4
 8003694:	f002 fdcc 	bl	8006230 <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8003698:	3510      	adds	r5, #16
 800369a:	42a5      	cmp	r5, r4
 800369c:	d1dc      	bne.n	8003658 <__init_ram_areas+0x8>
#endif
}
 800369e:	bd70      	pop	{r4, r5, r6, pc}
 80036a0:	0800756c 	.word	0x0800756c
	...

080036b0 <Vector58>:
/**
 * @brief   EXTI[0] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI0_HANDLER) {
 80036b0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80036b2:	4d1e      	ldr	r5, [pc, #120]	@ (800372c <Vector58+0x7c>)
 80036b4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80036b8:	f013 0404 	ands.w	r4, r3, #4
 80036bc:	d016      	beq.n	80036ec <Vector58+0x3c>
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 0, pr);
 80036be:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80036c2:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 80036c6:	f003 0301 	and.w	r3, r3, #1
 80036ca:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  exti_serve_irq(pr, 0);
 80036ce:	b123      	cbz	r3, 80036da <Vector58+0x2a>
 80036d0:	4a17      	ldr	r2, [pc, #92]	@ (8003730 <Vector58+0x80>)
 80036d2:	6813      	ldr	r3, [r2, #0]
 80036d4:	b10b      	cbz	r3, 80036da <Vector58+0x2a>
 80036d6:	6850      	ldr	r0, [r2, #4]
 80036d8:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80036da:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80036de:	f013 0404 	ands.w	r4, r3, #4
 80036e2:	d011      	beq.n	8003708 <Vector58+0x58>

  OSAL_IRQ_EPILOGUE();
}
 80036e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80036e8:	f7fd ba72 	b.w	8000bd0 <__port_irq_epilogue>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80036ec:	2330      	movs	r3, #48	@ 0x30
 80036ee:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80036f2:	2103      	movs	r1, #3
 80036f4:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80036f8:	4a0e      	ldr	r2, [pc, #56]	@ (8003734 <Vector58+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80036fa:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80036fc:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80036fe:	f7fd fb07 	bl	8000d10 <trace_next.constprop.0>
 8003702:	f384 8811 	msr	BASEPRI, r4
}
 8003706:	e7da      	b.n	80036be <Vector58+0xe>
 8003708:	2330      	movs	r3, #48	@ 0x30
 800370a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800370e:	2104      	movs	r1, #4
 8003710:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003714:	4a07      	ldr	r2, [pc, #28]	@ (8003734 <Vector58+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003716:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003718:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800371a:	f7fd faf9 	bl	8000d10 <trace_next.constprop.0>
 800371e:	f384 8811 	msr	BASEPRI, r4
}
 8003722:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003726:	f7fd ba53 	b.w	8000bd0 <__port_irq_epilogue>
 800372a:	bf00      	nop
 800372c:	24006e20 	.word	0x24006e20
 8003730:	24006da0 	.word	0x24006da0
 8003734:	080073f8 	.word	0x080073f8
	...

08003740 <Vector5C>:
/**
 * @brief   EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI1_HANDLER) {
 8003740:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003742:	4d1e      	ldr	r5, [pc, #120]	@ (80037bc <Vector5C+0x7c>)
 8003744:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003748:	f013 0404 	ands.w	r4, r3, #4
 800374c:	d016      	beq.n	800377c <Vector5C+0x3c>
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 1, pr);
 800374e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003752:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8003756:	f003 0302 	and.w	r3, r3, #2
 800375a:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  exti_serve_irq(pr, 1);
 800375e:	b123      	cbz	r3, 800376a <Vector5C+0x2a>
 8003760:	4a17      	ldr	r2, [pc, #92]	@ (80037c0 <Vector5C+0x80>)
 8003762:	6893      	ldr	r3, [r2, #8]
 8003764:	b10b      	cbz	r3, 800376a <Vector5C+0x2a>
 8003766:	68d0      	ldr	r0, [r2, #12]
 8003768:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800376a:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 800376e:	f013 0404 	ands.w	r4, r3, #4
 8003772:	d011      	beq.n	8003798 <Vector5C+0x58>

  OSAL_IRQ_EPILOGUE();
}
 8003774:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003778:	f7fd ba2a 	b.w	8000bd0 <__port_irq_epilogue>
 800377c:	2330      	movs	r3, #48	@ 0x30
 800377e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003782:	2103      	movs	r1, #3
 8003784:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003788:	4a0e      	ldr	r2, [pc, #56]	@ (80037c4 <Vector5C+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800378a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800378c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800378e:	f7fd fabf 	bl	8000d10 <trace_next.constprop.0>
 8003792:	f384 8811 	msr	BASEPRI, r4
}
 8003796:	e7da      	b.n	800374e <Vector5C+0xe>
 8003798:	2330      	movs	r3, #48	@ 0x30
 800379a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800379e:	2104      	movs	r1, #4
 80037a0:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80037a4:	4a07      	ldr	r2, [pc, #28]	@ (80037c4 <Vector5C+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80037a6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80037a8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80037aa:	f7fd fab1 	bl	8000d10 <trace_next.constprop.0>
 80037ae:	f384 8811 	msr	BASEPRI, r4
}
 80037b2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80037b6:	f7fd ba0b 	b.w	8000bd0 <__port_irq_epilogue>
 80037ba:	bf00      	nop
 80037bc:	24006e20 	.word	0x24006e20
 80037c0:	24006da0 	.word	0x24006da0
 80037c4:	080073ec 	.word	0x080073ec
	...

080037d0 <Vector60>:
/**
 * @brief   EXTI[2] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI2_HANDLER) {
 80037d0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80037d2:	4d1e      	ldr	r5, [pc, #120]	@ (800384c <Vector60+0x7c>)
 80037d4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80037d8:	f013 0404 	ands.w	r4, r3, #4
 80037dc:	d016      	beq.n	800380c <Vector60+0x3c>
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 2, pr);
 80037de:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80037e2:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 80037e6:	f003 0304 	and.w	r3, r3, #4
 80037ea:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  exti_serve_irq(pr, 2);
 80037ee:	b123      	cbz	r3, 80037fa <Vector60+0x2a>
 80037f0:	4a17      	ldr	r2, [pc, #92]	@ (8003850 <Vector60+0x80>)
 80037f2:	6913      	ldr	r3, [r2, #16]
 80037f4:	b10b      	cbz	r3, 80037fa <Vector60+0x2a>
 80037f6:	6950      	ldr	r0, [r2, #20]
 80037f8:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80037fa:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80037fe:	f013 0404 	ands.w	r4, r3, #4
 8003802:	d011      	beq.n	8003828 <Vector60+0x58>

  OSAL_IRQ_EPILOGUE();
}
 8003804:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003808:	f7fd b9e2 	b.w	8000bd0 <__port_irq_epilogue>
 800380c:	2330      	movs	r3, #48	@ 0x30
 800380e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003812:	2103      	movs	r1, #3
 8003814:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003818:	4a0e      	ldr	r2, [pc, #56]	@ (8003854 <Vector60+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800381a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800381c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800381e:	f7fd fa77 	bl	8000d10 <trace_next.constprop.0>
 8003822:	f384 8811 	msr	BASEPRI, r4
}
 8003826:	e7da      	b.n	80037de <Vector60+0xe>
 8003828:	2330      	movs	r3, #48	@ 0x30
 800382a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800382e:	2104      	movs	r1, #4
 8003830:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003834:	4a07      	ldr	r2, [pc, #28]	@ (8003854 <Vector60+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003836:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003838:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800383a:	f7fd fa69 	bl	8000d10 <trace_next.constprop.0>
 800383e:	f384 8811 	msr	BASEPRI, r4
}
 8003842:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003846:	f7fd b9c3 	b.w	8000bd0 <__port_irq_epilogue>
 800384a:	bf00      	nop
 800384c:	24006e20 	.word	0x24006e20
 8003850:	24006da0 	.word	0x24006da0
 8003854:	080073e0 	.word	0x080073e0
	...

08003860 <Vector64>:
/**
 * @brief   EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI3_HANDLER) {
 8003860:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003862:	4d1e      	ldr	r5, [pc, #120]	@ (80038dc <Vector64+0x7c>)
 8003864:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003868:	f013 0404 	ands.w	r4, r3, #4
 800386c:	d016      	beq.n	800389c <Vector64+0x3c>
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 3, pr);
 800386e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003872:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8003876:	f003 0308 	and.w	r3, r3, #8
 800387a:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  exti_serve_irq(pr, 3);
 800387e:	b123      	cbz	r3, 800388a <Vector64+0x2a>
 8003880:	4a17      	ldr	r2, [pc, #92]	@ (80038e0 <Vector64+0x80>)
 8003882:	6993      	ldr	r3, [r2, #24]
 8003884:	b10b      	cbz	r3, 800388a <Vector64+0x2a>
 8003886:	69d0      	ldr	r0, [r2, #28]
 8003888:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800388a:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 800388e:	f013 0404 	ands.w	r4, r3, #4
 8003892:	d011      	beq.n	80038b8 <Vector64+0x58>

  OSAL_IRQ_EPILOGUE();
}
 8003894:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003898:	f7fd b99a 	b.w	8000bd0 <__port_irq_epilogue>
 800389c:	2330      	movs	r3, #48	@ 0x30
 800389e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80038a2:	2103      	movs	r1, #3
 80038a4:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80038a8:	4a0e      	ldr	r2, [pc, #56]	@ (80038e4 <Vector64+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80038aa:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80038ac:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80038ae:	f7fd fa2f 	bl	8000d10 <trace_next.constprop.0>
 80038b2:	f384 8811 	msr	BASEPRI, r4
}
 80038b6:	e7da      	b.n	800386e <Vector64+0xe>
 80038b8:	2330      	movs	r3, #48	@ 0x30
 80038ba:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80038be:	2104      	movs	r1, #4
 80038c0:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80038c4:	4a07      	ldr	r2, [pc, #28]	@ (80038e4 <Vector64+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80038c6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80038c8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80038ca:	f7fd fa21 	bl	8000d10 <trace_next.constprop.0>
 80038ce:	f384 8811 	msr	BASEPRI, r4
}
 80038d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80038d6:	f7fd b97b 	b.w	8000bd0 <__port_irq_epilogue>
 80038da:	bf00      	nop
 80038dc:	24006e20 	.word	0x24006e20
 80038e0:	24006da0 	.word	0x24006da0
 80038e4:	080073d4 	.word	0x080073d4
	...

080038f0 <Vector68>:
/**
 * @brief   EXTI[4] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI4_HANDLER) {
 80038f0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80038f2:	4d1e      	ldr	r5, [pc, #120]	@ (800396c <Vector68+0x7c>)
 80038f4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80038f8:	f013 0404 	ands.w	r4, r3, #4
 80038fc:	d016      	beq.n	800392c <Vector68+0x3c>
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 4, pr);
 80038fe:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8003902:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8003906:	f003 0310 	and.w	r3, r3, #16
 800390a:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  exti_serve_irq(pr, 4);
 800390e:	b123      	cbz	r3, 800391a <Vector68+0x2a>
 8003910:	4a17      	ldr	r2, [pc, #92]	@ (8003970 <Vector68+0x80>)
 8003912:	6a13      	ldr	r3, [r2, #32]
 8003914:	b10b      	cbz	r3, 800391a <Vector68+0x2a>
 8003916:	6a50      	ldr	r0, [r2, #36]	@ 0x24
 8003918:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800391a:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 800391e:	f013 0404 	ands.w	r4, r3, #4
 8003922:	d011      	beq.n	8003948 <Vector68+0x58>

  OSAL_IRQ_EPILOGUE();
}
 8003924:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003928:	f7fd b952 	b.w	8000bd0 <__port_irq_epilogue>
 800392c:	2330      	movs	r3, #48	@ 0x30
 800392e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003932:	2103      	movs	r1, #3
 8003934:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003938:	4a0e      	ldr	r2, [pc, #56]	@ (8003974 <Vector68+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800393a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800393c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800393e:	f7fd f9e7 	bl	8000d10 <trace_next.constprop.0>
 8003942:	f384 8811 	msr	BASEPRI, r4
}
 8003946:	e7da      	b.n	80038fe <Vector68+0xe>
 8003948:	2330      	movs	r3, #48	@ 0x30
 800394a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800394e:	2104      	movs	r1, #4
 8003950:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003954:	4a07      	ldr	r2, [pc, #28]	@ (8003974 <Vector68+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003956:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003958:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800395a:	f7fd f9d9 	bl	8000d10 <trace_next.constprop.0>
 800395e:	f384 8811 	msr	BASEPRI, r4
}
 8003962:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003966:	f7fd b933 	b.w	8000bd0 <__port_irq_epilogue>
 800396a:	bf00      	nop
 800396c:	24006e20 	.word	0x24006e20
 8003970:	24006da0 	.word	0x24006da0
 8003974:	080073c8 	.word	0x080073c8
	...

08003980 <Vector9C>:
/**
 * @brief   EXTI[5]..EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI5_9_HANDLER) {
 8003980:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003982:	4d2c      	ldr	r5, [pc, #176]	@ (8003a34 <Vector9C+0xb4>)
 8003984:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003988:	f013 0404 	ands.w	r4, r3, #4
 800398c:	d033      	beq.n	80039f6 <Vector9C+0x76>
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 800398e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003992:	f8d3 4088 	ldr.w	r4, [r3, #136]	@ 0x88
 8003996:	f404 7278 	and.w	r2, r4, #992	@ 0x3e0
 800399a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                        (1U << 9), pr);

  exti_serve_irq(pr, 5);
 800399e:	06a3      	lsls	r3, r4, #26
 80039a0:	d504      	bpl.n	80039ac <Vector9C+0x2c>
 80039a2:	4a25      	ldr	r2, [pc, #148]	@ (8003a38 <Vector9C+0xb8>)
 80039a4:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 80039a6:	b10b      	cbz	r3, 80039ac <Vector9C+0x2c>
 80039a8:	6ad0      	ldr	r0, [r2, #44]	@ 0x2c
 80039aa:	4798      	blx	r3
  exti_serve_irq(pr, 6);
 80039ac:	0660      	lsls	r0, r4, #25
 80039ae:	d504      	bpl.n	80039ba <Vector9C+0x3a>
 80039b0:	4a21      	ldr	r2, [pc, #132]	@ (8003a38 <Vector9C+0xb8>)
 80039b2:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80039b4:	b10b      	cbz	r3, 80039ba <Vector9C+0x3a>
 80039b6:	6b50      	ldr	r0, [r2, #52]	@ 0x34
 80039b8:	4798      	blx	r3
  exti_serve_irq(pr, 7);
 80039ba:	0621      	lsls	r1, r4, #24
 80039bc:	d504      	bpl.n	80039c8 <Vector9C+0x48>
 80039be:	4a1e      	ldr	r2, [pc, #120]	@ (8003a38 <Vector9C+0xb8>)
 80039c0:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 80039c2:	b10b      	cbz	r3, 80039c8 <Vector9C+0x48>
 80039c4:	6bd0      	ldr	r0, [r2, #60]	@ 0x3c
 80039c6:	4798      	blx	r3
  exti_serve_irq(pr, 8);
 80039c8:	05e2      	lsls	r2, r4, #23
 80039ca:	d504      	bpl.n	80039d6 <Vector9C+0x56>
 80039cc:	4a1a      	ldr	r2, [pc, #104]	@ (8003a38 <Vector9C+0xb8>)
 80039ce:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 80039d0:	b10b      	cbz	r3, 80039d6 <Vector9C+0x56>
 80039d2:	6c50      	ldr	r0, [r2, #68]	@ 0x44
 80039d4:	4798      	blx	r3
  exti_serve_irq(pr, 9);
 80039d6:	05a3      	lsls	r3, r4, #22
 80039d8:	d504      	bpl.n	80039e4 <Vector9C+0x64>
 80039da:	4a17      	ldr	r2, [pc, #92]	@ (8003a38 <Vector9C+0xb8>)
 80039dc:	6c93      	ldr	r3, [r2, #72]	@ 0x48
 80039de:	b10b      	cbz	r3, 80039e4 <Vector9C+0x64>
 80039e0:	6cd0      	ldr	r0, [r2, #76]	@ 0x4c
 80039e2:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80039e4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80039e8:	f013 0404 	ands.w	r4, r3, #4
 80039ec:	d011      	beq.n	8003a12 <Vector9C+0x92>

  OSAL_IRQ_EPILOGUE();
}
 80039ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80039f2:	f7fd b8ed 	b.w	8000bd0 <__port_irq_epilogue>
 80039f6:	2330      	movs	r3, #48	@ 0x30
 80039f8:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80039fc:	2103      	movs	r1, #3
 80039fe:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003a02:	4a0e      	ldr	r2, [pc, #56]	@ (8003a3c <Vector9C+0xbc>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003a04:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003a06:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003a08:	f7fd f982 	bl	8000d10 <trace_next.constprop.0>
 8003a0c:	f384 8811 	msr	BASEPRI, r4
}
 8003a10:	e7bd      	b.n	800398e <Vector9C+0xe>
 8003a12:	2330      	movs	r3, #48	@ 0x30
 8003a14:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003a18:	2104      	movs	r1, #4
 8003a1a:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003a1e:	4a07      	ldr	r2, [pc, #28]	@ (8003a3c <Vector9C+0xbc>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003a20:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003a22:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003a24:	f7fd f974 	bl	8000d10 <trace_next.constprop.0>
 8003a28:	f384 8811 	msr	BASEPRI, r4
}
 8003a2c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003a30:	f7fd b8ce 	b.w	8000bd0 <__port_irq_epilogue>
 8003a34:	24006e20 	.word	0x24006e20
 8003a38:	24006da0 	.word	0x24006da0
 8003a3c:	080073bc 	.word	0x080073bc

08003a40 <VectorE0>:
/**
 * @brief   EXTI[10]..EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI10_15_HANDLER) {
 8003a40:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003a42:	4d30      	ldr	r5, [pc, #192]	@ (8003b04 <VectorE0+0xc4>)
 8003a44:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003a48:	f013 0404 	ands.w	r4, r3, #4
 8003a4c:	d03a      	beq.n	8003ac4 <VectorE0+0x84>
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 8003a4e:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8003a52:	f8d3 4088 	ldr.w	r4, [r3, #136]	@ 0x88
 8003a56:	f404 427c 	and.w	r2, r4, #64512	@ 0xfc00
 8003a5a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                        (1U << 14) | (1U << 15), pr);

  exti_serve_irq(pr, 10);
 8003a5e:	0562      	lsls	r2, r4, #21
 8003a60:	d504      	bpl.n	8003a6c <VectorE0+0x2c>
 8003a62:	4a29      	ldr	r2, [pc, #164]	@ (8003b08 <VectorE0+0xc8>)
 8003a64:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 8003a66:	b10b      	cbz	r3, 8003a6c <VectorE0+0x2c>
 8003a68:	6d50      	ldr	r0, [r2, #84]	@ 0x54
 8003a6a:	4798      	blx	r3
  exti_serve_irq(pr, 11);
 8003a6c:	0523      	lsls	r3, r4, #20
 8003a6e:	d504      	bpl.n	8003a7a <VectorE0+0x3a>
 8003a70:	4a25      	ldr	r2, [pc, #148]	@ (8003b08 <VectorE0+0xc8>)
 8003a72:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8003a74:	b10b      	cbz	r3, 8003a7a <VectorE0+0x3a>
 8003a76:	6dd0      	ldr	r0, [r2, #92]	@ 0x5c
 8003a78:	4798      	blx	r3
  exti_serve_irq(pr, 12);
 8003a7a:	04e0      	lsls	r0, r4, #19
 8003a7c:	d504      	bpl.n	8003a88 <VectorE0+0x48>
 8003a7e:	4a22      	ldr	r2, [pc, #136]	@ (8003b08 <VectorE0+0xc8>)
 8003a80:	6e13      	ldr	r3, [r2, #96]	@ 0x60
 8003a82:	b10b      	cbz	r3, 8003a88 <VectorE0+0x48>
 8003a84:	6e50      	ldr	r0, [r2, #100]	@ 0x64
 8003a86:	4798      	blx	r3
  exti_serve_irq(pr, 13);
 8003a88:	04a1      	lsls	r1, r4, #18
 8003a8a:	d504      	bpl.n	8003a96 <VectorE0+0x56>
 8003a8c:	4a1e      	ldr	r2, [pc, #120]	@ (8003b08 <VectorE0+0xc8>)
 8003a8e:	6e93      	ldr	r3, [r2, #104]	@ 0x68
 8003a90:	b10b      	cbz	r3, 8003a96 <VectorE0+0x56>
 8003a92:	6ed0      	ldr	r0, [r2, #108]	@ 0x6c
 8003a94:	4798      	blx	r3
  exti_serve_irq(pr, 14);
 8003a96:	0462      	lsls	r2, r4, #17
 8003a98:	d504      	bpl.n	8003aa4 <VectorE0+0x64>
 8003a9a:	4a1b      	ldr	r2, [pc, #108]	@ (8003b08 <VectorE0+0xc8>)
 8003a9c:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8003a9e:	b10b      	cbz	r3, 8003aa4 <VectorE0+0x64>
 8003aa0:	6f50      	ldr	r0, [r2, #116]	@ 0x74
 8003aa2:	4798      	blx	r3
  exti_serve_irq(pr, 15);
 8003aa4:	0423      	lsls	r3, r4, #16
 8003aa6:	d504      	bpl.n	8003ab2 <VectorE0+0x72>
 8003aa8:	4a17      	ldr	r2, [pc, #92]	@ (8003b08 <VectorE0+0xc8>)
 8003aaa:	6f93      	ldr	r3, [r2, #120]	@ 0x78
 8003aac:	b10b      	cbz	r3, 8003ab2 <VectorE0+0x72>
 8003aae:	6fd0      	ldr	r0, [r2, #124]	@ 0x7c
 8003ab0:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003ab2:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003ab6:	f013 0404 	ands.w	r4, r3, #4
 8003aba:	d011      	beq.n	8003ae0 <VectorE0+0xa0>

  OSAL_IRQ_EPILOGUE();
}
 8003abc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003ac0:	f7fd b886 	b.w	8000bd0 <__port_irq_epilogue>
 8003ac4:	2330      	movs	r3, #48	@ 0x30
 8003ac6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003aca:	2103      	movs	r1, #3
 8003acc:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003ad0:	4a0e      	ldr	r2, [pc, #56]	@ (8003b0c <VectorE0+0xcc>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003ad2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003ad4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003ad6:	f7fd f91b 	bl	8000d10 <trace_next.constprop.0>
 8003ada:	f384 8811 	msr	BASEPRI, r4
}
 8003ade:	e7b6      	b.n	8003a4e <VectorE0+0xe>
 8003ae0:	2330      	movs	r3, #48	@ 0x30
 8003ae2:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003ae6:	2104      	movs	r1, #4
 8003ae8:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003aec:	4a07      	ldr	r2, [pc, #28]	@ (8003b0c <VectorE0+0xcc>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003aee:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003af0:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003af2:	f7fd f90d 	bl	8000d10 <trace_next.constprop.0>
 8003af6:	f384 8811 	msr	BASEPRI, r4
}
 8003afa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003afe:	f7fd b867 	b.w	8000bd0 <__port_irq_epilogue>
 8003b02:	bf00      	nop
 8003b04:	24006e20 	.word	0x24006e20
 8003b08:	24006da0 	.word	0x24006da0
 8003b0c:	080073b0 	.word	0x080073b0

08003b10 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8003b10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003b14:	4e3a      	ldr	r6, [pc, #232]	@ (8003c00 <VectorD4+0xf0>)
 8003b16:	f8b6 3088 	ldrh.w	r3, [r6, #136]	@ 0x88
 8003b1a:	f013 0404 	ands.w	r4, r3, #4
 8003b1e:	d060      	beq.n	8003be2 <VectorD4+0xd2>
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
void uart_lld_serve_interrupt(UARTDriver *uartp) {
  uint32_t isr;
  USART_TypeDef *u = uartp->usart;
 8003b20:	f8df 80e0 	ldr.w	r8, [pc, #224]	@ 8003c04 <VectorD4+0xf4>

  /* Reading and clearing status.*/
  isr = u->ISR;
  u->ICR = isr;

  if (isr & (USART_ISR_LBDF | USART_ISR_ORE | USART_ISR_NE |
 8003b24:	f240 130f 	movw	r3, #271	@ 0x10f
  USART_TypeDef *u = uartp->usart;
 8003b28:	f8d8 5008 	ldr.w	r5, [r8, #8]
  uint32_t cr1 = u->CR1;
 8003b2c:	682f      	ldr	r7, [r5, #0]
  isr = u->ISR;
 8003b2e:	69ec      	ldr	r4, [r5, #28]
  if (isr & (USART_ISR_LBDF | USART_ISR_ORE | USART_ISR_NE |
 8003b30:	421c      	tst	r4, r3
  u->ICR = isr;
 8003b32:	622c      	str	r4, [r5, #32]
  if (isr & (USART_ISR_LBDF | USART_ISR_ORE | USART_ISR_NE |
 8003b34:	d019      	beq.n	8003b6a <VectorD4+0x5a>
             USART_ISR_FE   | USART_ISR_PE)) {
    _uart_rx_error_isr_code(uartp, translate_errors(isr));
 8003b36:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003b3a:	691b      	ldr	r3, [r3, #16]
 8003b3c:	b1ab      	cbz	r3, 8003b6a <VectorD4+0x5a>
  if (isr & USART_ISR_PE)
 8003b3e:	f344 0100 	sbfx	r1, r4, #0, #1
  if (isr & USART_ISR_ORE)
 8003b42:	f3c4 02c0 	ubfx	r2, r4, #3, #1
  if (isr & USART_ISR_FE)
 8003b46:	07a0      	lsls	r0, r4, #30
  if (isr & USART_ISR_PE)
 8003b48:	f001 0104 	and.w	r1, r1, #4
 8003b4c:	ea41 1102 	orr.w	r1, r1, r2, lsl #4
    sts |= UART_FRAMING_ERROR;
 8003b50:	bf48      	it	mi
 8003b52:	f041 0108 	orrmi.w	r1, r1, #8
  if (isr & USART_ISR_NE)
 8003b56:	0762      	lsls	r2, r4, #29
    sts |= UART_NOISE_ERROR;
 8003b58:	bf48      	it	mi
 8003b5a:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_LBDF)
 8003b5e:	05e0      	lsls	r0, r4, #23
    _uart_rx_error_isr_code(uartp, translate_errors(isr));
 8003b60:	4828      	ldr	r0, [pc, #160]	@ (8003c04 <VectorD4+0xf4>)
    sts |= UART_BREAK_DETECTED;
 8003b62:	bf48      	it	mi
 8003b64:	f041 0140 	orrmi.w	r1, r1, #64	@ 0x40
    _uart_rx_error_isr_code(uartp, translate_errors(isr));
 8003b68:	4798      	blx	r3
  }

  if ((isr & USART_ISR_TC) && (cr1 & USART_CR1_TCIE)) {
 8003b6a:	0662      	lsls	r2, r4, #25
 8003b6c:	d501      	bpl.n	8003b72 <VectorD4+0x62>
 8003b6e:	067b      	lsls	r3, r7, #25
 8003b70:	d42c      	bmi.n	8003bcc <VectorD4+0xbc>
    /* End of transmission, a callback is generated.*/
    _uart_tx2_isr_code(uartp);
  }

  /* Timeout interrupt sources are only checked if enabled in CR1.*/
  if (((cr1 & USART_CR1_IDLEIE) && (isr & USART_ISR_IDLE)) ||
 8003b72:	06f8      	lsls	r0, r7, #27
 8003b74:	d510      	bpl.n	8003b98 <VectorD4+0x88>
 8003b76:	06e1      	lsls	r1, r4, #27
 8003b78:	d50e      	bpl.n	8003b98 <VectorD4+0x88>
      ((cr1 & USART_CR1_RTOIE) && (isr & USART_ISR_RTOF))) {
    _uart_timeout_isr_code(uartp);
 8003b7a:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003b7e:	695b      	ldr	r3, [r3, #20]
 8003b80:	b10b      	cbz	r3, 8003b86 <VectorD4+0x76>
 8003b82:	4820      	ldr	r0, [pc, #128]	@ (8003c04 <VectorD4+0xf4>)
 8003b84:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003b86:	f8b6 3088 	ldrh.w	r3, [r6, #136]	@ 0x88
 8003b8a:	f013 0404 	ands.w	r4, r3, #4
 8003b8e:	d00c      	beq.n	8003baa <VectorD4+0x9a>
  uart_lld_serve_interrupt(&UARTD1);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
 8003b90:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_EPILOGUE();
 8003b94:	f7fd b81c 	b.w	8000bd0 <__port_irq_epilogue>
  if (((cr1 & USART_CR1_IDLEIE) && (isr & USART_ISR_IDLE)) ||
 8003b98:	017a      	lsls	r2, r7, #5
 8003b9a:	d5f4      	bpl.n	8003b86 <VectorD4+0x76>
      ((cr1 & USART_CR1_RTOIE) && (isr & USART_ISR_RTOF))) {
 8003b9c:	0523      	lsls	r3, r4, #20
 8003b9e:	d4ec      	bmi.n	8003b7a <VectorD4+0x6a>
 8003ba0:	f8b6 3088 	ldrh.w	r3, [r6, #136]	@ 0x88
 8003ba4:	f013 0404 	ands.w	r4, r3, #4
 8003ba8:	d1f2      	bne.n	8003b90 <VectorD4+0x80>
 8003baa:	2330      	movs	r3, #48	@ 0x30
 8003bac:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003bb0:	2104      	movs	r1, #4
 8003bb2:	f8d6 308c 	ldr.w	r3, [r6, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003bb6:	4a14      	ldr	r2, [pc, #80]	@ (8003c08 <VectorD4+0xf8>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003bb8:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003bba:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003bbc:	f7fd f8a8 	bl	8000d10 <trace_next.constprop.0>
 8003bc0:	f384 8811 	msr	BASEPRI, r4
}
 8003bc4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_EPILOGUE();
 8003bc8:	f7fd b802 	b.w	8000bd0 <__port_irq_epilogue>
    _uart_tx2_isr_code(uartp);
 8003bcc:	f8d8 3004 	ldr.w	r3, [r8, #4]
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8003bd0:	f027 0240 	bic.w	r2, r7, #64	@ 0x40
    _uart_tx2_isr_code(uartp);
 8003bd4:	685b      	ldr	r3, [r3, #4]
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8003bd6:	602a      	str	r2, [r5, #0]
    _uart_tx2_isr_code(uartp);
 8003bd8:	2b00      	cmp	r3, #0
 8003bda:	d0ca      	beq.n	8003b72 <VectorD4+0x62>
 8003bdc:	4809      	ldr	r0, [pc, #36]	@ (8003c04 <VectorD4+0xf4>)
 8003bde:	4798      	blx	r3
 8003be0:	e7c7      	b.n	8003b72 <VectorD4+0x62>
 8003be2:	2330      	movs	r3, #48	@ 0x30
 8003be4:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003be8:	2103      	movs	r1, #3
 8003bea:	f8d6 308c 	ldr.w	r3, [r6, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003bee:	4a06      	ldr	r2, [pc, #24]	@ (8003c08 <VectorD4+0xf8>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003bf0:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003bf2:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003bf4:	f7fd f88c 	bl	8000d10 <trace_next.constprop.0>
 8003bf8:	f384 8811 	msr	BASEPRI, r4
}
 8003bfc:	e790      	b.n	8003b20 <VectorD4+0x10>
 8003bfe:	bf00      	nop
 8003c00:	24006e20 	.word	0x24006e20
 8003c04:	24006d7c 	.word	0x24006d7c
 8003c08:	080073a4 	.word	0x080073a4
 8003c0c:	00000000 	.word	0x00000000

08003c10 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8003c10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003c14:	4d4f      	ldr	r5, [pc, #316]	@ (8003d54 <VectorB0+0x144>)
 8003c16:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003c1a:	f013 0404 	ands.w	r4, r3, #4
 8003c1e:	d016      	beq.n	8003c4e <VectorB0+0x3e>
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 8003c20:	f04f 4980 	mov.w	r9, #1073741824	@ 0x40000000
 8003c24:	f8d9 3010 	ldr.w	r3, [r9, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8003c28:	f8d9 200c 	ldr.w	r2, [r9, #12]
 8003c2c:	4013      	ands	r3, r2
 8003c2e:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;

  if ((sr & TIM_SR_CC1IF) != 0U)
 8003c30:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 8003c32:	ea6f 0202 	mvn.w	r2, r2
 8003c36:	f8c9 2010 	str.w	r2, [r9, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 8003c3a:	d416      	bmi.n	8003c6a <VectorB0+0x5a>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003c3c:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003c40:	f013 0404 	ands.w	r4, r3, #4
 8003c44:	d03a      	beq.n	8003cbc <VectorB0+0xac>
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
 8003c46:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8003c4a:	f7fc bfc1 	b.w	8000bd0 <__port_irq_epilogue>
 8003c4e:	2330      	movs	r3, #48	@ 0x30
 8003c50:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003c54:	2103      	movs	r1, #3
 8003c56:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003c5a:	4a3f      	ldr	r2, [pc, #252]	@ (8003d58 <VectorB0+0x148>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003c5c:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003c5e:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003c60:	f7fd f856 	bl	8000d10 <trace_next.constprop.0>
 8003c64:	f384 8811 	msr	BASEPRI, r4
}
 8003c68:	e7da      	b.n	8003c20 <VectorB0+0x10>
 8003c6a:	2330      	movs	r3, #48	@ 0x30
 8003c6c:	f383 8811 	msr	BASEPRI, r3
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8003c70:	4f3a      	ldr	r7, [pc, #232]	@ (8003d5c <VectorB0+0x14c>)
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
 8003c72:	f04f 0a00 	mov.w	sl, #0
 8003c76:	f04f 0830 	mov.w	r8, #48	@ 0x30
 8003c7a:	e009      	b.n	8003c90 <VectorB0+0x80>
 8003c7c:	f38a 8811 	msr	BASEPRI, sl
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
 8003c80:	e9d4 3103 	ldrd	r3, r1, [r4, #12]
 8003c84:	4620      	mov	r0, r4
 8003c86:	4798      	blx	r3
 8003c88:	f388 8811 	msr	BASEPRI, r8

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8003c8c:	6963      	ldr	r3, [r4, #20]
 8003c8e:	bb33      	cbnz	r3, 8003cde <VectorB0+0xce>
 8003c90:	f8d9 0024 	ldr.w	r0, [r9, #36]	@ 0x24
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8003c94:	692c      	ldr	r4, [r5, #16]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003c96:	69ee      	ldr	r6, [r5, #28]
    if (nowdelta < vtp->dlist.delta) {
 8003c98:	68a2      	ldr	r2, [r4, #8]
 8003c9a:	1b81      	subs	r1, r0, r6
 8003c9c:	4291      	cmp	r1, r2
 8003c9e:	d344      	bcc.n	8003d2a <VectorB0+0x11a>
  return systime + (systime_t)interval;
 8003ca0:	4416      	add	r6, r2
  dlp->prev->next = dlp->next;
 8003ca2:	e9d4 1000 	ldrd	r1, r0, [r4]
    vtlp->lasttime = lasttime;
 8003ca6:	61ee      	str	r6, [r5, #28]
 8003ca8:	6001      	str	r1, [r0, #0]
  dlp->next->prev = dlp->prev;
 8003caa:	6048      	str	r0, [r1, #4]
    vtp->dlist.next = NULL;
 8003cac:	f8c4 a000 	str.w	sl, [r4]
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8003cb0:	692b      	ldr	r3, [r5, #16]
 8003cb2:	42bb      	cmp	r3, r7
 8003cb4:	d1e2      	bne.n	8003c7c <VectorB0+0x6c>
  STM32_ST_TIM->DIER = 0U;
 8003cb6:	f8c9 a00c 	str.w	sl, [r9, #12]
 8003cba:	e7df      	b.n	8003c7c <VectorB0+0x6c>
 8003cbc:	2330      	movs	r3, #48	@ 0x30
 8003cbe:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003cc2:	2104      	movs	r1, #4
 8003cc4:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003cc8:	4a23      	ldr	r2, [pc, #140]	@ (8003d58 <VectorB0+0x148>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003cca:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003ccc:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003cce:	f7fd f81f 	bl	8000d10 <trace_next.constprop.0>
 8003cd2:	f384 8811 	msr	BASEPRI, r4
}
 8003cd6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8003cda:	f7fc bf79 	b.w	8000bd0 <__port_irq_epilogue>
  return (systime_t)STM32_ST_TIM->CNT;
 8003cde:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8003ce2:	6a51      	ldr	r1, [r2, #36]	@ 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8003ce4:	1b8a      	subs	r2, r1, r6
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8003ce6:	4293      	cmp	r3, r2
 8003ce8:	d31c      	bcc.n	8003d24 <VectorB0+0x114>
  return (bool)(dlhp == dlhp->next);
 8003cea:	692a      	ldr	r2, [r5, #16]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8003cec:	42ba      	cmp	r2, r7
 8003cee:	d02b      	beq.n	8003d48 <VectorB0+0x138>
  while (likely(dlp->delta < delta)) {
 8003cf0:	6891      	ldr	r1, [r2, #8]
 8003cf2:	428b      	cmp	r3, r1
 8003cf4:	d909      	bls.n	8003d0a <VectorB0+0xfa>
    chDbgAssert(dlp != dlep, "element already in list");
 8003cf6:	42a2      	cmp	r2, r4
 8003cf8:	d102      	bne.n	8003d00 <VectorB0+0xf0>
 8003cfa:	e022      	b.n	8003d42 <VectorB0+0x132>
 8003cfc:	4294      	cmp	r4, r2
 8003cfe:	d020      	beq.n	8003d42 <VectorB0+0x132>
    dlp = dlp->next;
 8003d00:	6812      	ldr	r2, [r2, #0]
    delta -= dlp->delta;
 8003d02:	1a5b      	subs	r3, r3, r1
  while (likely(dlp->delta < delta)) {
 8003d04:	6891      	ldr	r1, [r2, #8]
 8003d06:	428b      	cmp	r3, r1
 8003d08:	d8f8      	bhi.n	8003cfc <VectorB0+0xec>
  dlp->delta      = delta;
 8003d0a:	60a3      	str	r3, [r4, #8]
  dlp->delta -= delta;
 8003d0c:	6891      	ldr	r1, [r2, #8]
  dlp->next       = dlhp;
 8003d0e:	6022      	str	r2, [r4, #0]
  dlp->delta -= delta;
 8003d10:	1ac9      	subs	r1, r1, r3
  dlp->prev       = dlp->next->prev;
 8003d12:	6853      	ldr	r3, [r2, #4]
 8003d14:	6063      	str	r3, [r4, #4]
  dlp->prev->next = dlp;
 8003d16:	601c      	str	r4, [r3, #0]
  dlhp->delta = (sysinterval_t)-1;
 8003d18:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  dlp->delta -= delta;
 8003d1c:	e9c2 4101 	strd	r4, r1, [r2, #4]
  dlhp->delta = (sysinterval_t)-1;
 8003d20:	61ab      	str	r3, [r5, #24]
}
 8003d22:	e7a8      	b.n	8003c76 <VectorB0+0x66>
        chDbgAssert(false, "skipped deadline");
 8003d24:	480e      	ldr	r0, [pc, #56]	@ (8003d60 <VectorB0+0x150>)
 8003d26:	f7fd f813 	bl	8000d50 <chSysHalt>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8003d2a:	42bc      	cmp	r4, r7
 8003d2c:	d005      	beq.n	8003d3a <VectorB0+0x12a>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;
 8003d2e:	1a12      	subs	r2, r2, r0
  vtlp->lasttime += nowdelta;
 8003d30:	61e8      	str	r0, [r5, #28]
  vtp->dlist.delta -= nowdelta;
 8003d32:	1991      	adds	r1, r2, r6
 8003d34:	60a1      	str	r1, [r4, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 8003d36:	f7fd fa33 	bl	80011a0 <vt_set_alarm>
 8003d3a:	2300      	movs	r3, #0
 8003d3c:	f383 8811 	msr	BASEPRI, r3
}
 8003d40:	e77c      	b.n	8003c3c <VectorB0+0x2c>
    chDbgAssert(dlp != dlep, "element already in list");
 8003d42:	4808      	ldr	r0, [pc, #32]	@ (8003d64 <VectorB0+0x154>)
 8003d44:	f7fd f804 	bl	8000d50 <chSysHalt>
        delay = vtp->reload - nowdelta;
 8003d48:	1a5b      	subs	r3, r3, r1
        vt_insert_first(vtlp, vtp, now, delay);
 8003d4a:	4620      	mov	r0, r4
 8003d4c:	199a      	adds	r2, r3, r6
 8003d4e:	f7fd fb9f 	bl	8001490 <vt_insert_first.constprop.0>
        return;
 8003d52:	e7f2      	b.n	8003d3a <VectorB0+0x12a>
 8003d54:	24006e20 	.word	0x24006e20
 8003d58:	08007398 	.word	0x08007398
 8003d5c:	24006e30 	.word	0x24006e30
 8003d60:	0800738c 	.word	0x0800738c
 8003d64:	0800737c 	.word	0x0800737c
	...

08003d70 <Vector108>:
/**
 * @brief   TIM5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM5_HANDLER) {
 8003d70:	b570      	push	{r4, r5, r6, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003d72:	4d2c      	ldr	r5, [pc, #176]	@ (8003e24 <Vector108+0xb4>)
 8003d74:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003d78:	f013 0404 	ands.w	r4, r3, #4
 8003d7c:	d033      	beq.n	8003de6 <Vector108+0x76>
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8003d7e:	4e2a      	ldr	r6, [pc, #168]	@ (8003e28 <Vector108+0xb8>)
 8003d80:	69f3      	ldr	r3, [r6, #28]
 8003d82:	691c      	ldr	r4, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8003d84:	68da      	ldr	r2, [r3, #12]
 8003d86:	4014      	ands	r4, r2
 8003d88:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 8003d8a:	43d2      	mvns	r2, r2
 8003d8c:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8003d8e:	07a3      	lsls	r3, r4, #30
 8003d90:	d504      	bpl.n	8003d9c <Vector108+0x2c>
      (pwmp->config->channels[0].callback != NULL))
 8003d92:	6873      	ldr	r3, [r6, #4]
 8003d94:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8003d96:	b10b      	cbz	r3, 8003d9c <Vector108+0x2c>
    pwmp->config->channels[0].callback(pwmp);
 8003d98:	4630      	mov	r0, r6
 8003d9a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8003d9c:	0760      	lsls	r0, r4, #29
 8003d9e:	d504      	bpl.n	8003daa <Vector108+0x3a>
      (pwmp->config->channels[1].callback != NULL))
 8003da0:	6873      	ldr	r3, [r6, #4]
 8003da2:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8003da4:	b10b      	cbz	r3, 8003daa <Vector108+0x3a>
    pwmp->config->channels[1].callback(pwmp);
 8003da6:	4820      	ldr	r0, [pc, #128]	@ (8003e28 <Vector108+0xb8>)
 8003da8:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8003daa:	0721      	lsls	r1, r4, #28
 8003dac:	d504      	bpl.n	8003db8 <Vector108+0x48>
      (pwmp->config->channels[2].callback != NULL))
 8003dae:	6873      	ldr	r3, [r6, #4]
 8003db0:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8003db2:	b10b      	cbz	r3, 8003db8 <Vector108+0x48>
    pwmp->config->channels[2].callback(pwmp);
 8003db4:	481c      	ldr	r0, [pc, #112]	@ (8003e28 <Vector108+0xb8>)
 8003db6:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8003db8:	06e2      	lsls	r2, r4, #27
 8003dba:	d504      	bpl.n	8003dc6 <Vector108+0x56>
      (pwmp->config->channels[3].callback != NULL))
 8003dbc:	6873      	ldr	r3, [r6, #4]
 8003dbe:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8003dc0:	b10b      	cbz	r3, 8003dc6 <Vector108+0x56>
    pwmp->config->channels[3].callback(pwmp);
 8003dc2:	4819      	ldr	r0, [pc, #100]	@ (8003e28 <Vector108+0xb8>)
 8003dc4:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8003dc6:	07e3      	lsls	r3, r4, #31
 8003dc8:	d504      	bpl.n	8003dd4 <Vector108+0x64>
 8003dca:	6873      	ldr	r3, [r6, #4]
 8003dcc:	689b      	ldr	r3, [r3, #8]
 8003dce:	b10b      	cbz	r3, 8003dd4 <Vector108+0x64>
    pwmp->config->callback(pwmp);
 8003dd0:	4815      	ldr	r0, [pc, #84]	@ (8003e28 <Vector108+0xb8>)
 8003dd2:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003dd4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003dd8:	f013 0404 	ands.w	r4, r3, #4
 8003ddc:	d011      	beq.n	8003e02 <Vector108+0x92>
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
 8003dde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8003de2:	f7fc bef5 	b.w	8000bd0 <__port_irq_epilogue>
 8003de6:	2330      	movs	r3, #48	@ 0x30
 8003de8:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003dec:	2103      	movs	r1, #3
 8003dee:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003df2:	4a0e      	ldr	r2, [pc, #56]	@ (8003e2c <Vector108+0xbc>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003df4:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003df6:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003df8:	f7fc ff8a 	bl	8000d10 <trace_next.constprop.0>
 8003dfc:	f384 8811 	msr	BASEPRI, r4
}
 8003e00:	e7bd      	b.n	8003d7e <Vector108+0xe>
 8003e02:	2330      	movs	r3, #48	@ 0x30
 8003e04:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003e08:	2104      	movs	r1, #4
 8003e0a:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003e0e:	4a07      	ldr	r2, [pc, #28]	@ (8003e2c <Vector108+0xbc>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003e10:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003e12:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003e14:	f7fc ff7c 	bl	8000d10 <trace_next.constprop.0>
 8003e18:	f384 8811 	msr	BASEPRI, r4
}
 8003e1c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8003e20:	f7fc bed6 	b.w	8000bd0 <__port_irq_epilogue>
 8003e24:	24006e20 	.word	0x24006e20
 8003e28:	24006d5c 	.word	0x24006d5c
 8003e2c:	08007370 	.word	0x08007370

08003e30 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8003e30:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003e32:	4d1c      	ldr	r5, [pc, #112]	@ (8003ea4 <Vector6C+0x74>)
 8003e34:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003e38:	f013 0404 	ands.w	r4, r3, #4
 8003e3c:	d012      	beq.n	8003e64 <Vector6C+0x34>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003e3e:	4b1a      	ldr	r3, [pc, #104]	@ (8003ea8 <Vector6C+0x78>)
  DMA1->LIFCR = flags << 0U;
  if (dma.streams[0].func)
 8003e40:	481a      	ldr	r0, [pc, #104]	@ (8003eac <Vector6C+0x7c>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003e42:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[0].func)
 8003e44:	6842      	ldr	r2, [r0, #4]
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003e46:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA1->LIFCR = flags << 0U;
 8003e4a:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
 8003e4c:	b10a      	cbz	r2, 8003e52 <Vector6C+0x22>
    dma.streams[0].func(dma.streams[0].param, flags);
 8003e4e:	6880      	ldr	r0, [r0, #8]
 8003e50:	4790      	blx	r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003e52:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003e56:	f013 0404 	ands.w	r4, r3, #4
 8003e5a:	d011      	beq.n	8003e80 <Vector6C+0x50>

  OSAL_IRQ_EPILOGUE();
}
 8003e5c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003e60:	f7fc beb6 	b.w	8000bd0 <__port_irq_epilogue>
 8003e64:	2330      	movs	r3, #48	@ 0x30
 8003e66:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003e6a:	2103      	movs	r1, #3
 8003e6c:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003e70:	4a0f      	ldr	r2, [pc, #60]	@ (8003eb0 <Vector6C+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003e72:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003e74:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003e76:	f7fc ff4b 	bl	8000d10 <trace_next.constprop.0>
 8003e7a:	f384 8811 	msr	BASEPRI, r4
}
 8003e7e:	e7de      	b.n	8003e3e <Vector6C+0xe>
 8003e80:	2330      	movs	r3, #48	@ 0x30
 8003e82:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003e86:	2104      	movs	r1, #4
 8003e88:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003e8c:	4a08      	ldr	r2, [pc, #32]	@ (8003eb0 <Vector6C+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003e8e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003e90:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003e92:	f7fc ff3d 	bl	8000d10 <trace_next.constprop.0>
 8003e96:	f384 8811 	msr	BASEPRI, r4
}
 8003e9a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003e9e:	f7fc be97 	b.w	8000bd0 <__port_irq_epilogue>
 8003ea2:	bf00      	nop
 8003ea4:	24006e20 	.word	0x24006e20
 8003ea8:	40020000 	.word	0x40020000
 8003eac:	24006cd8 	.word	0x24006cd8
 8003eb0:	08007364 	.word	0x08007364
	...

08003ec0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8003ec0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003ec2:	4d1d      	ldr	r5, [pc, #116]	@ (8003f38 <Vector70+0x78>)
 8003ec4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003ec8:	f013 0404 	ands.w	r4, r3, #4
 8003ecc:	d014      	beq.n	8003ef8 <Vector70+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003ece:	4b1b      	ldr	r3, [pc, #108]	@ (8003f3c <Vector70+0x7c>)
  DMA1->LIFCR = flags << 6U;
  if (dma.streams[1].func)
 8003ed0:	4a1b      	ldr	r2, [pc, #108]	@ (8003f40 <Vector70+0x80>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003ed2:	6819      	ldr	r1, [r3, #0]
 8003ed4:	0989      	lsrs	r1, r1, #6
 8003ed6:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA1->LIFCR = flags << 6U;
 8003eda:	0188      	lsls	r0, r1, #6
 8003edc:	6098      	str	r0, [r3, #8]
  if (dma.streams[1].func)
 8003ede:	68d3      	ldr	r3, [r2, #12]
 8003ee0:	b10b      	cbz	r3, 8003ee6 <Vector70+0x26>
    dma.streams[1].func(dma.streams[1].param, flags);
 8003ee2:	6910      	ldr	r0, [r2, #16]
 8003ee4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003ee6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003eea:	f013 0404 	ands.w	r4, r3, #4
 8003eee:	d011      	beq.n	8003f14 <Vector70+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003ef0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003ef4:	f7fc be6c 	b.w	8000bd0 <__port_irq_epilogue>
 8003ef8:	2330      	movs	r3, #48	@ 0x30
 8003efa:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003efe:	2103      	movs	r1, #3
 8003f00:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003f04:	4a0f      	ldr	r2, [pc, #60]	@ (8003f44 <Vector70+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003f06:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003f08:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003f0a:	f7fc ff01 	bl	8000d10 <trace_next.constprop.0>
 8003f0e:	f384 8811 	msr	BASEPRI, r4
}
 8003f12:	e7dc      	b.n	8003ece <Vector70+0xe>
 8003f14:	2330      	movs	r3, #48	@ 0x30
 8003f16:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003f1a:	2104      	movs	r1, #4
 8003f1c:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003f20:	4a08      	ldr	r2, [pc, #32]	@ (8003f44 <Vector70+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003f22:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003f24:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003f26:	f7fc fef3 	bl	8000d10 <trace_next.constprop.0>
 8003f2a:	f384 8811 	msr	BASEPRI, r4
}
 8003f2e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003f32:	f7fc be4d 	b.w	8000bd0 <__port_irq_epilogue>
 8003f36:	bf00      	nop
 8003f38:	24006e20 	.word	0x24006e20
 8003f3c:	40020000 	.word	0x40020000
 8003f40:	24006cd8 	.word	0x24006cd8
 8003f44:	08007358 	.word	0x08007358
	...

08003f50 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8003f50:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003f52:	4d1d      	ldr	r5, [pc, #116]	@ (8003fc8 <Vector74+0x78>)
 8003f54:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003f58:	f013 0404 	ands.w	r4, r3, #4
 8003f5c:	d014      	beq.n	8003f88 <Vector74+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003f5e:	4b1b      	ldr	r3, [pc, #108]	@ (8003fcc <Vector74+0x7c>)
  DMA1->LIFCR = flags << 16U;
  if (dma.streams[2].func)
 8003f60:	4a1b      	ldr	r2, [pc, #108]	@ (8003fd0 <Vector74+0x80>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003f62:	6819      	ldr	r1, [r3, #0]
 8003f64:	0c09      	lsrs	r1, r1, #16
 8003f66:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA1->LIFCR = flags << 16U;
 8003f6a:	0408      	lsls	r0, r1, #16
 8003f6c:	6098      	str	r0, [r3, #8]
  if (dma.streams[2].func)
 8003f6e:	6953      	ldr	r3, [r2, #20]
 8003f70:	b10b      	cbz	r3, 8003f76 <Vector74+0x26>
    dma.streams[2].func(dma.streams[2].param, flags);
 8003f72:	6990      	ldr	r0, [r2, #24]
 8003f74:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003f76:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003f7a:	f013 0404 	ands.w	r4, r3, #4
 8003f7e:	d011      	beq.n	8003fa4 <Vector74+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003f80:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003f84:	f7fc be24 	b.w	8000bd0 <__port_irq_epilogue>
 8003f88:	2330      	movs	r3, #48	@ 0x30
 8003f8a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003f8e:	2103      	movs	r1, #3
 8003f90:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003f94:	4a0f      	ldr	r2, [pc, #60]	@ (8003fd4 <Vector74+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003f96:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003f98:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003f9a:	f7fc feb9 	bl	8000d10 <trace_next.constprop.0>
 8003f9e:	f384 8811 	msr	BASEPRI, r4
}
 8003fa2:	e7dc      	b.n	8003f5e <Vector74+0xe>
 8003fa4:	2330      	movs	r3, #48	@ 0x30
 8003fa6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003faa:	2104      	movs	r1, #4
 8003fac:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003fb0:	4a08      	ldr	r2, [pc, #32]	@ (8003fd4 <Vector74+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003fb2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003fb4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003fb6:	f7fc feab 	bl	8000d10 <trace_next.constprop.0>
 8003fba:	f384 8811 	msr	BASEPRI, r4
}
 8003fbe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003fc2:	f7fc be05 	b.w	8000bd0 <__port_irq_epilogue>
 8003fc6:	bf00      	nop
 8003fc8:	24006e20 	.word	0x24006e20
 8003fcc:	40020000 	.word	0x40020000
 8003fd0:	24006cd8 	.word	0x24006cd8
 8003fd4:	0800734c 	.word	0x0800734c
	...

08003fe0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8003fe0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003fe2:	4d1d      	ldr	r5, [pc, #116]	@ (8004058 <Vector78+0x78>)
 8003fe4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8003fe8:	f013 0404 	ands.w	r4, r3, #4
 8003fec:	d014      	beq.n	8004018 <Vector78+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003fee:	4b1b      	ldr	r3, [pc, #108]	@ (800405c <Vector78+0x7c>)
  DMA1->LIFCR = flags << 22U;
  if (dma.streams[3].func)
 8003ff0:	4a1b      	ldr	r2, [pc, #108]	@ (8004060 <Vector78+0x80>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003ff2:	6819      	ldr	r1, [r3, #0]
 8003ff4:	0d89      	lsrs	r1, r1, #22
 8003ff6:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA1->LIFCR = flags << 22U;
 8003ffa:	0588      	lsls	r0, r1, #22
 8003ffc:	6098      	str	r0, [r3, #8]
  if (dma.streams[3].func)
 8003ffe:	69d3      	ldr	r3, [r2, #28]
 8004000:	b10b      	cbz	r3, 8004006 <Vector78+0x26>
    dma.streams[3].func(dma.streams[3].param, flags);
 8004002:	6a10      	ldr	r0, [r2, #32]
 8004004:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004006:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 800400a:	f013 0404 	ands.w	r4, r3, #4
 800400e:	d011      	beq.n	8004034 <Vector78+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8004010:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004014:	f7fc bddc 	b.w	8000bd0 <__port_irq_epilogue>
 8004018:	2330      	movs	r3, #48	@ 0x30
 800401a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800401e:	2103      	movs	r1, #3
 8004020:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004024:	4a0f      	ldr	r2, [pc, #60]	@ (8004064 <Vector78+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004026:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004028:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800402a:	f7fc fe71 	bl	8000d10 <trace_next.constprop.0>
 800402e:	f384 8811 	msr	BASEPRI, r4
}
 8004032:	e7dc      	b.n	8003fee <Vector78+0xe>
 8004034:	2330      	movs	r3, #48	@ 0x30
 8004036:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800403a:	2104      	movs	r1, #4
 800403c:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004040:	4a08      	ldr	r2, [pc, #32]	@ (8004064 <Vector78+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004042:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004044:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004046:	f7fc fe63 	bl	8000d10 <trace_next.constprop.0>
 800404a:	f384 8811 	msr	BASEPRI, r4
}
 800404e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004052:	f7fc bdbd 	b.w	8000bd0 <__port_irq_epilogue>
 8004056:	bf00      	nop
 8004058:	24006e20 	.word	0x24006e20
 800405c:	40020000 	.word	0x40020000
 8004060:	24006cd8 	.word	0x24006cd8
 8004064:	08007340 	.word	0x08007340
	...

08004070 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8004070:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004072:	4d1c      	ldr	r5, [pc, #112]	@ (80040e4 <Vector7C+0x74>)
 8004074:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8004078:	f013 0404 	ands.w	r4, r3, #4
 800407c:	d012      	beq.n	80040a4 <Vector7C+0x34>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800407e:	4b1a      	ldr	r3, [pc, #104]	@ (80040e8 <Vector7C+0x78>)
  DMA1->HIFCR = flags << 0U;
  if (dma.streams[4].func)
 8004080:	481a      	ldr	r0, [pc, #104]	@ (80040ec <Vector7C+0x7c>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8004082:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[4].func)
 8004084:	6a42      	ldr	r2, [r0, #36]	@ 0x24
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8004086:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA1->HIFCR = flags << 0U;
 800408a:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
 800408c:	b10a      	cbz	r2, 8004092 <Vector7C+0x22>
    dma.streams[4].func(dma.streams[4].param, flags);
 800408e:	6a80      	ldr	r0, [r0, #40]	@ 0x28
 8004090:	4790      	blx	r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004092:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8004096:	f013 0404 	ands.w	r4, r3, #4
 800409a:	d011      	beq.n	80040c0 <Vector7C+0x50>

  OSAL_IRQ_EPILOGUE();
}
 800409c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80040a0:	f7fc bd96 	b.w	8000bd0 <__port_irq_epilogue>
 80040a4:	2330      	movs	r3, #48	@ 0x30
 80040a6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80040aa:	2103      	movs	r1, #3
 80040ac:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80040b0:	4a0f      	ldr	r2, [pc, #60]	@ (80040f0 <Vector7C+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80040b2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80040b4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80040b6:	f7fc fe2b 	bl	8000d10 <trace_next.constprop.0>
 80040ba:	f384 8811 	msr	BASEPRI, r4
}
 80040be:	e7de      	b.n	800407e <Vector7C+0xe>
 80040c0:	2330      	movs	r3, #48	@ 0x30
 80040c2:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80040c6:	2104      	movs	r1, #4
 80040c8:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80040cc:	4a08      	ldr	r2, [pc, #32]	@ (80040f0 <Vector7C+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80040ce:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80040d0:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80040d2:	f7fc fe1d 	bl	8000d10 <trace_next.constprop.0>
 80040d6:	f384 8811 	msr	BASEPRI, r4
}
 80040da:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80040de:	f7fc bd77 	b.w	8000bd0 <__port_irq_epilogue>
 80040e2:	bf00      	nop
 80040e4:	24006e20 	.word	0x24006e20
 80040e8:	40020000 	.word	0x40020000
 80040ec:	24006cd8 	.word	0x24006cd8
 80040f0:	08007334 	.word	0x08007334
	...

08004100 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8004100:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004102:	4d1d      	ldr	r5, [pc, #116]	@ (8004178 <Vector80+0x78>)
 8004104:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8004108:	f013 0404 	ands.w	r4, r3, #4
 800410c:	d014      	beq.n	8004138 <Vector80+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800410e:	4b1b      	ldr	r3, [pc, #108]	@ (800417c <Vector80+0x7c>)
  DMA1->HIFCR = flags << 6U;
  if (dma.streams[5].func)
 8004110:	4a1b      	ldr	r2, [pc, #108]	@ (8004180 <Vector80+0x80>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8004112:	6859      	ldr	r1, [r3, #4]
 8004114:	0989      	lsrs	r1, r1, #6
 8004116:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA1->HIFCR = flags << 6U;
 800411a:	0188      	lsls	r0, r1, #6
 800411c:	60d8      	str	r0, [r3, #12]
  if (dma.streams[5].func)
 800411e:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8004120:	b10b      	cbz	r3, 8004126 <Vector80+0x26>
    dma.streams[5].func(dma.streams[5].param, flags);
 8004122:	6b10      	ldr	r0, [r2, #48]	@ 0x30
 8004124:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004126:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 800412a:	f013 0404 	ands.w	r4, r3, #4
 800412e:	d011      	beq.n	8004154 <Vector80+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8004130:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004134:	f7fc bd4c 	b.w	8000bd0 <__port_irq_epilogue>
 8004138:	2330      	movs	r3, #48	@ 0x30
 800413a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800413e:	2103      	movs	r1, #3
 8004140:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004144:	4a0f      	ldr	r2, [pc, #60]	@ (8004184 <Vector80+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004146:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004148:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800414a:	f7fc fde1 	bl	8000d10 <trace_next.constprop.0>
 800414e:	f384 8811 	msr	BASEPRI, r4
}
 8004152:	e7dc      	b.n	800410e <Vector80+0xe>
 8004154:	2330      	movs	r3, #48	@ 0x30
 8004156:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800415a:	2104      	movs	r1, #4
 800415c:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004160:	4a08      	ldr	r2, [pc, #32]	@ (8004184 <Vector80+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004162:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004164:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004166:	f7fc fdd3 	bl	8000d10 <trace_next.constprop.0>
 800416a:	f384 8811 	msr	BASEPRI, r4
}
 800416e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004172:	f7fc bd2d 	b.w	8000bd0 <__port_irq_epilogue>
 8004176:	bf00      	nop
 8004178:	24006e20 	.word	0x24006e20
 800417c:	40020000 	.word	0x40020000
 8004180:	24006cd8 	.word	0x24006cd8
 8004184:	08007328 	.word	0x08007328
	...

08004190 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8004190:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004192:	4d1d      	ldr	r5, [pc, #116]	@ (8004208 <Vector84+0x78>)
 8004194:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8004198:	f013 0404 	ands.w	r4, r3, #4
 800419c:	d014      	beq.n	80041c8 <Vector84+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800419e:	4b1b      	ldr	r3, [pc, #108]	@ (800420c <Vector84+0x7c>)
  DMA1->HIFCR = flags << 16U;
  if (dma.streams[6].func)
 80041a0:	4a1b      	ldr	r2, [pc, #108]	@ (8004210 <Vector84+0x80>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80041a2:	6859      	ldr	r1, [r3, #4]
 80041a4:	0c09      	lsrs	r1, r1, #16
 80041a6:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA1->HIFCR = flags << 16U;
 80041aa:	0408      	lsls	r0, r1, #16
 80041ac:	60d8      	str	r0, [r3, #12]
  if (dma.streams[6].func)
 80041ae:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 80041b0:	b10b      	cbz	r3, 80041b6 <Vector84+0x26>
    dma.streams[6].func(dma.streams[6].param, flags);
 80041b2:	6b90      	ldr	r0, [r2, #56]	@ 0x38
 80041b4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80041b6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80041ba:	f013 0404 	ands.w	r4, r3, #4
 80041be:	d011      	beq.n	80041e4 <Vector84+0x54>

  OSAL_IRQ_EPILOGUE();
}
 80041c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80041c4:	f7fc bd04 	b.w	8000bd0 <__port_irq_epilogue>
 80041c8:	2330      	movs	r3, #48	@ 0x30
 80041ca:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80041ce:	2103      	movs	r1, #3
 80041d0:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80041d4:	4a0f      	ldr	r2, [pc, #60]	@ (8004214 <Vector84+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80041d6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80041d8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80041da:	f7fc fd99 	bl	8000d10 <trace_next.constprop.0>
 80041de:	f384 8811 	msr	BASEPRI, r4
}
 80041e2:	e7dc      	b.n	800419e <Vector84+0xe>
 80041e4:	2330      	movs	r3, #48	@ 0x30
 80041e6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80041ea:	2104      	movs	r1, #4
 80041ec:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80041f0:	4a08      	ldr	r2, [pc, #32]	@ (8004214 <Vector84+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80041f2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80041f4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80041f6:	f7fc fd8b 	bl	8000d10 <trace_next.constprop.0>
 80041fa:	f384 8811 	msr	BASEPRI, r4
}
 80041fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004202:	f7fc bce5 	b.w	8000bd0 <__port_irq_epilogue>
 8004206:	bf00      	nop
 8004208:	24006e20 	.word	0x24006e20
 800420c:	40020000 	.word	0x40020000
 8004210:	24006cd8 	.word	0x24006cd8
 8004214:	0800731c 	.word	0x0800731c
	...

08004220 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8004220:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004222:	4d1d      	ldr	r5, [pc, #116]	@ (8004298 <VectorFC+0x78>)
 8004224:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8004228:	f013 0404 	ands.w	r4, r3, #4
 800422c:	d014      	beq.n	8004258 <VectorFC+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800422e:	4b1b      	ldr	r3, [pc, #108]	@ (800429c <VectorFC+0x7c>)
  DMA1->HIFCR = flags << 22U;
  if (dma.streams[7].func)
 8004230:	4a1b      	ldr	r2, [pc, #108]	@ (80042a0 <VectorFC+0x80>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8004232:	6859      	ldr	r1, [r3, #4]
 8004234:	0d89      	lsrs	r1, r1, #22
 8004236:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA1->HIFCR = flags << 22U;
 800423a:	0588      	lsls	r0, r1, #22
 800423c:	60d8      	str	r0, [r3, #12]
  if (dma.streams[7].func)
 800423e:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
 8004240:	b10b      	cbz	r3, 8004246 <VectorFC+0x26>
    dma.streams[7].func(dma.streams[7].param, flags);
 8004242:	6c10      	ldr	r0, [r2, #64]	@ 0x40
 8004244:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004246:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 800424a:	f013 0404 	ands.w	r4, r3, #4
 800424e:	d011      	beq.n	8004274 <VectorFC+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8004250:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004254:	f7fc bcbc 	b.w	8000bd0 <__port_irq_epilogue>
 8004258:	2330      	movs	r3, #48	@ 0x30
 800425a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800425e:	2103      	movs	r1, #3
 8004260:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004264:	4a0f      	ldr	r2, [pc, #60]	@ (80042a4 <VectorFC+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004266:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004268:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800426a:	f7fc fd51 	bl	8000d10 <trace_next.constprop.0>
 800426e:	f384 8811 	msr	BASEPRI, r4
}
 8004272:	e7dc      	b.n	800422e <VectorFC+0xe>
 8004274:	2330      	movs	r3, #48	@ 0x30
 8004276:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800427a:	2104      	movs	r1, #4
 800427c:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004280:	4a08      	ldr	r2, [pc, #32]	@ (80042a4 <VectorFC+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004282:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004284:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004286:	f7fc fd43 	bl	8000d10 <trace_next.constprop.0>
 800428a:	f384 8811 	msr	BASEPRI, r4
}
 800428e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004292:	f7fc bc9d 	b.w	8000bd0 <__port_irq_epilogue>
 8004296:	bf00      	nop
 8004298:	24006e20 	.word	0x24006e20
 800429c:	40020000 	.word	0x40020000
 80042a0:	24006cd8 	.word	0x24006cd8
 80042a4:	08007310 	.word	0x08007310
	...

080042b0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 80042b0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80042b2:	4d1c      	ldr	r5, [pc, #112]	@ (8004324 <Vector120+0x74>)
 80042b4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80042b8:	f013 0404 	ands.w	r4, r3, #4
 80042bc:	d012      	beq.n	80042e4 <Vector120+0x34>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80042be:	4b1a      	ldr	r3, [pc, #104]	@ (8004328 <Vector120+0x78>)
  DMA2->LIFCR = flags << 0U;
  if (dma.streams[8].func)
 80042c0:	481a      	ldr	r0, [pc, #104]	@ (800432c <Vector120+0x7c>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80042c2:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[8].func)
 80042c4:	6c42      	ldr	r2, [r0, #68]	@ 0x44
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80042c6:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA2->LIFCR = flags << 0U;
 80042ca:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
 80042cc:	b10a      	cbz	r2, 80042d2 <Vector120+0x22>
    dma.streams[8].func(dma.streams[8].param, flags);
 80042ce:	6c80      	ldr	r0, [r0, #72]	@ 0x48
 80042d0:	4790      	blx	r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80042d2:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80042d6:	f013 0404 	ands.w	r4, r3, #4
 80042da:	d011      	beq.n	8004300 <Vector120+0x50>

  OSAL_IRQ_EPILOGUE();
}
 80042dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80042e0:	f7fc bc76 	b.w	8000bd0 <__port_irq_epilogue>
 80042e4:	2330      	movs	r3, #48	@ 0x30
 80042e6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80042ea:	2103      	movs	r1, #3
 80042ec:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80042f0:	4a0f      	ldr	r2, [pc, #60]	@ (8004330 <Vector120+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80042f2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80042f4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80042f6:	f7fc fd0b 	bl	8000d10 <trace_next.constprop.0>
 80042fa:	f384 8811 	msr	BASEPRI, r4
}
 80042fe:	e7de      	b.n	80042be <Vector120+0xe>
 8004300:	2330      	movs	r3, #48	@ 0x30
 8004302:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004306:	2104      	movs	r1, #4
 8004308:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800430c:	4a08      	ldr	r2, [pc, #32]	@ (8004330 <Vector120+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800430e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004310:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004312:	f7fc fcfd 	bl	8000d10 <trace_next.constprop.0>
 8004316:	f384 8811 	msr	BASEPRI, r4
}
 800431a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800431e:	f7fc bc57 	b.w	8000bd0 <__port_irq_epilogue>
 8004322:	bf00      	nop
 8004324:	24006e20 	.word	0x24006e20
 8004328:	40020400 	.word	0x40020400
 800432c:	24006cd8 	.word	0x24006cd8
 8004330:	08007304 	.word	0x08007304
	...

08004340 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8004340:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004342:	4d1d      	ldr	r5, [pc, #116]	@ (80043b8 <Vector124+0x78>)
 8004344:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8004348:	f013 0404 	ands.w	r4, r3, #4
 800434c:	d014      	beq.n	8004378 <Vector124+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800434e:	4b1b      	ldr	r3, [pc, #108]	@ (80043bc <Vector124+0x7c>)
  DMA2->LIFCR = flags << 6U;
  if (dma.streams[9].func)
 8004350:	4a1b      	ldr	r2, [pc, #108]	@ (80043c0 <Vector124+0x80>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8004352:	6819      	ldr	r1, [r3, #0]
 8004354:	0989      	lsrs	r1, r1, #6
 8004356:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA2->LIFCR = flags << 6U;
 800435a:	0188      	lsls	r0, r1, #6
 800435c:	6098      	str	r0, [r3, #8]
  if (dma.streams[9].func)
 800435e:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
 8004360:	b10b      	cbz	r3, 8004366 <Vector124+0x26>
    dma.streams[9].func(dma.streams[9].param, flags);
 8004362:	6d10      	ldr	r0, [r2, #80]	@ 0x50
 8004364:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004366:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 800436a:	f013 0404 	ands.w	r4, r3, #4
 800436e:	d011      	beq.n	8004394 <Vector124+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8004370:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004374:	f7fc bc2c 	b.w	8000bd0 <__port_irq_epilogue>
 8004378:	2330      	movs	r3, #48	@ 0x30
 800437a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800437e:	2103      	movs	r1, #3
 8004380:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004384:	4a0f      	ldr	r2, [pc, #60]	@ (80043c4 <Vector124+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004386:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004388:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800438a:	f7fc fcc1 	bl	8000d10 <trace_next.constprop.0>
 800438e:	f384 8811 	msr	BASEPRI, r4
}
 8004392:	e7dc      	b.n	800434e <Vector124+0xe>
 8004394:	2330      	movs	r3, #48	@ 0x30
 8004396:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800439a:	2104      	movs	r1, #4
 800439c:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80043a0:	4a08      	ldr	r2, [pc, #32]	@ (80043c4 <Vector124+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80043a2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80043a4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80043a6:	f7fc fcb3 	bl	8000d10 <trace_next.constprop.0>
 80043aa:	f384 8811 	msr	BASEPRI, r4
}
 80043ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80043b2:	f7fc bc0d 	b.w	8000bd0 <__port_irq_epilogue>
 80043b6:	bf00      	nop
 80043b8:	24006e20 	.word	0x24006e20
 80043bc:	40020400 	.word	0x40020400
 80043c0:	24006cd8 	.word	0x24006cd8
 80043c4:	080072f8 	.word	0x080072f8
	...

080043d0 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 80043d0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80043d2:	4d1d      	ldr	r5, [pc, #116]	@ (8004448 <Vector128+0x78>)
 80043d4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80043d8:	f013 0404 	ands.w	r4, r3, #4
 80043dc:	d014      	beq.n	8004408 <Vector128+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80043de:	4b1b      	ldr	r3, [pc, #108]	@ (800444c <Vector128+0x7c>)
  DMA2->LIFCR = flags << 16U;
  if (dma.streams[10].func)
 80043e0:	4a1b      	ldr	r2, [pc, #108]	@ (8004450 <Vector128+0x80>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80043e2:	6819      	ldr	r1, [r3, #0]
 80043e4:	0c09      	lsrs	r1, r1, #16
 80043e6:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA2->LIFCR = flags << 16U;
 80043ea:	0408      	lsls	r0, r1, #16
 80043ec:	6098      	str	r0, [r3, #8]
  if (dma.streams[10].func)
 80043ee:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 80043f0:	b10b      	cbz	r3, 80043f6 <Vector128+0x26>
    dma.streams[10].func(dma.streams[10].param, flags);
 80043f2:	6d90      	ldr	r0, [r2, #88]	@ 0x58
 80043f4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80043f6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80043fa:	f013 0404 	ands.w	r4, r3, #4
 80043fe:	d011      	beq.n	8004424 <Vector128+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8004400:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004404:	f7fc bbe4 	b.w	8000bd0 <__port_irq_epilogue>
 8004408:	2330      	movs	r3, #48	@ 0x30
 800440a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800440e:	2103      	movs	r1, #3
 8004410:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004414:	4a0f      	ldr	r2, [pc, #60]	@ (8004454 <Vector128+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004416:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004418:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800441a:	f7fc fc79 	bl	8000d10 <trace_next.constprop.0>
 800441e:	f384 8811 	msr	BASEPRI, r4
}
 8004422:	e7dc      	b.n	80043de <Vector128+0xe>
 8004424:	2330      	movs	r3, #48	@ 0x30
 8004426:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800442a:	2104      	movs	r1, #4
 800442c:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004430:	4a08      	ldr	r2, [pc, #32]	@ (8004454 <Vector128+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004432:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004434:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004436:	f7fc fc6b 	bl	8000d10 <trace_next.constprop.0>
 800443a:	f384 8811 	msr	BASEPRI, r4
}
 800443e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004442:	f7fc bbc5 	b.w	8000bd0 <__port_irq_epilogue>
 8004446:	bf00      	nop
 8004448:	24006e20 	.word	0x24006e20
 800444c:	40020400 	.word	0x40020400
 8004450:	24006cd8 	.word	0x24006cd8
 8004454:	080072ec 	.word	0x080072ec
	...

08004460 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8004460:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004462:	4d1d      	ldr	r5, [pc, #116]	@ (80044d8 <Vector12C+0x78>)
 8004464:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8004468:	f013 0404 	ands.w	r4, r3, #4
 800446c:	d014      	beq.n	8004498 <Vector12C+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800446e:	4b1b      	ldr	r3, [pc, #108]	@ (80044dc <Vector12C+0x7c>)
  DMA2->LIFCR = flags << 22U;
  if (dma.streams[11].func)
 8004470:	4a1b      	ldr	r2, [pc, #108]	@ (80044e0 <Vector12C+0x80>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8004472:	6819      	ldr	r1, [r3, #0]
 8004474:	0d89      	lsrs	r1, r1, #22
 8004476:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA2->LIFCR = flags << 22U;
 800447a:	0588      	lsls	r0, r1, #22
 800447c:	6098      	str	r0, [r3, #8]
  if (dma.streams[11].func)
 800447e:	6dd3      	ldr	r3, [r2, #92]	@ 0x5c
 8004480:	b10b      	cbz	r3, 8004486 <Vector12C+0x26>
    dma.streams[11].func(dma.streams[11].param, flags);
 8004482:	6e10      	ldr	r0, [r2, #96]	@ 0x60
 8004484:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004486:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 800448a:	f013 0404 	ands.w	r4, r3, #4
 800448e:	d011      	beq.n	80044b4 <Vector12C+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8004490:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004494:	f7fc bb9c 	b.w	8000bd0 <__port_irq_epilogue>
 8004498:	2330      	movs	r3, #48	@ 0x30
 800449a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800449e:	2103      	movs	r1, #3
 80044a0:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80044a4:	4a0f      	ldr	r2, [pc, #60]	@ (80044e4 <Vector12C+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80044a6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80044a8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80044aa:	f7fc fc31 	bl	8000d10 <trace_next.constprop.0>
 80044ae:	f384 8811 	msr	BASEPRI, r4
}
 80044b2:	e7dc      	b.n	800446e <Vector12C+0xe>
 80044b4:	2330      	movs	r3, #48	@ 0x30
 80044b6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80044ba:	2104      	movs	r1, #4
 80044bc:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80044c0:	4a08      	ldr	r2, [pc, #32]	@ (80044e4 <Vector12C+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80044c2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80044c4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80044c6:	f7fc fc23 	bl	8000d10 <trace_next.constprop.0>
 80044ca:	f384 8811 	msr	BASEPRI, r4
}
 80044ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80044d2:	f7fc bb7d 	b.w	8000bd0 <__port_irq_epilogue>
 80044d6:	bf00      	nop
 80044d8:	24006e20 	.word	0x24006e20
 80044dc:	40020400 	.word	0x40020400
 80044e0:	24006cd8 	.word	0x24006cd8
 80044e4:	080072e0 	.word	0x080072e0
	...

080044f0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 80044f0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80044f2:	4d1c      	ldr	r5, [pc, #112]	@ (8004564 <Vector130+0x74>)
 80044f4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80044f8:	f013 0404 	ands.w	r4, r3, #4
 80044fc:	d012      	beq.n	8004524 <Vector130+0x34>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80044fe:	4b1a      	ldr	r3, [pc, #104]	@ (8004568 <Vector130+0x78>)
  DMA2->HIFCR = flags << 0U;
  if (dma.streams[12].func)
 8004500:	481a      	ldr	r0, [pc, #104]	@ (800456c <Vector130+0x7c>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8004502:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[12].func)
 8004504:	6e42      	ldr	r2, [r0, #100]	@ 0x64
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8004506:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA2->HIFCR = flags << 0U;
 800450a:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
 800450c:	b10a      	cbz	r2, 8004512 <Vector130+0x22>
    dma.streams[12].func(dma.streams[12].param, flags);
 800450e:	6e80      	ldr	r0, [r0, #104]	@ 0x68
 8004510:	4790      	blx	r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004512:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8004516:	f013 0404 	ands.w	r4, r3, #4
 800451a:	d011      	beq.n	8004540 <Vector130+0x50>

  OSAL_IRQ_EPILOGUE();
}
 800451c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004520:	f7fc bb56 	b.w	8000bd0 <__port_irq_epilogue>
 8004524:	2330      	movs	r3, #48	@ 0x30
 8004526:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800452a:	2103      	movs	r1, #3
 800452c:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004530:	4a0f      	ldr	r2, [pc, #60]	@ (8004570 <Vector130+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004532:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004534:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004536:	f7fc fbeb 	bl	8000d10 <trace_next.constprop.0>
 800453a:	f384 8811 	msr	BASEPRI, r4
}
 800453e:	e7de      	b.n	80044fe <Vector130+0xe>
 8004540:	2330      	movs	r3, #48	@ 0x30
 8004542:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004546:	2104      	movs	r1, #4
 8004548:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800454c:	4a08      	ldr	r2, [pc, #32]	@ (8004570 <Vector130+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800454e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004550:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004552:	f7fc fbdd 	bl	8000d10 <trace_next.constprop.0>
 8004556:	f384 8811 	msr	BASEPRI, r4
}
 800455a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800455e:	f7fc bb37 	b.w	8000bd0 <__port_irq_epilogue>
 8004562:	bf00      	nop
 8004564:	24006e20 	.word	0x24006e20
 8004568:	40020400 	.word	0x40020400
 800456c:	24006cd8 	.word	0x24006cd8
 8004570:	080072d4 	.word	0x080072d4
	...

08004580 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8004580:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004582:	4d1d      	ldr	r5, [pc, #116]	@ (80045f8 <Vector150+0x78>)
 8004584:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8004588:	f013 0404 	ands.w	r4, r3, #4
 800458c:	d014      	beq.n	80045b8 <Vector150+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800458e:	4b1b      	ldr	r3, [pc, #108]	@ (80045fc <Vector150+0x7c>)
  DMA2->HIFCR = flags << 6U;
  if (dma.streams[13].func)
 8004590:	4a1b      	ldr	r2, [pc, #108]	@ (8004600 <Vector150+0x80>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8004592:	6859      	ldr	r1, [r3, #4]
 8004594:	0989      	lsrs	r1, r1, #6
 8004596:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA2->HIFCR = flags << 6U;
 800459a:	0188      	lsls	r0, r1, #6
 800459c:	60d8      	str	r0, [r3, #12]
  if (dma.streams[13].func)
 800459e:	6ed3      	ldr	r3, [r2, #108]	@ 0x6c
 80045a0:	b10b      	cbz	r3, 80045a6 <Vector150+0x26>
    dma.streams[13].func(dma.streams[13].param, flags);
 80045a2:	6f10      	ldr	r0, [r2, #112]	@ 0x70
 80045a4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80045a6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80045aa:	f013 0404 	ands.w	r4, r3, #4
 80045ae:	d011      	beq.n	80045d4 <Vector150+0x54>

  OSAL_IRQ_EPILOGUE();
}
 80045b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80045b4:	f7fc bb0c 	b.w	8000bd0 <__port_irq_epilogue>
 80045b8:	2330      	movs	r3, #48	@ 0x30
 80045ba:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80045be:	2103      	movs	r1, #3
 80045c0:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80045c4:	4a0f      	ldr	r2, [pc, #60]	@ (8004604 <Vector150+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80045c6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80045c8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80045ca:	f7fc fba1 	bl	8000d10 <trace_next.constprop.0>
 80045ce:	f384 8811 	msr	BASEPRI, r4
}
 80045d2:	e7dc      	b.n	800458e <Vector150+0xe>
 80045d4:	2330      	movs	r3, #48	@ 0x30
 80045d6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80045da:	2104      	movs	r1, #4
 80045dc:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80045e0:	4a08      	ldr	r2, [pc, #32]	@ (8004604 <Vector150+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80045e2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80045e4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80045e6:	f7fc fb93 	bl	8000d10 <trace_next.constprop.0>
 80045ea:	f384 8811 	msr	BASEPRI, r4
}
 80045ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80045f2:	f7fc baed 	b.w	8000bd0 <__port_irq_epilogue>
 80045f6:	bf00      	nop
 80045f8:	24006e20 	.word	0x24006e20
 80045fc:	40020400 	.word	0x40020400
 8004600:	24006cd8 	.word	0x24006cd8
 8004604:	080072c8 	.word	0x080072c8
	...

08004610 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8004610:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004612:	4d1d      	ldr	r5, [pc, #116]	@ (8004688 <Vector154+0x78>)
 8004614:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 8004618:	f013 0404 	ands.w	r4, r3, #4
 800461c:	d014      	beq.n	8004648 <Vector154+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800461e:	4b1b      	ldr	r3, [pc, #108]	@ (800468c <Vector154+0x7c>)
  DMA2->HIFCR = flags << 16U;
  if (dma.streams[14].func)
 8004620:	4a1b      	ldr	r2, [pc, #108]	@ (8004690 <Vector154+0x80>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8004622:	6859      	ldr	r1, [r3, #4]
 8004624:	0c09      	lsrs	r1, r1, #16
 8004626:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA2->HIFCR = flags << 16U;
 800462a:	0408      	lsls	r0, r1, #16
 800462c:	60d8      	str	r0, [r3, #12]
  if (dma.streams[14].func)
 800462e:	6f53      	ldr	r3, [r2, #116]	@ 0x74
 8004630:	b10b      	cbz	r3, 8004636 <Vector154+0x26>
    dma.streams[14].func(dma.streams[14].param, flags);
 8004632:	6f90      	ldr	r0, [r2, #120]	@ 0x78
 8004634:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004636:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 800463a:	f013 0404 	ands.w	r4, r3, #4
 800463e:	d011      	beq.n	8004664 <Vector154+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8004640:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004644:	f7fc bac4 	b.w	8000bd0 <__port_irq_epilogue>
 8004648:	2330      	movs	r3, #48	@ 0x30
 800464a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800464e:	2103      	movs	r1, #3
 8004650:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004654:	4a0f      	ldr	r2, [pc, #60]	@ (8004694 <Vector154+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004656:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004658:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800465a:	f7fc fb59 	bl	8000d10 <trace_next.constprop.0>
 800465e:	f384 8811 	msr	BASEPRI, r4
}
 8004662:	e7dc      	b.n	800461e <Vector154+0xe>
 8004664:	2330      	movs	r3, #48	@ 0x30
 8004666:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800466a:	2104      	movs	r1, #4
 800466c:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004670:	4a08      	ldr	r2, [pc, #32]	@ (8004694 <Vector154+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004672:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004674:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004676:	f7fc fb4b 	bl	8000d10 <trace_next.constprop.0>
 800467a:	f384 8811 	msr	BASEPRI, r4
}
 800467e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004682:	f7fc baa5 	b.w	8000bd0 <__port_irq_epilogue>
 8004686:	bf00      	nop
 8004688:	24006e20 	.word	0x24006e20
 800468c:	40020400 	.word	0x40020400
 8004690:	24006cd8 	.word	0x24006cd8
 8004694:	080072bc 	.word	0x080072bc
	...

080046a0 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 80046a0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80046a2:	4d1d      	ldr	r5, [pc, #116]	@ (8004718 <Vector158+0x78>)
 80046a4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80046a8:	f013 0404 	ands.w	r4, r3, #4
 80046ac:	d015      	beq.n	80046da <Vector158+0x3a>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80046ae:	4b1b      	ldr	r3, [pc, #108]	@ (800471c <Vector158+0x7c>)
  DMA2->HIFCR = flags << 22U;
  if (dma.streams[15].func)
 80046b0:	4a1b      	ldr	r2, [pc, #108]	@ (8004720 <Vector158+0x80>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80046b2:	6859      	ldr	r1, [r3, #4]
 80046b4:	0d89      	lsrs	r1, r1, #22
 80046b6:	f001 013d 	and.w	r1, r1, #61	@ 0x3d
  DMA2->HIFCR = flags << 22U;
 80046ba:	0588      	lsls	r0, r1, #22
 80046bc:	60d8      	str	r0, [r3, #12]
  if (dma.streams[15].func)
 80046be:	6fd3      	ldr	r3, [r2, #124]	@ 0x7c
 80046c0:	b113      	cbz	r3, 80046c8 <Vector158+0x28>
    dma.streams[15].func(dma.streams[15].param, flags);
 80046c2:	f8d2 0080 	ldr.w	r0, [r2, #128]	@ 0x80
 80046c6:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80046c8:	f8b5 3088 	ldrh.w	r3, [r5, #136]	@ 0x88
 80046cc:	f013 0404 	ands.w	r4, r3, #4
 80046d0:	d011      	beq.n	80046f6 <Vector158+0x56>

  OSAL_IRQ_EPILOGUE();
}
 80046d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80046d6:	f7fc ba7b 	b.w	8000bd0 <__port_irq_epilogue>
 80046da:	2330      	movs	r3, #48	@ 0x30
 80046dc:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80046e0:	2103      	movs	r1, #3
 80046e2:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80046e6:	4a0f      	ldr	r2, [pc, #60]	@ (8004724 <Vector158+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80046e8:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80046ea:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80046ec:	f7fc fb10 	bl	8000d10 <trace_next.constprop.0>
 80046f0:	f384 8811 	msr	BASEPRI, r4
}
 80046f4:	e7db      	b.n	80046ae <Vector158+0xe>
 80046f6:	2330      	movs	r3, #48	@ 0x30
 80046f8:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80046fc:	2104      	movs	r1, #4
 80046fe:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004702:	4a08      	ldr	r2, [pc, #32]	@ (8004724 <Vector158+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004704:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004706:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004708:	f7fc fb02 	bl	8000d10 <trace_next.constprop.0>
 800470c:	f384 8811 	msr	BASEPRI, r4
}
 8004710:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8004714:	f7fc ba5c 	b.w	8000bd0 <__port_irq_epilogue>
 8004718:	24006e20 	.word	0x24006e20
 800471c:	40020400 	.word	0x40020400
 8004720:	24006cd8 	.word	0x24006cd8
 8004724:	080072b0 	.word	0x080072b0
	...

08004730 <Vector174>:
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 8004730:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004734:	f8df 8274 	ldr.w	r8, [pc, #628]	@ 80049ac <Vector174+0x27c>
 8004738:	f8b8 3088 	ldrh.w	r3, [r8, #136]	@ 0x88
 800473c:	f013 0404 	ands.w	r4, r3, #4
 8004740:	f000 80e6 	beq.w	8004910 <Vector174+0x1e0>
  stm32_otg_t *otgp = usbp->otg;
 8004744:	4e9a      	ldr	r6, [pc, #616]	@ (80049b0 <Vector174+0x280>)
 8004746:	f8d6 4090 	ldr.w	r4, [r6, #144]	@ 0x90
  sts  = otgp->GINTSTS;
 800474a:	6967      	ldr	r7, [r4, #20]
  sts &= otgp->GINTMSK;
 800474c:	69a3      	ldr	r3, [r4, #24]
 800474e:	401f      	ands	r7, r3
  if (sts & GINTSTS_USBRST) {
 8004750:	f417 5980 	ands.w	r9, r7, #4096	@ 0x1000
  otgp->GINTSTS = sts;
 8004754:	6167      	str	r7, [r4, #20]
  if (sts & GINTSTS_USBRST) {
 8004756:	f040 8156 	bne.w	8004a06 <Vector174+0x2d6>
  if (sts & GINTSTS_WKUPINT) {
 800475a:	2f00      	cmp	r7, #0
 800475c:	f2c0 80ad 	blt.w	80048ba <Vector174+0x18a>
  if (sts & GINTSTS_USBSUSP) {
 8004760:	053b      	lsls	r3, r7, #20
 8004762:	f100 80c3 	bmi.w	80048ec <Vector174+0x1bc>
  if (sts & GINTSTS_ENUMDNE) {
 8004766:	04bd      	lsls	r5, r7, #18
 8004768:	d50c      	bpl.n	8004784 <Vector174+0x54>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 800476a:	f8d4 3808 	ldr.w	r3, [r4, #2056]	@ 0x808
 800476e:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8004772:	68e3      	ldr	r3, [r4, #12]
 8004774:	f423 5370 	bic.w	r3, r3, #15360	@ 0x3c00
 8004778:	bf0c      	ite	eq
 800477a:	f443 5310 	orreq.w	r3, r3, #9216	@ 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 800477e:	f443 53a0 	orrne.w	r3, r3, #5120	@ 0x1400
 8004782:	60e3      	str	r3, [r4, #12]
  if (sts & GINTSTS_SOF) {
 8004784:	0738      	lsls	r0, r7, #28
 8004786:	d44d      	bmi.n	8004824 <Vector174+0xf4>
  if (sts & GINTSTS_IISOIXFR) {
 8004788:	02f9      	lsls	r1, r7, #11
 800478a:	d453      	bmi.n	8004834 <Vector174+0x104>
  if (sts & GINTSTS_IISOOXFR) {
 800478c:	02ba      	lsls	r2, r7, #10
 800478e:	f100 8107 	bmi.w	80049a0 <Vector174+0x270>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 8004792:	06fd      	lsls	r5, r7, #27
 8004794:	f100 80db 	bmi.w	800494e <Vector174+0x21e>
  if (sts & GINTSTS_OEPINT) {
 8004798:	033b      	lsls	r3, r7, #12
  src = otgp->DAINT;
 800479a:	f8d4 4818 	ldr.w	r4, [r4, #2072]	@ 0x818
  if (sts & GINTSTS_OEPINT) {
 800479e:	d51a      	bpl.n	80047d6 <Vector174+0xa6>
    if (src & (1 << 16))
 80047a0:	03e6      	lsls	r6, r4, #15
 80047a2:	f100 81e3 	bmi.w	8004b6c <Vector174+0x43c>
    if (src & (1 << 17))
 80047a6:	03a5      	lsls	r5, r4, #14
 80047a8:	f100 81e6 	bmi.w	8004b78 <Vector174+0x448>
    if (src & (1 << 18))
 80047ac:	0360      	lsls	r0, r4, #13
 80047ae:	f100 81e9 	bmi.w	8004b84 <Vector174+0x454>
    if (src & (1 << 19))
 80047b2:	0321      	lsls	r1, r4, #12
 80047b4:	f100 81ec 	bmi.w	8004b90 <Vector174+0x460>
    if (src & (1 << 20))
 80047b8:	02e2      	lsls	r2, r4, #11
 80047ba:	f100 81ef 	bmi.w	8004b9c <Vector174+0x46c>
    if (src & (1 << 21))
 80047be:	02a3      	lsls	r3, r4, #10
 80047c0:	f100 81f2 	bmi.w	8004ba8 <Vector174+0x478>
    if (src & (1 << 22))
 80047c4:	0266      	lsls	r6, r4, #9
 80047c6:	f100 81f5 	bmi.w	8004bb4 <Vector174+0x484>
    if (src & (1 << 23))
 80047ca:	0225      	lsls	r5, r4, #8
 80047cc:	f100 81ca 	bmi.w	8004b64 <Vector174+0x434>
    if (src & (1 << 24))
 80047d0:	01e0      	lsls	r0, r4, #7
 80047d2:	f100 8192 	bmi.w	8004afa <Vector174+0x3ca>
  if (sts & GINTSTS_IEPINT) {
 80047d6:	0379      	lsls	r1, r7, #13
 80047d8:	d51a      	bpl.n	8004810 <Vector174+0xe0>
    if (src & (1 << 0))
 80047da:	07e2      	lsls	r2, r4, #31
 80047dc:	f100 820a 	bmi.w	8004bf4 <Vector174+0x4c4>
    if (src & (1 << 1))
 80047e0:	07a3      	lsls	r3, r4, #30
 80047e2:	f100 8203 	bmi.w	8004bec <Vector174+0x4bc>
    if (src & (1 << 2))
 80047e6:	0767      	lsls	r7, r4, #29
 80047e8:	f100 81fc 	bmi.w	8004be4 <Vector174+0x4b4>
    if (src & (1 << 3))
 80047ec:	0726      	lsls	r6, r4, #28
 80047ee:	f100 81f5 	bmi.w	8004bdc <Vector174+0x4ac>
    if (src & (1 << 4))
 80047f2:	06e5      	lsls	r5, r4, #27
 80047f4:	f100 81ee 	bmi.w	8004bd4 <Vector174+0x4a4>
    if (src & (1 << 5))
 80047f8:	06a0      	lsls	r0, r4, #26
 80047fa:	f100 81e7 	bmi.w	8004bcc <Vector174+0x49c>
    if (src & (1 << 6))
 80047fe:	0661      	lsls	r1, r4, #25
 8004800:	f100 81e0 	bmi.w	8004bc4 <Vector174+0x494>
    if (src & (1 << 7))
 8004804:	0622      	lsls	r2, r4, #24
 8004806:	f100 81d9 	bmi.w	8004bbc <Vector174+0x48c>
    if (src & (1 << 8))
 800480a:	05e3      	lsls	r3, r4, #23
 800480c:	f100 817c 	bmi.w	8004b08 <Vector174+0x3d8>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004810:	f8b8 3088 	ldrh.w	r3, [r8, #136]	@ 0x88
 8004814:	f013 0404 	ands.w	r4, r3, #4
 8004818:	f000 8088 	beq.w	800492c <Vector174+0x1fc>
}
 800481c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8004820:	f7fc b9d6 	b.w	8000bd0 <__port_irq_epilogue>
    _usb_isr_invoke_sof_cb(usbp);
 8004824:	6873      	ldr	r3, [r6, #4]
 8004826:	68db      	ldr	r3, [r3, #12]
 8004828:	2b00      	cmp	r3, #0
 800482a:	d0ad      	beq.n	8004788 <Vector174+0x58>
 800482c:	4860      	ldr	r0, [pc, #384]	@ (80049b0 <Vector174+0x280>)
 800482e:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
 8004830:	02f9      	lsls	r1, r7, #11
 8004832:	d5ab      	bpl.n	800478c <Vector174+0x5c>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8004834:	2100      	movs	r1, #0
  stm32_otg_t *otgp = usbp->otg;
 8004836:	f8d6 a090 	ldr.w	sl, [r6, #144]	@ 0x90
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800483a:	460d      	mov	r5, r1
 800483c:	e007      	b.n	800484e <Vector174+0x11e>
 800483e:	3501      	adds	r5, #1
 8004840:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
 8004844:	b2ed      	uxtb	r5, r5
 8004846:	689b      	ldr	r3, [r3, #8]
 8004848:	429d      	cmp	r5, r3
 800484a:	4629      	mov	r1, r5
 800484c:	d89e      	bhi.n	800478c <Vector174+0x5c>
 800484e:	eb0a 1245 	add.w	r2, sl, r5, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8004852:	f8d2 3900 	ldr.w	r3, [r2, #2304]	@ 0x900
 8004856:	f403 2340 	and.w	r3, r3, #786432	@ 0xc0000
 800485a:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800485e:	d1ee      	bne.n	800483e <Vector174+0x10e>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8004860:	f8d2 3900 	ldr.w	r3, [r2, #2304]	@ 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8004864:	2b00      	cmp	r3, #0
 8004866:	daea      	bge.n	800483e <Vector174+0x10e>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8004868:	f8d2 3900 	ldr.w	r3, [r2, #2304]	@ 0x900
 800486c:	f043 4390 	orr.w	r3, r3, #1207959552	@ 0x48000000
 8004870:	f8c2 3900 	str.w	r3, [r2, #2304]	@ 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8004874:	f8d2 3900 	ldr.w	r3, [r2, #2304]	@ 0x900
 8004878:	2b00      	cmp	r3, #0
 800487a:	dbfb      	blt.n	8004874 <Vector174+0x144>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800487c:	0189      	lsls	r1, r1, #6
 800487e:	f8d6 2090 	ldr.w	r2, [r6, #144]	@ 0x90
 8004882:	f041 0120 	orr.w	r1, r1, #32
 8004886:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8004888:	6913      	ldr	r3, [r2, #16]
 800488a:	069b      	lsls	r3, r3, #26
 800488c:	d4fc      	bmi.n	8004888 <Vector174+0x158>
 800488e:	4a49      	ldr	r2, [pc, #292]	@ (80049b4 <Vector174+0x284>)
 8004890:	6851      	ldr	r1, [r2, #4]
 8004892:	6853      	ldr	r3, [r2, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8004894:	1a5b      	subs	r3, r3, r1
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8004896:	2b11      	cmp	r3, #17
 8004898:	d9fb      	bls.n	8004892 <Vector174+0x162>
      _usb_isr_invoke_in_cb(usbp, ep);
 800489a:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 800489e:	2101      	movs	r1, #1
 80048a0:	68db      	ldr	r3, [r3, #12]
 80048a2:	40a9      	lsls	r1, r5
 80048a4:	689a      	ldr	r2, [r3, #8]
 80048a6:	8933      	ldrh	r3, [r6, #8]
 80048a8:	ea23 0301 	bic.w	r3, r3, r1
 80048ac:	8133      	strh	r3, [r6, #8]
 80048ae:	2a00      	cmp	r2, #0
 80048b0:	d0c5      	beq.n	800483e <Vector174+0x10e>
 80048b2:	4629      	mov	r1, r5
 80048b4:	483e      	ldr	r0, [pc, #248]	@ (80049b0 <Vector174+0x280>)
 80048b6:	4790      	blx	r2
 80048b8:	e7c1      	b.n	800483e <Vector174+0x10e>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 80048ba:	f8d4 3e00 	ldr.w	r3, [r4, #3584]	@ 0xe00
 80048be:	079a      	lsls	r2, r3, #30
 80048c0:	f040 8114 	bne.w	8004aec <Vector174+0x3bc>
    otgp->DCTL &= ~DCTL_RWUSIG;
 80048c4:	f8d4 3804 	ldr.w	r3, [r4, #2052]	@ 0x804
 80048c8:	f023 0301 	bic.w	r3, r3, #1
 80048cc:	f8c4 3804 	str.w	r3, [r4, #2052]	@ 0x804
  usbp->state = usbp->saved_state;
 80048d0:	f896 308c 	ldrb.w	r3, [r6, #140]	@ 0x8c
 80048d4:	7033      	strb	r3, [r6, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80048d6:	6873      	ldr	r3, [r6, #4]
 80048d8:	681b      	ldr	r3, [r3, #0]
 80048da:	2b00      	cmp	r3, #0
 80048dc:	f43f af40 	beq.w	8004760 <Vector174+0x30>
 80048e0:	2105      	movs	r1, #5
 80048e2:	4833      	ldr	r0, [pc, #204]	@ (80049b0 <Vector174+0x280>)
 80048e4:	4798      	blx	r3
  if (sts & GINTSTS_USBSUSP) {
 80048e6:	053b      	lsls	r3, r7, #20
 80048e8:	f57f af3d 	bpl.w	8004766 <Vector174+0x36>
    otg_disable_ep(usbp);
 80048ec:	e9d6 0124 	ldrd	r0, r1, [r6, #144]	@ 0x90
 80048f0:	f7fc fa5e 	bl	8000db0 <otg_disable_ep.isra.0>
  usbp->saved_state = usbp->state;
 80048f4:	7833      	ldrb	r3, [r6, #0]
  usbp->state       = USB_SUSPENDED;
 80048f6:	2205      	movs	r2, #5
  usbp->saved_state = usbp->state;
 80048f8:	f886 308c 	strb.w	r3, [r6, #140]	@ 0x8c
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80048fc:	6873      	ldr	r3, [r6, #4]
  usbp->state       = USB_SUSPENDED;
 80048fe:	7032      	strb	r2, [r6, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8004900:	681b      	ldr	r3, [r3, #0]
 8004902:	b113      	cbz	r3, 800490a <Vector174+0x1da>
 8004904:	2104      	movs	r1, #4
 8004906:	482a      	ldr	r0, [pc, #168]	@ (80049b0 <Vector174+0x280>)
 8004908:	4798      	blx	r3
  usbp->transmitting  = 0;
 800490a:	2300      	movs	r3, #0
 800490c:	60b3      	str	r3, [r6, #8]
}
 800490e:	e72a      	b.n	8004766 <Vector174+0x36>
 8004910:	2330      	movs	r3, #48	@ 0x30
 8004912:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004916:	2103      	movs	r1, #3
 8004918:	f8d8 308c 	ldr.w	r3, [r8, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800491c:	4a26      	ldr	r2, [pc, #152]	@ (80049b8 <Vector174+0x288>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800491e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004920:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004922:	f7fc f9f5 	bl	8000d10 <trace_next.constprop.0>
 8004926:	f384 8811 	msr	BASEPRI, r4
}
 800492a:	e70b      	b.n	8004744 <Vector174+0x14>
 800492c:	2330      	movs	r3, #48	@ 0x30
 800492e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004932:	2104      	movs	r1, #4
 8004934:	f8d8 308c 	ldr.w	r3, [r8, #140]	@ 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004938:	4a1f      	ldr	r2, [pc, #124]	@ (80049b8 <Vector174+0x288>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800493a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800493c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800493e:	f7fc f9e7 	bl	8000d10 <trace_next.constprop.0>
 8004942:	f384 8811 	msr	BASEPRI, r4
}
 8004946:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 800494a:	f7fc b941 	b.w	8000bd0 <__port_irq_epilogue>
  sts = usbp->otg->GRXSTSP;
 800494e:	f8d6 5090 	ldr.w	r5, [r6, #144]	@ 0x90
 8004952:	6a2b      	ldr	r3, [r5, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8004954:	f403 12f0 	and.w	r2, r3, #1966080	@ 0x1e0000
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8004958:	f3c3 110a 	ubfx	r1, r3, #4, #11
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800495c:	f003 030f 	and.w	r3, r3, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8004960:	f5b2 2f80 	cmp.w	r2, #262144	@ 0x40000
 8004964:	f000 80d4 	beq.w	8004b10 <Vector174+0x3e0>
 8004968:	f5b2 2f40 	cmp.w	r2, #786432	@ 0xc0000
 800496c:	f47f af14 	bne.w	8004798 <Vector174+0x68>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8004970:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8004974:	68db      	ldr	r3, [r3, #12]
 8004976:	6a1a      	ldr	r2, [r3, #32]
  while (i < n) {
 8004978:	2900      	cmp	r1, #0
 800497a:	f43f af0d 	beq.w	8004798 <Vector174+0x68>
      w = *fifop;
 800497e:	f505 5580 	add.w	r5, r5, #4096	@ 0x1000
  size_t i = 0;
 8004982:	2300      	movs	r3, #0
    if ((i & 3) == 0) {
 8004984:	0798      	lsls	r0, r3, #30
 8004986:	d101      	bne.n	800498c <Vector174+0x25c>
      w = *fifop;
 8004988:	f8d5 9000 	ldr.w	r9, [r5]
    if (i < max) {
 800498c:	2b07      	cmp	r3, #7
 800498e:	d803      	bhi.n	8004998 <Vector174+0x268>
      *buf++ = (uint8_t)w;
 8004990:	f802 9b01 	strb.w	r9, [r2], #1
      w >>= 8;
 8004994:	ea4f 2919 	mov.w	r9, r9, lsr #8
    i++;
 8004998:	3301      	adds	r3, #1
  while (i < n) {
 800499a:	4299      	cmp	r1, r3
 800499c:	d1f2      	bne.n	8004984 <Vector174+0x254>
 800499e:	e6fb      	b.n	8004798 <Vector174+0x68>
  stm32_otg_t *otgp = usbp->otg;
 80049a0:	f8d6 a090 	ldr.w	sl, [r6, #144]	@ 0x90
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80049a4:	2500      	movs	r5, #0
      _usb_isr_invoke_out_cb(usbp, ep);
 80049a6:	f04f 0b01 	mov.w	fp, #1
 80049aa:	e00f      	b.n	80049cc <Vector174+0x29c>
 80049ac:	24006e20 	.word	0x24006e20
 80049b0:	24006c3c 	.word	0x24006c3c
 80049b4:	e0001000 	.word	0xe0001000
 80049b8:	080072a4 	.word	0x080072a4
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80049bc:	3501      	adds	r5, #1
 80049be:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
 80049c2:	b2ed      	uxtb	r5, r5
 80049c4:	689b      	ldr	r3, [r3, #8]
 80049c6:	429d      	cmp	r5, r3
 80049c8:	f63f aee3 	bhi.w	8004792 <Vector174+0x62>
 80049cc:	eb0a 1245 	add.w	r2, sl, r5, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 80049d0:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	@ 0xb00
 80049d4:	f403 2340 	and.w	r3, r3, #786432	@ 0xc0000
 80049d8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 80049dc:	d1ee      	bne.n	80049bc <Vector174+0x28c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 80049de:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	@ 0xb00
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 80049e2:	2b00      	cmp	r3, #0
 80049e4:	daea      	bge.n	80049bc <Vector174+0x28c>
      _usb_isr_invoke_out_cb(usbp, ep);
 80049e6:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 80049ea:	fa0b f105 	lsl.w	r1, fp, r5
 80049ee:	68db      	ldr	r3, [r3, #12]
 80049f0:	68da      	ldr	r2, [r3, #12]
 80049f2:	8973      	ldrh	r3, [r6, #10]
 80049f4:	ea23 0301 	bic.w	r3, r3, r1
 80049f8:	8173      	strh	r3, [r6, #10]
 80049fa:	2a00      	cmp	r2, #0
 80049fc:	d0de      	beq.n	80049bc <Vector174+0x28c>
 80049fe:	4629      	mov	r1, r5
 8004a00:	4880      	ldr	r0, [pc, #512]	@ (8004c04 <Vector174+0x4d4>)
 8004a02:	4790      	blx	r2
 8004a04:	e7da      	b.n	80049bc <Vector174+0x28c>
  usbp->status        = 0;
 8004a06:	2500      	movs	r5, #0
  usbp->state         = USB_READY;
 8004a08:	2302      	movs	r3, #2
    usbp->epc[i] = NULL;
 8004a0a:	2224      	movs	r2, #36	@ 0x24
 8004a0c:	f106 000c 	add.w	r0, r6, #12
 8004a10:	4629      	mov	r1, r5
  usbp->state         = USB_READY;
 8004a12:	7033      	strb	r3, [r6, #0]
  usbp->status        = 0;
 8004a14:	f8c6 5088 	str.w	r5, [r6, #136]	@ 0x88
  usbp->transmitting  = 0;
 8004a18:	60b5      	str	r5, [r6, #8]
    usbp->epc[i] = NULL;
 8004a1a:	f001 fc09 	bl	8006230 <memset>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8004a1e:	2320      	movs	r3, #32
  usbp->ep0state = USB_EP0_STP_WAITING;
 8004a20:	f886 5070 	strb.w	r5, [r6, #112]	@ 0x70
 8004a24:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8004a26:	6923      	ldr	r3, [r4, #16]
 8004a28:	f013 0320 	ands.w	r3, r3, #32
 8004a2c:	d1fb      	bne.n	8004a26 <Vector174+0x2f6>
 8004a2e:	4976      	ldr	r1, [pc, #472]	@ (8004c08 <Vector174+0x4d8>)
 8004a30:	6848      	ldr	r0, [r1, #4]
 8004a32:	684a      	ldr	r2, [r1, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8004a34:	1a12      	subs	r2, r2, r0
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8004a36:	2a11      	cmp	r2, #17
 8004a38:	d9fb      	bls.n	8004a32 <Vector174+0x302>
  otgp->DIEPEMPMSK = 0;
 8004a3a:	2200      	movs	r2, #0
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8004a3c:	f8d6 5094 	ldr.w	r5, [r6, #148]	@ 0x94
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8004a40:	f04f 6000 	mov.w	r0, #134217728	@ 0x8000000
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8004a44:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
  otgp->DIEPEMPMSK = 0;
 8004a48:	f8c4 2834 	str.w	r2, [r4, #2100]	@ 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8004a4c:	f04f 1201 	mov.w	r2, #65537	@ 0x10001
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8004a50:	68af      	ldr	r7, [r5, #8]
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8004a52:	f8c4 281c 	str.w	r2, [r4, #2076]	@ 0x81c
 8004a56:	eb04 1243 	add.w	r2, r4, r3, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8004a5a:	429f      	cmp	r7, r3
 8004a5c:	f103 0301 	add.w	r3, r3, #1
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8004a60:	f8c2 0900 	str.w	r0, [r2, #2304]	@ 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8004a64:	f8c2 0b00 	str.w	r0, [r2, #2816]	@ 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8004a68:	f8c2 1908 	str.w	r1, [r2, #2312]	@ 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8004a6c:	f8c2 1b08 	str.w	r1, [r2, #2824]	@ 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8004a70:	d1f1      	bne.n	8004a56 <Vector174+0x326>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8004a72:	6828      	ldr	r0, [r5, #0]
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8004a74:	2310      	movs	r3, #16
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8004a76:	6260      	str	r0, [r4, #36]	@ 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8004a78:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8004a7a:	6923      	ldr	r3, [r4, #16]
 8004a7c:	06d9      	lsls	r1, r3, #27
 8004a7e:	d4fc      	bmi.n	8004a7a <Vector174+0x34a>
 8004a80:	4a61      	ldr	r2, [pc, #388]	@ (8004c08 <Vector174+0x4d8>)
 8004a82:	6851      	ldr	r1, [r2, #4]
 8004a84:	6853      	ldr	r3, [r2, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8004a86:	1a5b      	subs	r3, r3, r1
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8004a88:	2b11      	cmp	r3, #17
 8004a8a:	d9fb      	bls.n	8004a84 <Vector174+0x354>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8004a8c:	f8d4 3800 	ldr.w	r3, [r4, #2048]	@ 0x800
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8004a90:	686a      	ldr	r2, [r5, #4]
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8004a92:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 8004a96:	f8c4 3800 	str.w	r3, [r4, #2048]	@ 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8004a9a:	4b5c      	ldr	r3, [pc, #368]	@ (8004c0c <Vector174+0x4dc>)
 8004a9c:	69a1      	ldr	r1, [r4, #24]
 8004a9e:	430b      	orrs	r3, r1
  usbp->epc[0] = &ep0config;
 8004aa0:	495b      	ldr	r1, [pc, #364]	@ (8004c10 <Vector174+0x4e0>)
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8004aa2:	61a3      	str	r3, [r4, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8004aa4:	2309      	movs	r3, #9
  usbp->epc[0] = &ep0config;
 8004aa6:	60f1      	str	r1, [r6, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 8004aa8:	f04f 41c0 	mov.w	r1, #1610612736	@ 0x60000000
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8004aac:	f8c4 3810 	str.w	r3, [r4, #2064]	@ 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8004ab0:	f8c4 3814 	str.w	r3, [r4, #2068]	@ 0x814
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 8004ab4:	f8c4 1b10 	str.w	r1, [r4, #2832]	@ 0xb10
  otgp->ie[0].DIEPTSIZ = 0;
 8004ab8:	2100      	movs	r1, #0
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8004aba:	4b56      	ldr	r3, [pc, #344]	@ (8004c14 <Vector174+0x4e4>)
 8004abc:	f8c4 3b00 	str.w	r3, [r4, #2816]	@ 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 8004ac0:	f8c4 1910 	str.w	r1, [r4, #2320]	@ 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8004ac4:	f8c4 3900 	str.w	r3, [r4, #2304]	@ 0x900
  usbp->pmnext += size;
 8004ac8:	f100 0310 	add.w	r3, r0, #16
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8004acc:	4293      	cmp	r3, r2
  usbp->pmnext += size;
 8004ace:	f8c6 3098 	str.w	r3, [r6, #152]	@ 0x98
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8004ad2:	f200 8093 	bhi.w	8004bfc <Vector174+0x4cc>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8004ad6:	6873      	ldr	r3, [r6, #4]
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8004ad8:	f440 1080 	orr.w	r0, r0, #1048576	@ 0x100000
 8004adc:	681b      	ldr	r3, [r3, #0]
 8004ade:	62a0      	str	r0, [r4, #40]	@ 0x28
 8004ae0:	2b00      	cmp	r3, #0
 8004ae2:	f43f ae95 	beq.w	8004810 <Vector174+0xe0>
 8004ae6:	4847      	ldr	r0, [pc, #284]	@ (8004c04 <Vector174+0x4d4>)
 8004ae8:	4798      	blx	r3
 8004aea:	e691      	b.n	8004810 <Vector174+0xe0>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8004aec:	f8d4 3e00 	ldr.w	r3, [r4, #3584]	@ 0xe00
 8004af0:	f023 0303 	bic.w	r3, r3, #3
 8004af4:	f8c4 3e00 	str.w	r3, [r4, #3584]	@ 0xe00
 8004af8:	e6e4      	b.n	80048c4 <Vector174+0x194>
      otg_epout_handler(usbp, 8);
 8004afa:	2008      	movs	r0, #8
 8004afc:	f7fc f8b8 	bl	8000c70 <otg_epout_handler.constprop.0>
  if (sts & GINTSTS_IEPINT) {
 8004b00:	0379      	lsls	r1, r7, #13
 8004b02:	f57f ae85 	bpl.w	8004810 <Vector174+0xe0>
 8004b06:	e668      	b.n	80047da <Vector174+0xaa>
      otg_epin_handler(usbp, 8);
 8004b08:	2008      	movs	r0, #8
 8004b0a:	f7fc fc31 	bl	8001370 <otg_epin_handler.constprop.0>
 8004b0e:	e67f      	b.n	8004810 <Vector174+0xe0>
                            usbp->epc[ep]->out_state->rxbuf,
 8004b10:	1c98      	adds	r0, r3, #2
 8004b12:	eb06 0380 	add.w	r3, r6, r0, lsl #2
 8004b16:	685b      	ldr	r3, [r3, #4]
 8004b18:	f8d3 e018 	ldr.w	lr, [r3, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8004b1c:	e9de 2300 	ldrd	r2, r3, [lr]
 8004b20:	eba2 0c03 	sub.w	ip, r2, r3
 8004b24:	f8de 2008 	ldr.w	r2, [lr, #8]
  while (i < n) {
 8004b28:	b1b9      	cbz	r1, 8004b5a <Vector174+0x42a>
      w = *fifop;
 8004b2a:	f505 5580 	add.w	r5, r5, #4096	@ 0x1000
  size_t i = 0;
 8004b2e:	2300      	movs	r3, #0
    if ((i & 3) == 0) {
 8004b30:	f013 0f03 	tst.w	r3, #3
 8004b34:	d101      	bne.n	8004b3a <Vector174+0x40a>
      w = *fifop;
 8004b36:	f8d5 9000 	ldr.w	r9, [r5]
    if (i < max) {
 8004b3a:	459c      	cmp	ip, r3
 8004b3c:	d903      	bls.n	8004b46 <Vector174+0x416>
      *buf++ = (uint8_t)w;
 8004b3e:	f802 9b01 	strb.w	r9, [r2], #1
      w >>= 8;
 8004b42:	ea4f 2919 	mov.w	r9, r9, lsr #8
    i++;
 8004b46:	3301      	adds	r3, #1
  while (i < n) {
 8004b48:	4299      	cmp	r1, r3
 8004b4a:	d1f1      	bne.n	8004b30 <Vector174+0x400>
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8004b4c:	eb06 0680 	add.w	r6, r6, r0, lsl #2
 8004b50:	6873      	ldr	r3, [r6, #4]
 8004b52:	f8d3 e018 	ldr.w	lr, [r3, #24]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8004b56:	e9de 3201 	ldrd	r3, r2, [lr, #4]
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8004b5a:	440a      	add	r2, r1
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8004b5c:	4419      	add	r1, r3
 8004b5e:	e9ce 1201 	strd	r1, r2, [lr, #4]
    break;
 8004b62:	e619      	b.n	8004798 <Vector174+0x68>
      otg_epout_handler(usbp, 7);
 8004b64:	2007      	movs	r0, #7
 8004b66:	f7fc f883 	bl	8000c70 <otg_epout_handler.constprop.0>
 8004b6a:	e631      	b.n	80047d0 <Vector174+0xa0>
      otg_epout_handler(usbp, 0);
 8004b6c:	2000      	movs	r0, #0
 8004b6e:	f7fc f87f 	bl	8000c70 <otg_epout_handler.constprop.0>
    if (src & (1 << 17))
 8004b72:	03a5      	lsls	r5, r4, #14
 8004b74:	f57f ae1a 	bpl.w	80047ac <Vector174+0x7c>
      otg_epout_handler(usbp, 1);
 8004b78:	2001      	movs	r0, #1
 8004b7a:	f7fc f879 	bl	8000c70 <otg_epout_handler.constprop.0>
    if (src & (1 << 18))
 8004b7e:	0360      	lsls	r0, r4, #13
 8004b80:	f57f ae17 	bpl.w	80047b2 <Vector174+0x82>
      otg_epout_handler(usbp, 2);
 8004b84:	2002      	movs	r0, #2
 8004b86:	f7fc f873 	bl	8000c70 <otg_epout_handler.constprop.0>
    if (src & (1 << 19))
 8004b8a:	0321      	lsls	r1, r4, #12
 8004b8c:	f57f ae14 	bpl.w	80047b8 <Vector174+0x88>
      otg_epout_handler(usbp, 3);
 8004b90:	2003      	movs	r0, #3
 8004b92:	f7fc f86d 	bl	8000c70 <otg_epout_handler.constprop.0>
    if (src & (1 << 20))
 8004b96:	02e2      	lsls	r2, r4, #11
 8004b98:	f57f ae11 	bpl.w	80047be <Vector174+0x8e>
      otg_epout_handler(usbp, 4);
 8004b9c:	2004      	movs	r0, #4
 8004b9e:	f7fc f867 	bl	8000c70 <otg_epout_handler.constprop.0>
    if (src & (1 << 21))
 8004ba2:	02a3      	lsls	r3, r4, #10
 8004ba4:	f57f ae0e 	bpl.w	80047c4 <Vector174+0x94>
      otg_epout_handler(usbp, 5);
 8004ba8:	2005      	movs	r0, #5
 8004baa:	f7fc f861 	bl	8000c70 <otg_epout_handler.constprop.0>
    if (src & (1 << 22))
 8004bae:	0266      	lsls	r6, r4, #9
 8004bb0:	f57f ae0b 	bpl.w	80047ca <Vector174+0x9a>
      otg_epout_handler(usbp, 6);
 8004bb4:	2006      	movs	r0, #6
 8004bb6:	f7fc f85b 	bl	8000c70 <otg_epout_handler.constprop.0>
 8004bba:	e606      	b.n	80047ca <Vector174+0x9a>
      otg_epin_handler(usbp, 7);
 8004bbc:	2007      	movs	r0, #7
 8004bbe:	f7fc fbd7 	bl	8001370 <otg_epin_handler.constprop.0>
 8004bc2:	e622      	b.n	800480a <Vector174+0xda>
      otg_epin_handler(usbp, 6);
 8004bc4:	2006      	movs	r0, #6
 8004bc6:	f7fc fbd3 	bl	8001370 <otg_epin_handler.constprop.0>
 8004bca:	e61b      	b.n	8004804 <Vector174+0xd4>
      otg_epin_handler(usbp, 5);
 8004bcc:	2005      	movs	r0, #5
 8004bce:	f7fc fbcf 	bl	8001370 <otg_epin_handler.constprop.0>
 8004bd2:	e614      	b.n	80047fe <Vector174+0xce>
      otg_epin_handler(usbp, 4);
 8004bd4:	2004      	movs	r0, #4
 8004bd6:	f7fc fbcb 	bl	8001370 <otg_epin_handler.constprop.0>
 8004bda:	e60d      	b.n	80047f8 <Vector174+0xc8>
      otg_epin_handler(usbp, 3);
 8004bdc:	2003      	movs	r0, #3
 8004bde:	f7fc fbc7 	bl	8001370 <otg_epin_handler.constprop.0>
 8004be2:	e606      	b.n	80047f2 <Vector174+0xc2>
      otg_epin_handler(usbp, 2);
 8004be4:	2002      	movs	r0, #2
 8004be6:	f7fc fbc3 	bl	8001370 <otg_epin_handler.constprop.0>
 8004bea:	e5ff      	b.n	80047ec <Vector174+0xbc>
      otg_epin_handler(usbp, 1);
 8004bec:	2001      	movs	r0, #1
 8004bee:	f7fc fbbf 	bl	8001370 <otg_epin_handler.constprop.0>
 8004bf2:	e5f8      	b.n	80047e6 <Vector174+0xb6>
      otg_epin_handler(usbp, 0);
 8004bf4:	2000      	movs	r0, #0
 8004bf6:	f7fc fbbb 	bl	8001370 <otg_epin_handler.constprop.0>
 8004bfa:	e5f1      	b.n	80047e0 <Vector174+0xb0>
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8004bfc:	4806      	ldr	r0, [pc, #24]	@ (8004c18 <Vector174+0x4e8>)
 8004bfe:	f7fc f8a7 	bl	8000d50 <chSysHalt>
 8004c02:	bf00      	nop
 8004c04:	24006c3c 	.word	0x24006c3c
 8004c08:	e0001000 	.word	0xe0001000
 8004c0c:	000c0010 	.word	0x000c0010
 8004c10:	08007280 	.word	0x08007280
 8004c14:	10008040 	.word	0x10008040
 8004c18:	08007440 	.word	0x08007440
 8004c1c:	00000000 	.word	0x00000000

08004c20 <__early_init>:
}

__STATIC_INLINE void __rccResetAHB4(uint32_t mask) {

  /* Resetting the peripherals.*/
  RCC->AHB4RSTR |= mask;
 8004c20:	49ac      	ldr	r1, [pc, #688]	@ (8004ed4 <__early_init+0x2b4>)
 8004c22:	f240 60ff 	movw	r0, #1791	@ 0x6ff
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8004c26:	2300      	movs	r3, #0
  gpiop->OSPEEDR = config->ospeedr;
 8004c28:	f04f 6c4c 	mov.w	ip, #213909504	@ 0xcc00000
 8004c2c:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8004c30:	4302      	orrs	r2, r0
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8004c32:	b4f0      	push	{r4, r5, r6, r7}
 8004c34:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  gpiop->OSPEEDR = config->ospeedr;
 8004c38:	f46f 557f 	mvn.w	r5, #16320	@ 0x3fc0
  RCC->AHB4RSTR &= ~mask;
 8004c3c:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
  gpiop->ODR     = config->odr;
 8004c40:	f64f 76ff 	movw	r6, #65535	@ 0xffff
 8004c44:	4ca4      	ldr	r4, [pc, #656]	@ (8004ed8 <__early_init+0x2b8>)
  gpiop->PUPDR   = config->pupdr;
 8004c46:	f04f 3755 	mov.w	r7, #1431655765	@ 0x55555555
 8004c4a:	4014      	ands	r4, r2
  gpiop->OTYPER  = config->otyper;
 8004c4c:	4aa3      	ldr	r2, [pc, #652]	@ (8004edc <__early_init+0x2bc>)
 8004c4e:	f8c1 4088 	str.w	r4, [r1, #136]	@ 0x88
  (void)RCC->AHB4RSTR;
 8004c52:	f8d1 4088 	ldr.w	r4, [r1, #136]	@ 0x88
 */
__STATIC_INLINE void rccEnableAHB4(uint32_t mask, bool lp) {

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->AHB4ENR |= mask;
 8004c56:	f8d1 40e0 	ldr.w	r4, [r1, #224]	@ 0xe0
 8004c5a:	4304      	orrs	r4, r0
 8004c5c:	f8c1 40e0 	str.w	r4, [r1, #224]	@ 0xe0
  if (lp) {
    RCC_C1->AHB4LPENR |= mask;
 8004c60:	f8d1 4108 	ldr.w	r4, [r1, #264]	@ 0x108
 8004c64:	4304      	orrs	r4, r0
 8004c66:	489e      	ldr	r0, [pc, #632]	@ (8004ee0 <__early_init+0x2c0>)
 8004c68:	f8c1 4108 	str.w	r4, [r1, #264]	@ 0x108
  }
  else {
    RCC_C1->AHB4LPENR &= ~mask;
  }
  (void)RCC_C1->AHB4LPENR;
 8004c6c:	f8d1 4108 	ldr.w	r4, [r1, #264]	@ 0x108
  gpiop->PUPDR   = config->pupdr;
 8004c70:	4c9c      	ldr	r4, [pc, #624]	@ (8004ee4 <__early_init+0x2c4>)
  gpiop->OTYPER  = config->otyper;
 8004c72:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004c74:	6095      	str	r5, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8004c76:	60d4      	str	r4, [r2, #12]
  gpiop->ODR     = config->odr;
 8004c78:	f64f 74fe 	movw	r4, #65534	@ 0xfffe
  gpiop->OTYPER  = config->otyper;
 8004c7c:	4d9a      	ldr	r5, [pc, #616]	@ (8004ee8 <__early_init+0x2c8>)
  gpiop->ODR     = config->odr;
 8004c7e:	6154      	str	r4, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8004c80:	4c9a      	ldr	r4, [pc, #616]	@ (8004eec <__early_init+0x2cc>)
 8004c82:	6214      	str	r4, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8004c84:	4c9a      	ldr	r4, [pc, #616]	@ (8004ef0 <__early_init+0x2d0>)
 8004c86:	6254      	str	r4, [r2, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8004c88:	4c9a      	ldr	r4, [pc, #616]	@ (8004ef4 <__early_init+0x2d4>)
 8004c8a:	6014      	str	r4, [r2, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8004c8c:	4c9a      	ldr	r4, [pc, #616]	@ (8004ef8 <__early_init+0x2d8>)
  gpiop->OTYPER  = config->otyper;
 8004c8e:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004c90:	6084      	str	r4, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8004c92:	f104 6415 	add.w	r4, r4, #156237824	@ 0x9500000
 8004c96:	f504 24aa 	add.w	r4, r4, #348160	@ 0x55000
 8004c9a:	f204 4491 	addw	r4, r4, #1169	@ 0x491
 8004c9e:	60c4      	str	r4, [r0, #12]
  gpiop->ODR     = config->odr;
 8004ca0:	f64b 74fe 	movw	r4, #49150	@ 0xbffe
 8004ca4:	6144      	str	r4, [r0, #20]
  gpiop->AFRH    = config->afrh;
 8004ca6:	f44f 0430 	mov.w	r4, #11534336	@ 0xb00000
  gpiop->AFRL    = config->afrl;
 8004caa:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8004cac:	6244      	str	r4, [r0, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8004cae:	4c93      	ldr	r4, [pc, #588]	@ (8004efc <__early_init+0x2dc>)
 8004cb0:	6004      	str	r4, [r0, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8004cb2:	f640 700c 	movw	r0, #3852	@ 0xf0c
  gpiop->OTYPER  = config->otyper;
 8004cb6:	f8c2 3804 	str.w	r3, [r2, #2052]	@ 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8004cba:	f8c2 0808 	str.w	r0, [r2, #2056]	@ 0x808
  gpiop->PUPDR   = config->pupdr;
 8004cbe:	4890      	ldr	r0, [pc, #576]	@ (8004f00 <__early_init+0x2e0>)
  gpiop->OTYPER  = config->otyper;
 8004cc0:	4c90      	ldr	r4, [pc, #576]	@ (8004f04 <__early_init+0x2e4>)
  gpiop->PUPDR   = config->pupdr;
 8004cc2:	f8c2 080c 	str.w	r0, [r2, #2060]	@ 0x80c
  gpiop->AFRL    = config->afrl;
 8004cc6:	4890      	ldr	r0, [pc, #576]	@ (8004f08 <__early_init+0x2e8>)
  gpiop->ODR     = config->odr;
 8004cc8:	f8c2 6814 	str.w	r6, [r2, #2068]	@ 0x814
  gpiop->AFRL    = config->afrl;
 8004ccc:	f8c2 0820 	str.w	r0, [r2, #2080]	@ 0x820
  gpiop->MODER   = config->moder;
 8004cd0:	f640 2008 	movw	r0, #2568	@ 0xa08
  gpiop->AFRH    = config->afrh;
 8004cd4:	f8c2 3824 	str.w	r3, [r2, #2084]	@ 0x824
  gpiop->MODER   = config->moder;
 8004cd8:	f8c2 0800 	str.w	r0, [r2, #2048]	@ 0x800
  gpiop->OTYPER  = config->otyper;
 8004cdc:	f502 6240 	add.w	r2, r2, #3072	@ 0xc00
 8004ce0:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 8004ce4:	6050      	str	r0, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004ce6:	f44f 2070 	mov.w	r0, #983040	@ 0xf0000
 8004cea:	6090      	str	r0, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8004cec:	4887      	ldr	r0, [pc, #540]	@ (8004f0c <__early_init+0x2ec>)
 8004cee:	60d0      	str	r0, [r2, #12]
  gpiop->AFRH    = config->afrh;
 8004cf0:	2077      	movs	r0, #119	@ 0x77
  gpiop->ODR     = config->odr;
 8004cf2:	6156      	str	r6, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8004cf4:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8004cf6:	6250      	str	r0, [r2, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8004cf8:	f44f 10d0 	mov.w	r0, #1703936	@ 0x1a0000
 8004cfc:	6010      	str	r0, [r2, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8004cfe:	200c      	movs	r0, #12
  gpiop->OTYPER  = config->otyper;
 8004d00:	f8c2 3404 	str.w	r3, [r2, #1028]	@ 0x404
  gpiop->OSPEEDR = config->ospeedr;
 8004d04:	f8c2 0408 	str.w	r0, [r2, #1032]	@ 0x408
  gpiop->PUPDR   = config->pupdr;
 8004d08:	4881      	ldr	r0, [pc, #516]	@ (8004f10 <__early_init+0x2f0>)
 8004d0a:	f8c2 040c 	str.w	r0, [r2, #1036]	@ 0x40c
  gpiop->ODR     = config->odr;
 8004d0e:	f64f 70fd 	movw	r0, #65533	@ 0xfffd
 8004d12:	f8c2 0414 	str.w	r0, [r2, #1044]	@ 0x414
  gpiop->MODER   = config->moder;
 8004d16:	2004      	movs	r0, #4
  gpiop->AFRL    = config->afrl;
 8004d18:	f8c2 3420 	str.w	r3, [r2, #1056]	@ 0x420
  gpiop->AFRH    = config->afrh;
 8004d1c:	f8c2 3424 	str.w	r3, [r2, #1060]	@ 0x424
  gpiop->MODER   = config->moder;
 8004d20:	f8c2 0400 	str.w	r0, [r2, #1024]	@ 0x400
  gpiop->OTYPER  = config->otyper;
 8004d24:	f8c2 3804 	str.w	r3, [r2, #2052]	@ 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8004d28:	f8c2 3808 	str.w	r3, [r2, #2056]	@ 0x808
  gpiop->PUPDR   = config->pupdr;
 8004d2c:	f8c2 780c 	str.w	r7, [r2, #2060]	@ 0x80c
  gpiop->ODR     = config->odr;
 8004d30:	f8c2 6814 	str.w	r6, [r2, #2068]	@ 0x814
  gpiop->AFRL    = config->afrl;
 8004d34:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  gpiop->AFRH    = config->afrh;
 8004d38:	f8c2 3824 	str.w	r3, [r2, #2084]	@ 0x824
  gpiop->MODER   = config->moder;
 8004d3c:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800
  gpiop->OTYPER  = config->otyper;
 8004d40:	f502 52e0 	add.w	r2, r2, #7168	@ 0x1c00
 8004d44:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004d46:	f8c5 c008 	str.w	ip, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8004d4a:	f10c 4c88 	add.w	ip, ip, #1140850688	@ 0x44000000
  gpiop->OTYPER  = config->otyper;
 8004d4e:	4871      	ldr	r0, [pc, #452]	@ (8004f14 <__early_init+0x2f4>)
  gpiop->PUPDR   = config->pupdr;
 8004d50:	f10c 1c55 	add.w	ip, ip, #5570645	@ 0x550055
 8004d54:	f50c 5ca8 	add.w	ip, ip, #5376	@ 0x1500
 8004d58:	f8c5 c00c 	str.w	ip, [r5, #12]
  gpiop->ODR     = config->odr;
 8004d5c:	f64f 7c7f 	movw	ip, #65407	@ 0xff7f
 8004d60:	f8c5 c014 	str.w	ip, [r5, #20]
  gpiop->AFRH    = config->afrh;
 8004d64:	f8df c1b0 	ldr.w	ip, [pc, #432]	@ 8004f18 <__early_init+0x2f8>
  gpiop->AFRL    = config->afrl;
 8004d68:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8004d6a:	f8c5 c024 	str.w	ip, [r5, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8004d6e:	f8df c1ac 	ldr.w	ip, [pc, #428]	@ 8004f1c <__early_init+0x2fc>
 8004d72:	f8c5 c000 	str.w	ip, [r5]
  gpiop->OSPEEDR = config->ospeedr;
 8004d76:	250f      	movs	r5, #15
  gpiop->OTYPER  = config->otyper;
 8004d78:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004d7a:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8004d7c:	4d68      	ldr	r5, [pc, #416]	@ (8004f20 <__early_init+0x300>)
 8004d7e:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 8004d80:	6166      	str	r6, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8004d82:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8004d84:	6263      	str	r3, [r4, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8004d86:	6023      	str	r3, [r4, #0]
  gpiop->OTYPER  = config->otyper;
 8004d88:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004d8a:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8004d8c:	60c7      	str	r7, [r0, #12]
  gpiop->ODR     = config->odr;
 8004d8e:	6146      	str	r6, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8004d90:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8004d92:	6243      	str	r3, [r0, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8004d94:	6003      	str	r3, [r0, #0]
  (void)pwr;
#endif

  /* Lower C3 byte, it must be programmed at very first, then waiting for
     power supply to stabilize.*/
  PWR->CR3   = STM32_PWR_CR3 & 0x000000FFU;
 8004d96:	2002      	movs	r0, #2
  gpiop->OTYPER  = config->otyper;
 8004d98:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004d9a:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8004d9c:	60d7      	str	r7, [r2, #12]
  gpiop->ODR     = config->odr;
 8004d9e:	6156      	str	r6, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8004da0:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8004da2:	6253      	str	r3, [r2, #36]	@ 0x24
  gpiop->MODER   = config->moder;
 8004da4:	6013      	str	r3, [r2, #0]
 8004da6:	f502 5200 	add.w	r2, r2, #8192	@ 0x2000
  RCC_C1->APB4ENR |= mask;
 8004daa:	f8d1 30f4 	ldr.w	r3, [r1, #244]	@ 0xf4
 8004dae:	4303      	orrs	r3, r0
 8004db0:	f8c1 30f4 	str.w	r3, [r1, #244]	@ 0xf4
    RCC_C1->APB4LPENR |= mask;
 8004db4:	f8d1 311c 	ldr.w	r3, [r1, #284]	@ 0x11c
 8004db8:	4303      	orrs	r3, r0
 8004dba:	f8c1 311c 	str.w	r3, [r1, #284]	@ 0x11c
  (void)RCC_C1->APB4LPENR;
 8004dbe:	f8d1 311c 	ldr.w	r3, [r1, #284]	@ 0x11c
 8004dc2:	60d0      	str	r0, [r2, #12]
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0)
 8004dc4:	6853      	ldr	r3, [r2, #4]
 8004dc6:	049b      	lsls	r3, r3, #18
 8004dc8:	d5fc      	bpl.n	8004dc4 <__early_init+0x1a4>
    ; /* CHTODO timeout handling.*/

  PWR->CR1   = STM32_PWR_CR1 | 0xF0000000U;
  PWR->CR2   = STM32_PWR_CR2;
 8004dca:	2101      	movs	r1, #1
  PWR->CR1   = STM32_PWR_CR1 | 0xF0000000U;
 8004dcc:	4c55      	ldr	r4, [pc, #340]	@ (8004f24 <__early_init+0x304>)
  PWR->CR3   = STM32_PWR_CR3;   /* Other bits, lower byte is not changed.   */
  PWR->CPUCR = STM32_PWR_CPUCR;
 8004dce:	2300      	movs	r3, #0
  PWR->CR3   = STM32_PWR_CR3;   /* Other bits, lower byte is not changed.   */
 8004dd0:	4855      	ldr	r0, [pc, #340]	@ (8004f28 <__early_init+0x308>)
  PWR->CR1   = STM32_PWR_CR1 | 0xF0000000U;
 8004dd2:	6014      	str	r4, [r2, #0]
  PWR->CR2   = STM32_PWR_CR2;
 8004dd4:	6091      	str	r1, [r2, #8]
#endif
#endif
#if defined(HAL_LLD_TYPE3_H)
  while ((PWR->SRDCR & PWR_SRDCR_VOSRDY) == 0)
#else
  while ((PWR->D3CR & PWR_D3CR_VOSRDY) == 0)
 8004dd6:	4955      	ldr	r1, [pc, #340]	@ (8004f2c <__early_init+0x30c>)
  PWR->CR3   = STM32_PWR_CR3;   /* Other bits, lower byte is not changed.   */
 8004dd8:	60d0      	str	r0, [r2, #12]
  PWR->CPUCR = STM32_PWR_CPUCR;
 8004dda:	6113      	str	r3, [r2, #16]
  PWR->D3CR  = STM32_VOS;
 8004ddc:	6193      	str	r3, [r2, #24]
  while ((PWR->D3CR & PWR_D3CR_VOSRDY) == 0)
 8004dde:	698b      	ldr	r3, [r1, #24]
 8004de0:	049f      	lsls	r7, r3, #18
 8004de2:	d5fc      	bpl.n	8004dde <__early_init+0x1be>
  PWR->CR1 |= PWR_CR1_DBP;
 8004de4:	680b      	ldr	r3, [r1, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8004de6:	4a3b      	ldr	r2, [pc, #236]	@ (8004ed4 <__early_init+0x2b4>)
  PWR->CR1 |= PWR_CR1_DBP;
 8004de8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8004dec:	600b      	str	r3, [r1, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8004dee:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8004df0:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004df4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004df8:	d004      	beq.n	8004e04 <__early_init+0x1e4>
    RCC->BDCR = RCC_BDCR_BDRST;
 8004dfa:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
    RCC->BDCR = 0;
 8004dfe:	2300      	movs	r3, #0
    RCC->BDCR = RCC_BDCR_BDRST;
 8004e00:	6711      	str	r1, [r2, #112]	@ 0x70
    RCC->BDCR = 0;
 8004e02:	6713      	str	r3, [r2, #112]	@ 0x70
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 8004e04:	4a33      	ldr	r2, [pc, #204]	@ (8004ed4 <__early_init+0x2b4>)
 8004e06:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8004e08:	f043 0319 	orr.w	r3, r3, #25
 8004e0c:	6713      	str	r3, [r2, #112]	@ 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 8004e0e:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8004e10:	079e      	lsls	r6, r3, #30
 8004e12:	d5fc      	bpl.n	8004e0e <__early_init+0x1ee>
  /* Backup domain initialization.*/
  init_bkp_domain();

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8004e14:	6813      	ldr	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8004e16:	492f      	ldr	r1, [pc, #188]	@ (8004ed4 <__early_init+0x2b4>)
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8004e18:	f043 0301 	orr.w	r3, r3, #1
 8004e1c:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8004e1e:	680b      	ldr	r3, [r1, #0]
 8004e20:	075d      	lsls	r5, r3, #29
 8004e22:	d5fc      	bpl.n	8004e1e <__early_init+0x1fe>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. This is only required when using a debugger than can cause
     restarts.*/
  RCC->CFGR    = 0x00000000U;               /* Reset SW to HSI.             */
 8004e24:	2300      	movs	r3, #0
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8004e26:	4a2b      	ldr	r2, [pc, #172]	@ (8004ed4 <__early_init+0x2b4>)
  RCC->CFGR    = 0x00000000U;               /* Reset SW to HSI.             */
 8004e28:	610b      	str	r3, [r1, #16]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8004e2a:	6913      	ldr	r3, [r2, #16]
 8004e2c:	f013 0338 	ands.w	r3, r3, #56	@ 0x38
 8004e30:	d1fb      	bne.n	8004e2a <__early_init+0x20a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers cleared to reset values.*/
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
 8004e32:	2001      	movs	r0, #1
  RCC->HSICFGR = 0x40000000U;              /* HSICFGR Reset value.         */
 8004e34:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
#if !defined(STM32_ENFORCE_H7_REV_XY)
  RCC->CSICFGR = 0x20000000U;              /* CSICFGR Reset value.         */
 8004e38:	f04f 5400 	mov.w	r4, #536870912	@ 0x20000000
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
 8004e3c:	6010      	str	r0, [r2, #0]
  RCC->HSICFGR = 0x40000000U;              /* HSICFGR Reset value.         */
 8004e3e:	6051      	str	r1, [r2, #4]
#endif
  RCC->CSR     = 0x00000000U;              /* CSR reset value.             */
  RCC->PLLCFGR = 0x01FF0000U;              /* PLLCFGR reset value.         */
 8004e40:	483b      	ldr	r0, [pc, #236]	@ (8004f30 <__early_init+0x310>)
  cfgr |= STM32_HRTIMSEL;
#endif
#if STM32_TIMPRE_ENABLE == TRUE
  cfgr |= RCC_CFGR_TIMPRE;
#endif
  RCC->CFGR = cfgr;
 8004e42:	493c      	ldr	r1, [pc, #240]	@ (8004f34 <__early_init+0x314>)
  RCC->CSICFGR = 0x20000000U;              /* CSICFGR Reset value.         */
 8004e44:	60d4      	str	r4, [r2, #12]
  RCC->CSR     = 0x00000000U;              /* CSR reset value.             */
 8004e46:	6753      	str	r3, [r2, #116]	@ 0x74
  RCC->PLLCFGR = 0x01FF0000U;              /* PLLCFGR reset value.         */
 8004e48:	62d0      	str	r0, [r2, #44]	@ 0x2c
  RCC->CFGR = cfgr;
 8004e4a:	6111      	str	r1, [r2, #16]
  /* HSE activation with optional bypass.*/
#if STM32_HSE_ENABLED == TRUE
#if defined(STM32_HSE_BYPASS)
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  RCC->CR |= RCC_CR_HSEON;
 8004e4c:	6813      	ldr	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8004e4e:	4821      	ldr	r0, [pc, #132]	@ (8004ed4 <__early_init+0x2b4>)
  RCC->CR |= RCC_CR_HSEON;
 8004e50:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8004e54:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8004e56:	6803      	ldr	r3, [r0, #0]
 8004e58:	039c      	lsls	r4, r3, #14
 8004e5a:	d5fc      	bpl.n	8004e56 <__early_init+0x236>
    ;                           /* Waits until HSE is stable.               */
#endif /* STM32_HSE_ENABLED == TRUE */

  /* HSI48 activation.*/
#if STM32_HSI48_ENABLED == TRUE
  RCC->CR |= RCC_CR_HSI48ON;
 8004e5c:	6803      	ldr	r3, [r0, #0]
  while ((RCC->CR & RCC_CR_HSI48RDY) == 0)
 8004e5e:	491d      	ldr	r1, [pc, #116]	@ (8004ed4 <__early_init+0x2b4>)
  RCC->CR |= RCC_CR_HSI48ON;
 8004e60:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8004e64:	6003      	str	r3, [r0, #0]
  while ((RCC->CR & RCC_CR_HSI48RDY) == 0)
 8004e66:	680b      	ldr	r3, [r1, #0]
 8004e68:	0498      	lsls	r0, r3, #18
 8004e6a:	d5fc      	bpl.n	8004e66 <__early_init+0x246>

#endif /* STM32_HSI48_ENABLED == TRUE */

  /* CSI activation.*/
#if STM32_CSI_ENABLED == TRUE
  RCC->CR |= RCC_CR_CSION;
 8004e6c:	680b      	ldr	r3, [r1, #0]
  while ((RCC->CR & RCC_CR_CSIRDY) == 0)
 8004e6e:	4a19      	ldr	r2, [pc, #100]	@ (8004ed4 <__early_init+0x2b4>)
  RCC->CR |= RCC_CR_CSION;
 8004e70:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8004e74:	600b      	str	r3, [r1, #0]
  while ((RCC->CR & RCC_CR_CSIRDY) == 0)
 8004e76:	6813      	ldr	r3, [r2, #0]
 8004e78:	05d9      	lsls	r1, r3, #23
 8004e7a:	d5fc      	bpl.n	8004e76 <__early_init+0x256>
    ;                           /* Waits until CSI is stable.               */
#endif /* STM32_CSI_ENABLED == TRUE */

  /* LSI activation.*/
#if STM32_LSI_ENABLED == TRUE
  RCC->CSR |= RCC_CSR_LSION;
 8004e7c:	6f53      	ldr	r3, [r2, #116]	@ 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8004e7e:	4915      	ldr	r1, [pc, #84]	@ (8004ed4 <__early_init+0x2b4>)
  RCC->CSR |= RCC_CSR_LSION;
 8004e80:	f043 0301 	orr.w	r3, r3, #1
 8004e84:	6753      	str	r3, [r2, #116]	@ 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8004e86:	6f4b      	ldr	r3, [r1, #116]	@ 0x74
 8004e88:	079a      	lsls	r2, r3, #30
 8004e8a:	d5fc      	bpl.n	8004e86 <__early_init+0x266>
              STM32_PLLCFGR_PLL2RGE | STM32_PLLCFGR_PLL2VCOSEL | RCC_PLLCFGR_PLL2FRACEN |
              STM32_PLLCFGR_PLL1RGE | STM32_PLLCFGR_PLL1VCOSEL | RCC_PLLCFGR_PLL1FRACEN;

#if STM32_PLL1_ENABLED == TRUE
    RCC->PLL1FRACR = STM32_PLL1_FRACN;
    RCC->PLL1DIVR  = STM32_PLL1_DIVR | STM32_PLL1_DIVQ |
 8004e8c:	4a2a      	ldr	r2, [pc, #168]	@ (8004f38 <__early_init+0x318>)
    RCC->PLL1FRACR = STM32_PLL1_FRACN;
 8004e8e:	2000      	movs	r0, #0
    cfgmask |= RCC_PLLCFGR_DIVR3EN;
#endif
#endif /* STM32_PLL3_ENABLED == TRUE */

    /* Activating enabled PLLs and waiting for all of them to become ready.*/
    RCC->PLLCFGR = cfgmask & STM32_PLLCFGR_MASK;
 8004e90:	4b2a      	ldr	r3, [pc, #168]	@ (8004f3c <__early_init+0x31c>)
    RCC->PLLCKSELR = RCC_PLLCKSELR_DIVM3_VALUE(STM32_PLL3_DIVM_VALUE) |
 8004e92:	4c2b      	ldr	r4, [pc, #172]	@ (8004f40 <__early_init+0x320>)
 8004e94:	628c      	str	r4, [r1, #40]	@ 0x28
    RCC->PLL1FRACR = STM32_PLL1_FRACN;
 8004e96:	6348      	str	r0, [r1, #52]	@ 0x34
    RCC->PLL1DIVR  = STM32_PLL1_DIVR | STM32_PLL1_DIVQ |
 8004e98:	630a      	str	r2, [r1, #48]	@ 0x30
    RCC->PLLCFGR = cfgmask & STM32_PLLCFGR_MASK;
 8004e9a:	62cb      	str	r3, [r1, #44]	@ 0x2c
    RCC->CR     |= onmask;
 8004e9c:	680b      	ldr	r3, [r1, #0]
    while ((RCC->CR & rdymask) != rdymask)
 8004e9e:	4a0d      	ldr	r2, [pc, #52]	@ (8004ed4 <__early_init+0x2b4>)
    RCC->CR     |= onmask;
 8004ea0:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8004ea4:	600b      	str	r3, [r1, #0]
    while ((RCC->CR & rdymask) != rdymask)
 8004ea6:	6813      	ldr	r3, [r2, #0]
 8004ea8:	019b      	lsls	r3, r3, #6
 8004eaa:	d5fc      	bpl.n	8004ea6 <__early_init+0x286>
#if defined(HAL_LLD_TYPE3_H)
  RCC->CDCFGR1 = STM32_CDCPRE  | STM32_CDPPRE | STM32_CDHPRE;
  RCC->CDCFGR2 = STM32_CDPPRE2 | STM32_CDPPRE1;
  RCC->SRDCFGR = STM32_SRDPPRE;
#else
  RCC->D1CFGR = STM32_D1CPRE  | STM32_D1PPRE3 | STM32_D1HPRE;
 8004eac:	2448      	movs	r4, #72	@ 0x48
  RCC->D2CFGR = STM32_D2PPRE2 | STM32_D2PPRE1;
 8004eae:	f44f 6188 	mov.w	r1, #1088	@ 0x440
  RCC->D3CFGR = STM32_D3PPRE4;
 8004eb2:	2040      	movs	r0, #64	@ 0x40
                  STM32_ADCSEL     | STM32_LPTIM345SEL | STM32_LPTIM2SEL     |
                  STM32_I2C4SEL    | STM32_LPUART1SEL;
#elif defined(HAL_LLD_TYPE2_H)
  RCC->D1CCIPR  = STM32_CKPERSEL   | STM32_SDMMCSEL    | STM32_OCTOSPISEL    |
                  STM32_FMCSEL;
  RCC->D2CCIP1R = STM32_SWPSEL     | STM32_FDCANSEL    | STM32_DFSDM1SEL     |
 8004eb4:	2300      	movs	r3, #0
  RCC->D1CFGR = STM32_D1CPRE  | STM32_D1PPRE3 | STM32_D1HPRE;
 8004eb6:	6194      	str	r4, [r2, #24]
                  STM32_SPDIFSEL   | STM32_SPDIFSEL    | STM32_SPI45SEL      |
                  STM32_SPI123SEL  | STM32_SAI23SEL    | STM32_SAI1SEL;
  RCC->D2CCIP2R = STM32_LPTIM1SEL  | STM32_CECSEL      | STM32_USBSEL        |
 8004eb8:	f44f 1440 	mov.w	r4, #3145728	@ 0x300000
  RCC->D2CFGR = STM32_D2PPRE2 | STM32_D2PPRE1;
 8004ebc:	61d1      	str	r1, [r2, #28]
  RCC->D1CCIPR  = STM32_CKPERSEL   | STM32_SDMMCSEL    | STM32_OCTOSPISEL    |
 8004ebe:	f04f 5100 	mov.w	r1, #536870912	@ 0x20000000
  RCC->D3CFGR = STM32_D3PPRE4;
 8004ec2:	6210      	str	r0, [r2, #32]
                  STM32_LPTIM3SEL  | STM32_LPTIM2SEL   | STM32_I2C4SEL       |
                  STM32_LPUART1SEL;
#endif

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8004ec4:	2031      	movs	r0, #49	@ 0x31
  RCC->D1CCIPR  = STM32_CKPERSEL   | STM32_SDMMCSEL    | STM32_OCTOSPISEL    |
 8004ec6:	64d1      	str	r1, [r2, #76]	@ 0x4c
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8004ec8:	491e      	ldr	r1, [pc, #120]	@ (8004f44 <__early_init+0x324>)
  RCC->D2CCIP1R = STM32_SWPSEL     | STM32_FDCANSEL    | STM32_DFSDM1SEL     |
 8004eca:	6513      	str	r3, [r2, #80]	@ 0x50
  RCC->D2CCIP2R = STM32_LPTIM1SEL  | STM32_CECSEL      | STM32_USBSEL        |
 8004ecc:	6554      	str	r4, [r2, #84]	@ 0x54
  RCC->D3CCIPR  = STM32_SPI6SEL    | STM32_SAI4BSEL    | STM32_SAI4ASEL      |
 8004ece:	6593      	str	r3, [r2, #88]	@ 0x58
 8004ed0:	e03a      	b.n	8004f48 <__early_init+0x328>
 8004ed2:	bf00      	nop
 8004ed4:	58024400 	.word	0x58024400
 8004ed8:	fffff900 	.word	0xfffff900
 8004edc:	58020000 	.word	0x58020000
 8004ee0:	58020400 	.word	0x58020400
 8004ee4:	40005550 	.word	0x40005550
 8004ee8:	58021800 	.word	0x58021800
 8004eec:	10000bb2 	.word	0x10000bb2
 8004ef0:	000aaa0a 	.word	0x000aaa0a
 8004ef4:	aaa2802a 	.word	0xaaa2802a
 8004ef8:	3c0000c3 	.word	0x3c0000c3
 8004efc:	18000081 	.word	0x18000081
 8004f00:	01555051 	.word	0x01555051
 8004f04:	58021c00 	.word	0x58021c00
 8004f08:	00bb00b0 	.word	0x00bb00b0
 8004f0c:	55405555 	.word	0x55405555
 8004f10:	55555551 	.word	0x55555551
 8004f14:	58022400 	.word	0x58022400
 8004f18:	00b0b000 	.word	0x00b0b000
 8004f1c:	08804000 	.word	0x08804000
 8004f20:	55555550 	.word	0x55555550
 8004f24:	f000c000 	.word	0xf000c000
 8004f28:	01000002 	.word	0x01000002
 8004f2c:	58024800 	.word	0x58024800
 8004f30:	01ff0000 	.word	0x01ff0000
 8004f34:	08908800 	.word	0x08908800
 8004f38:	0101026f 	.word	0x0101026f
 8004f3c:	00070999 	.word	0x00070999
 8004f40:	00505052 	.word	0x00505052
 8004f44:	52002000 	.word	0x52002000
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8004f48:	6008      	str	r0, [r1, #0]
               STM32_FLASHBITS;
  while ((FLASH->ACR & FLASH_ACR_LATENCY) !=
 8004f4a:	680b      	ldr	r3, [r1, #0]
 8004f4c:	f003 030f 	and.w	r3, r3, #15
 8004f50:	2b01      	cmp	r3, #1
 8004f52:	d1fa      	bne.n	8004f4a <__early_init+0x32a>
  }

  /* Switching to the configured clock source if it is different
     from HSI.*/
#if STM32_SW != STM32_SW_HSI_CK
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8004f54:	4a13      	ldr	r2, [pc, #76]	@ (8004fa4 <__early_init+0x384>)
 8004f56:	6913      	ldr	r3, [r2, #16]
 8004f58:	f043 0303 	orr.w	r3, r3, #3
 8004f5c:	6113      	str	r3, [r2, #16]
  while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != (STM32_SW << RCC_CFGR_SWS_Pos))
 8004f5e:	6913      	ldr	r3, [r2, #16]
 8004f60:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8004f64:	2b18      	cmp	r3, #24
 8004f66:	d1fa      	bne.n	8004f5e <__early_init+0x33e>
  RCC_C1->AHB2ENR |= mask;
 8004f68:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
 8004f6c:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8004f70:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
    RCC_C1->AHB2LPENR |= mask;
 8004f74:	f8d2 3104 	ldr.w	r3, [r2, #260]	@ 0x104
 8004f78:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8004f7c:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
  (void)RCC_C1->AHB2LPENR;
 8004f80:	f8d2 3104 	ldr.w	r3, [r2, #260]	@ 0x104
  RCC_C1->AHB2ENR |= mask;
 8004f84:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
 8004f88:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8004f8c:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
    RCC_C1->AHB2LPENR |= mask;
 8004f90:	f8d2 3104 	ldr.w	r3, [r2, #260]	@ 0x104
 8004f94:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000

  stm32_gpio_init();
  stm32_clock_init();
}
 8004f98:	bcf0      	pop	{r4, r5, r6, r7}
 8004f9a:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
  (void)RCC_C1->AHB2LPENR;
 8004f9e:	f8d2 3104 	ldr.w	r3, [r2, #260]	@ 0x104
 8004fa2:	4770      	bx	lr
 8004fa4:	58024400 	.word	0x58024400
	...

08004fb0 <chSchDoPreemption>:
static void __sch_reschedule_ahead(void) {
 8004fb0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = __instance_get_currthread(oip);
 8004fb2:	4c15      	ldr	r4, [pc, #84]	@ (8005008 <chSchDoPreemption+0x58>)
  ntp->state = CH_STATE_CURRENT;
 8004fb4:	2201      	movs	r2, #1
  ch_priority_queue_t *p = pqp->next;
 8004fb6:	6825      	ldr	r5, [r4, #0]
  otp = __sch_ready_ahead(otp);
 8004fb8:	68e0      	ldr	r0, [r4, #12]
  pqp->next       = p->next;
 8004fba:	682b      	ldr	r3, [r5, #0]
  pqp->next->prev = pqp;
 8004fbc:	605c      	str	r4, [r3, #4]
  ntp->state = CH_STATE_CURRENT;
 8004fbe:	f885 2024 	strb.w	r2, [r5, #36]	@ 0x24
  pqp->next       = p->next;
 8004fc2:	6023      	str	r3, [r4, #0]
  __instance_set_currthread(oip, ntp);
 8004fc4:	60e5      	str	r5, [r4, #12]
  otp = __sch_ready_ahead(otp);
 8004fc6:	f7fc f91b 	bl	8001200 <__sch_ready_ahead>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8004fca:	f8b4 3088 	ldrh.w	r3, [r4, #136]	@ 0x88
 8004fce:	4606      	mov	r6, r0
 8004fd0:	079b      	lsls	r3, r3, #30
 8004fd2:	d505      	bpl.n	8004fe0 <chSchDoPreemption+0x30>
  chSysSwitch(ntp, otp);
 8004fd4:	4631      	mov	r1, r6
 8004fd6:	4628      	mov	r0, r5
}
 8004fd8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(ntp, otp);
 8004fdc:	f7fb ba00 	b.w	80003e0 <__port_switch>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004fe0:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 8004fe4:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 8004fe6:	00db      	lsls	r3, r3, #3
 8004fe8:	f8d4 208c 	ldr.w	r2, [r4, #140]	@ 0x8c
 8004fec:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8004ff0:	e9c2 5102 	strd	r5, r1, [r2, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004ff4:	7013      	strb	r3, [r2, #0]
    trace_next(oip);
 8004ff6:	f7fb fe8b 	bl	8000d10 <trace_next.constprop.0>
 8004ffa:	4631      	mov	r1, r6
 8004ffc:	4628      	mov	r0, r5
}
 8004ffe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(ntp, otp);
 8005002:	f7fb b9ed 	b.w	80003e0 <__port_switch>
 8005006:	bf00      	nop
 8005008:	24006e20 	.word	0x24006e20
 800500c:	00000000 	.word	0x00000000

08005010 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8005010:	b538      	push	{r3, r4, r5, lr}
  return __sch_get_currthread();
 8005012:	4d23      	ldr	r5, [pc, #140]	@ (80050a0 <chMtxUnlock+0x90>)
 8005014:	2330      	movs	r3, #48	@ 0x30
 8005016:	68ec      	ldr	r4, [r5, #12]
 8005018:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(mp != NULL);

  chSysLock();

  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 800501c:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 800501e:	2b00      	cmp	r3, #0
 8005020:	d030      	beq.n	8005084 <chMtxUnlock+0x74>
  chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 8005022:	689a      	ldr	r2, [r3, #8]
 8005024:	42a2      	cmp	r2, r4
 8005026:	d12d      	bne.n	8005084 <chMtxUnlock+0x74>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(currtp->mtxlist == mp, "not next in list");
 8005028:	4283      	cmp	r3, r0
 800502a:	4601      	mov	r1, r0
 800502c:	d12a      	bne.n	8005084 <chMtxUnlock+0x74>
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800502e:	6802      	ldr	r2, [r0, #0]
    currtp->mtxlist = mp->next;
 8005030:	68c3      	ldr	r3, [r0, #12]
    if (chMtxQueueNotEmptyS(mp)) {
 8005032:	4282      	cmp	r2, r0
    currtp->mtxlist = mp->next;
 8005034:	63e3      	str	r3, [r4, #60]	@ 0x3c
    if (chMtxQueueNotEmptyS(mp)) {
 8005036:	d028      	beq.n	800508a <chMtxUnlock+0x7a>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 8005038:	6c20      	ldr	r0, [r4, #64]	@ 0x40
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
 800503a:	b14b      	cbz	r3, 8005050 <chMtxUnlock+0x40>
  return (bool)(qp->next != qp);
 800503c:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800503e:	4293      	cmp	r3, r2
 8005040:	d003      	beq.n	800504a <chMtxUnlock+0x3a>
 8005042:	6892      	ldr	r2, [r2, #8]
 8005044:	4290      	cmp	r0, r2
 8005046:	bf38      	it	cc
 8005048:	4610      	movcc	r0, r2
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
 800504a:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 800504c:	2b00      	cmp	r3, #0
 800504e:	d1f5      	bne.n	800503c <chMtxUnlock+0x2c>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 8005050:	60a0      	str	r0, [r4, #8]
  ch_queue_t *p = qp->next;
 8005052:	6808      	ldr	r0, [r1, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8005054:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
  qp->next       = p->next;
 8005056:	6803      	ldr	r3, [r0, #0]
 8005058:	600b      	str	r3, [r1, #0]
  qp->next->prev = qp;
 800505a:	6059      	str	r1, [r3, #4]
 800505c:	e9c1 0202 	strd	r0, r2, [r1, #8]
      tp->mtxlist = mp;
 8005060:	63c1      	str	r1, [r0, #60]	@ 0x3c
  return __sch_ready_behind(tp);
 8005062:	f7fc fa55 	bl	8001510 <__sch_ready_behind.isra.0>
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 8005066:	682a      	ldr	r2, [r5, #0]
 8005068:	68eb      	ldr	r3, [r5, #12]
 800506a:	6892      	ldr	r2, [r2, #8]
 800506c:	689b      	ldr	r3, [r3, #8]
 800506e:	429a      	cmp	r2, r3
 8005070:	d904      	bls.n	800507c <chMtxUnlock+0x6c>
    __sch_reschedule_ahead();
 8005072:	f7ff ff9d 	bl	8004fb0 <chSchDoPreemption>
 8005076:	682b      	ldr	r3, [r5, #0]
 8005078:	42ab      	cmp	r3, r5
 800507a:	d109      	bne.n	8005090 <chMtxUnlock+0x80>
 800507c:	2300      	movs	r3, #0
 800507e:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 8005082:	bd38      	pop	{r3, r4, r5, pc}
  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 8005084:	4807      	ldr	r0, [pc, #28]	@ (80050a4 <chMtxUnlock+0x94>)
 8005086:	f7fb fe63 	bl	8000d50 <chSysHalt>
      mp->owner = NULL;
 800508a:	2300      	movs	r3, #0
 800508c:	6093      	str	r3, [r2, #8]
 800508e:	e7f2      	b.n	8005076 <chMtxUnlock+0x66>
 8005090:	68ea      	ldr	r2, [r5, #12]
 8005092:	689b      	ldr	r3, [r3, #8]
 8005094:	6892      	ldr	r2, [r2, #8]
 8005096:	429a      	cmp	r2, r3
 8005098:	d2f0      	bcs.n	800507c <chMtxUnlock+0x6c>
 800509a:	4803      	ldr	r0, [pc, #12]	@ (80050a8 <chMtxUnlock+0x98>)
 800509c:	f7fb fe58 	bl	8000d50 <chSysHalt>
 80050a0:	24006e20 	.word	0x24006e20
 80050a4:	080071bc 	.word	0x080071bc
 80050a8:	0800720c 	.word	0x0800720c
 80050ac:	00000000 	.word	0x00000000

080050b0 <chThdRelease.part.0>:
void chThdRelease(thread_t *tp) {
 80050b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80050b4:	4e49      	ldr	r6, [pc, #292]	@ (80051dc <chThdRelease.part.0+0x12c>)
 80050b6:	6831      	ldr	r1, [r6, #0]
  p->prev->next = p->next;
 80050b8:	e9d0 3204 	ldrd	r3, r2, [r0, #16]
 80050bc:	42b1      	cmp	r1, r6
 80050be:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 80050c0:	605a      	str	r2, [r3, #4]
 80050c2:	d16f      	bne.n	80051a4 <chThdRelease.part.0+0xf4>
 80050c4:	2300      	movs	r3, #0
 80050c6:	f383 8811 	msr	BASEPRI, r3
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 80050ca:	f890 3025 	ldrb.w	r3, [r0, #37]	@ 0x25
 80050ce:	f003 0303 	and.w	r3, r3, #3
 80050d2:	2b01      	cmp	r3, #1
 80050d4:	d011      	beq.n	80050fa <chThdRelease.part.0+0x4a>
 80050d6:	2b02      	cmp	r3, #2
 80050d8:	d10d      	bne.n	80050f6 <chThdRelease.part.0+0x46>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 80050da:	6c43      	ldr	r3, [r0, #68]	@ 0x44
 80050dc:	2130      	movs	r1, #48	@ 0x30
  return tp->wabase;
 80050de:	6a02      	ldr	r2, [r0, #32]
 80050e0:	f381 8811 	msr	BASEPRI, r1
 80050e4:	6831      	ldr	r1, [r6, #0]
  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 80050e6:	6818      	ldr	r0, [r3, #0]
 80050e8:	42b1      	cmp	r1, r6
 80050ea:	6010      	str	r0, [r2, #0]
  mp->next = php;
 80050ec:	601a      	str	r2, [r3, #0]
 80050ee:	d164      	bne.n	80051ba <chThdRelease.part.0+0x10a>
 80050f0:	2300      	movs	r3, #0
 80050f2:	f383 8811 	msr	BASEPRI, r3
}
 80050f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80050fa:	6a07      	ldr	r7, [r0, #32]
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80050fc:	e957 5302 	ldrd	r5, r3, [r7, #-8]
  hp = (heap_header_t *)p - 1U;
 8005100:	f1a7 0408 	sub.w	r4, r7, #8
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8005104:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8005106:	f105 080c 	add.w	r8, r5, #12
  qp = &heapp->header;
 800510a:	3504      	adds	r5, #4
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 800510c:	08db      	lsrs	r3, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800510e:	f847 3c04 	str.w	r3, [r7, #-4]
 8005112:	2330      	movs	r3, #48	@ 0x30
 8005114:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(mp);
 8005118:	4640      	mov	r0, r8
 800511a:	f7fd faf9 	bl	8002710 <chMtxLockS>
 800511e:	6833      	ldr	r3, [r6, #0]
 8005120:	42b3      	cmp	r3, r6
 8005122:	d152      	bne.n	80051ca <chThdRelease.part.0+0x11a>
 8005124:	2300      	movs	r3, #0
 8005126:	f383 8811 	msr	BASEPRI, r3
  qp = &heapp->header;
 800512a:	462b      	mov	r3, r5

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 800512c:	429c      	cmp	r4, r3
 800512e:	d205      	bcs.n	800513c <chThdRelease.part.0+0x8c>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8005130:	429d      	cmp	r5, r3
 8005132:	d00d      	beq.n	8005150 <chThdRelease.part.0+0xa0>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8005134:	681a      	ldr	r2, [r3, #0]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 8005136:	4613      	mov	r3, r2
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8005138:	429c      	cmp	r4, r3
 800513a:	d3f9      	bcc.n	8005130 <chThdRelease.part.0+0x80>
 800513c:	685a      	ldr	r2, [r3, #4]
 800513e:	3201      	adds	r2, #1
 8005140:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8005144:	4294      	cmp	r4, r2
 8005146:	d335      	bcc.n	80051b4 <chThdRelease.part.0+0x104>
    if (((qp == &heapp->header) || (hp > qp)) &&
 8005148:	429d      	cmp	r5, r3
 800514a:	d001      	beq.n	8005150 <chThdRelease.part.0+0xa0>
 800514c:	429c      	cmp	r4, r3
 800514e:	d9f1      	bls.n	8005134 <chThdRelease.part.0+0x84>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8005150:	681a      	ldr	r2, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8005152:	b10a      	cbz	r2, 8005158 <chThdRelease.part.0+0xa8>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8005154:	4294      	cmp	r4, r2
 8005156:	d2ee      	bcs.n	8005136 <chThdRelease.part.0+0x86>
      H_NEXT(hp) = H_NEXT(qp);
 8005158:	f847 2c08 	str.w	r2, [r7, #-8]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 800515c:	f857 2c04 	ldr.w	r2, [r7, #-4]
      H_NEXT(qp) = hp;
 8005160:	601c      	str	r4, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8005162:	3201      	adds	r2, #1
 8005164:	f857 1c08 	ldr.w	r1, [r7, #-8]
 8005168:	eb04 00c2 	add.w	r0, r4, r2, lsl #3
 800516c:	4281      	cmp	r1, r0
 800516e:	d011      	beq.n	8005194 <chThdRelease.part.0+0xe4>
      if ((H_LIMIT(qp) == hp)) {
 8005170:	6859      	ldr	r1, [r3, #4]
 8005172:	1c4a      	adds	r2, r1, #1
 8005174:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8005178:	4294      	cmp	r4, r2
 800517a:	d004      	beq.n	8005186 <chThdRelease.part.0+0xd6>
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800517c:	4640      	mov	r0, r8
 800517e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8005182:	f7ff bf45 	b.w	8005010 <chMtxUnlock>
        H_NEXT(qp) = H_NEXT(hp);
 8005186:	e957 0202 	ldrd	r0, r2, [r7, #-8]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 800518a:	3201      	adds	r2, #1
        H_NEXT(qp) = H_NEXT(hp);
 800518c:	6018      	str	r0, [r3, #0]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 800518e:	440a      	add	r2, r1
 8005190:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8005192:	e7f3      	b.n	800517c <chThdRelease.part.0+0xcc>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8005194:	6848      	ldr	r0, [r1, #4]
 8005196:	4410      	add	r0, r2
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8005198:	680a      	ldr	r2, [r1, #0]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 800519a:	f847 0c04 	str.w	r0, [r7, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800519e:	f847 2c08 	str.w	r2, [r7, #-8]
 80051a2:	e7e5      	b.n	8005170 <chThdRelease.part.0+0xc0>
 80051a4:	68f2      	ldr	r2, [r6, #12]
 80051a6:	688b      	ldr	r3, [r1, #8]
 80051a8:	6892      	ldr	r2, [r2, #8]
 80051aa:	429a      	cmp	r2, r3
 80051ac:	d28a      	bcs.n	80050c4 <chThdRelease.part.0+0x14>
 80051ae:	480c      	ldr	r0, [pc, #48]	@ (80051e0 <chThdRelease.part.0+0x130>)
 80051b0:	f7fb fdce 	bl	8000d50 <chSysHalt>
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 80051b4:	480b      	ldr	r0, [pc, #44]	@ (80051e4 <chThdRelease.part.0+0x134>)
 80051b6:	f7fb fdcb 	bl	8000d50 <chSysHalt>
 80051ba:	68f2      	ldr	r2, [r6, #12]
 80051bc:	688b      	ldr	r3, [r1, #8]
 80051be:	6892      	ldr	r2, [r2, #8]
 80051c0:	429a      	cmp	r2, r3
 80051c2:	d295      	bcs.n	80050f0 <chThdRelease.part.0+0x40>
 80051c4:	4808      	ldr	r0, [pc, #32]	@ (80051e8 <chThdRelease.part.0+0x138>)
 80051c6:	f7fb fdc3 	bl	8000d50 <chSysHalt>
 80051ca:	68f2      	ldr	r2, [r6, #12]
 80051cc:	689b      	ldr	r3, [r3, #8]
 80051ce:	6892      	ldr	r2, [r2, #8]
 80051d0:	429a      	cmp	r2, r3
 80051d2:	d2a7      	bcs.n	8005124 <chThdRelease.part.0+0x74>
 80051d4:	4805      	ldr	r0, [pc, #20]	@ (80051ec <chThdRelease.part.0+0x13c>)
 80051d6:	f7fb fdbb 	bl	8000d50 <chSysHalt>
 80051da:	bf00      	nop
 80051dc:	24006e20 	.word	0x24006e20
 80051e0:	08007224 	.word	0x08007224
 80051e4:	08007218 	.word	0x08007218
 80051e8:	08007200 	.word	0x08007200
 80051ec:	0800720c 	.word	0x0800720c

080051f0 <chRegNextThread>:
 80051f0:	2330      	movs	r3, #48	@ 0x30
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 80051f2:	b510      	push	{r4, lr}
 80051f4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();

  /* Next element in the registry queue.*/
  nqp = tp->rqueue.next;
  if (nqp == REG_HEADER(currcore)) {
 80051f8:	4a21      	ldr	r2, [pc, #132]	@ (8005280 <chRegNextThread+0x90>)
  nqp = tp->rqueue.next;
 80051fa:	6903      	ldr	r3, [r0, #16]
  if (nqp == REG_HEADER(currcore)) {
 80051fc:	4293      	cmp	r3, r2
 80051fe:	d027      	beq.n	8005250 <chRegNextThread+0x60>
    /*lint -save -e413 [1.3] Safe to subtract a calculated offset.*/
    ntp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
    /*lint -restore*/

#if CH_CFG_USE_DYNAMIC == TRUE
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8005200:	7d9a      	ldrb	r2, [r3, #22]
    ntp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 8005202:	f1a3 0410 	sub.w	r4, r3, #16
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8005206:	2aff      	cmp	r2, #255	@ 0xff
 8005208:	d02f      	beq.n	800526a <chRegNextThread+0x7a>

    ntp->refs++;
 800520a:	3201      	adds	r2, #1
 800520c:	759a      	strb	r2, [r3, #22]
 800520e:	4a1d      	ldr	r2, [pc, #116]	@ (8005284 <chRegNextThread+0x94>)
 8005210:	6813      	ldr	r3, [r2, #0]
 8005212:	4293      	cmp	r3, r2
 8005214:	d11e      	bne.n	8005254 <chRegNextThread+0x64>
 8005216:	2300      	movs	r3, #0
 8005218:	f383 8811 	msr	BASEPRI, r3
 800521c:	2330      	movs	r3, #48	@ 0x30
 800521e:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8005222:	f890 3026 	ldrb.w	r3, [r0, #38]	@ 0x26
 8005226:	b1eb      	cbz	r3, 8005264 <chRegNextThread+0x74>
  tp->refs--;
 8005228:	3b01      	subs	r3, #1
 800522a:	f880 3026 	strb.w	r3, [r0, #38]	@ 0x26
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800522e:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 8005230:	f003 13ff 	and.w	r3, r3, #16711935	@ 0xff00ff
 8005234:	2b0f      	cmp	r3, #15
 8005236:	d007      	beq.n	8005248 <chRegNextThread+0x58>
 8005238:	6813      	ldr	r3, [r2, #0]
 800523a:	4293      	cmp	r3, r2
 800523c:	d118      	bne.n	8005270 <chRegNextThread+0x80>
 800523e:	2300      	movs	r3, #0
 8005240:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
#endif

  return ntp;
}
 8005244:	4620      	mov	r0, r4
 8005246:	bd10      	pop	{r4, pc}
 8005248:	f7ff ff32 	bl	80050b0 <chThdRelease.part.0>
 800524c:	4620      	mov	r0, r4
 800524e:	bd10      	pop	{r4, pc}
    ntp = NULL;
 8005250:	2400      	movs	r4, #0
 8005252:	e7dc      	b.n	800520e <chRegNextThread+0x1e>
 8005254:	68d1      	ldr	r1, [r2, #12]
 8005256:	689b      	ldr	r3, [r3, #8]
 8005258:	6889      	ldr	r1, [r1, #8]
 800525a:	4299      	cmp	r1, r3
 800525c:	d2db      	bcs.n	8005216 <chRegNextThread+0x26>
 800525e:	480a      	ldr	r0, [pc, #40]	@ (8005288 <chRegNextThread+0x98>)
 8005260:	f7fb fd76 	bl	8000d50 <chSysHalt>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8005264:	4809      	ldr	r0, [pc, #36]	@ (800528c <chRegNextThread+0x9c>)
 8005266:	f7fb fd73 	bl	8000d50 <chSysHalt>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 800526a:	4809      	ldr	r0, [pc, #36]	@ (8005290 <chRegNextThread+0xa0>)
 800526c:	f7fb fd70 	bl	8000d50 <chSysHalt>
 8005270:	68d2      	ldr	r2, [r2, #12]
 8005272:	689b      	ldr	r3, [r3, #8]
 8005274:	6892      	ldr	r2, [r2, #8]
 8005276:	429a      	cmp	r2, r3
 8005278:	d2e1      	bcs.n	800523e <chRegNextThread+0x4e>
 800527a:	4806      	ldr	r0, [pc, #24]	@ (8005294 <chRegNextThread+0xa4>)
 800527c:	f7fb fd68 	bl	8000d50 <chSysHalt>
 8005280:	24006e48 	.word	0x24006e48
 8005284:	24006e20 	.word	0x24006e20
 8005288:	080071d4 	.word	0x080071d4
 800528c:	080071e0 	.word	0x080071e0
 8005290:	080071f0 	.word	0x080071f0
 8005294:	08007224 	.word	0x08007224
	...

080052a0 <cmd_threads>:
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 80052a0:	2900      	cmp	r1, #0
 80052a2:	dc40      	bgt.n	8005326 <cmd_threads+0x86>
    shellUsage(chp, "threads");
    return;
  }
  chprintf(chp, "core stklimit    stack     addr refs prio     state         name" SHELL_NEWLINE_STR);
 80052a4:	4926      	ldr	r1, [pc, #152]	@ (8005340 <cmd_threads+0xa0>)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 80052a6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80052aa:	b087      	sub	sp, #28
 80052ac:	4606      	mov	r6, r0
  chprintf(chp, "core stklimit    stack     addr refs prio     state         name" SHELL_NEWLINE_STR);
 80052ae:	f7fd fae7 	bl	8002880 <chprintf>
 80052b2:	2330      	movs	r3, #48	@ 0x30
 80052b4:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)REG_HEADER(currcore)->next;
 80052b8:	4b22      	ldr	r3, [pc, #136]	@ (8005344 <cmd_threads+0xa4>)
 80052ba:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80052bc:	6818      	ldr	r0, [r3, #0]
  tp->refs++;
 80052be:	7d91      	ldrb	r1, [r2, #22]
  tp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 80052c0:	f1a2 0410 	sub.w	r4, r2, #16
 80052c4:	4298      	cmp	r0, r3
  tp->refs++;
 80052c6:	f101 0101 	add.w	r1, r1, #1
 80052ca:	7591      	strb	r1, [r2, #22]
 80052cc:	d12f      	bne.n	800532e <cmd_threads+0x8e>
 80052ce:	2300      	movs	r3, #0
 80052d0:	f383 8811 	msr	BASEPRI, r3
  return tp;
 80052d4:	f8df 9070 	ldr.w	r9, [pc, #112]	@ 8005348 <cmd_threads+0xa8>
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%4lu %08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 80052d8:	f8df 8070 	ldr.w	r8, [pc, #112]	@ 800534c <cmd_threads+0xac>
 80052dc:	4f1c      	ldr	r7, [pc, #112]	@ (8005350 <cmd_threads+0xb0>)
             stklimit,
             (uint32_t)tp->ctx.sp,
             (uint32_t)tp,
             (uint32_t)tp->refs - 1,
             (uint32_t)tp->hdr.pqueue.prio,
             states[tp->state],
 80052de:	f894 3024 	ldrb.w	r3, [r4, #36]	@ 0x24
             (uint32_t)tp->refs - 1,
 80052e2:	f894 5026 	ldrb.w	r5, [r4, #38]	@ 0x26
    chprintf(chp, "%4lu %08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 80052e6:	f859 e023 	ldr.w	lr, [r9, r3, lsl #2]
 80052ea:	3d01      	subs	r5, #1
 80052ec:	6a23      	ldr	r3, [r4, #32]
    core_id = tp->owner->core_id;
 80052ee:	e9d4 2106 	ldrd	r2, r1, [r4, #24]
             (uint32_t)tp->hdr.pqueue.prio,
 80052f2:	e9d4 0c02 	ldrd	r0, ip, [r4, #8]
    chprintf(chp, "%4lu %08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 80052f6:	2900      	cmp	r1, #0
    core_id = tp->owner->core_id;
 80052f8:	6b12      	ldr	r2, [r2, #48]	@ 0x30
    chprintf(chp, "%4lu %08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 80052fa:	f8cd c000 	str.w	ip, [sp]
 80052fe:	bf08      	it	eq
 8005300:	4641      	moveq	r1, r8
 8005302:	e9cd 0e03 	strd	r0, lr, [sp, #12]
 8005306:	9105      	str	r1, [sp, #20]
 8005308:	4630      	mov	r0, r6
 800530a:	4639      	mov	r1, r7
 800530c:	e9cd 4501 	strd	r4, r5, [sp, #4]
 8005310:	f7fd fab6 	bl	8002880 <chprintf>
             tp->name == NULL ? "" : tp->name);
    tp = chRegNextThread(tp);
 8005314:	4620      	mov	r0, r4
 8005316:	f7ff ff6b 	bl	80051f0 <chRegNextThread>
  } while (tp != NULL);
 800531a:	4604      	mov	r4, r0
 800531c:	2800      	cmp	r0, #0
 800531e:	d1de      	bne.n	80052de <cmd_threads+0x3e>
}
 8005320:	b007      	add	sp, #28
 8005322:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    shellUsage(chp, "threads");
 8005326:	4a0b      	ldr	r2, [pc, #44]	@ (8005354 <cmd_threads+0xb4>)
 8005328:	490b      	ldr	r1, [pc, #44]	@ (8005358 <cmd_threads+0xb8>)
 800532a:	f7fd baa9 	b.w	8002880 <chprintf>
 800532e:	68da      	ldr	r2, [r3, #12]
 8005330:	6883      	ldr	r3, [r0, #8]
 8005332:	6892      	ldr	r2, [r2, #8]
 8005334:	429a      	cmp	r2, r3
 8005336:	d2ca      	bcs.n	80052ce <cmd_threads+0x2e>
 8005338:	4808      	ldr	r0, [pc, #32]	@ (800535c <cmd_threads+0xbc>)
 800533a:	f7fb fd09 	bl	8000d50 <chSysHalt>
 800533e:	bf00      	nop
 8005340:	08006b48 	.word	0x08006b48
 8005344:	24006e20 	.word	0x24006e20
 8005348:	08007138 	.word	0x08007138
 800534c:	08006b3c 	.word	0x08006b3c
 8005350:	08006b8c 	.word	0x08006b8c
 8005354:	08006b40 	.word	0x08006b40
 8005358:	080068e4 	.word	0x080068e4
 800535c:	080071d4 	.word	0x080071d4

08005360 <cmd_mem>:
  if (argc > 0) {
 8005360:	2900      	cmp	r1, #0
 8005362:	dc3a      	bgt.n	80053da <cmd_mem+0x7a>
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8005364:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005366:	4606      	mov	r6, r0
 8005368:	2330      	movs	r3, #48	@ 0x30
 800536a:	f383 8811 	msr	BASEPRI, r3
 800536e:	4823      	ldr	r0, [pc, #140]	@ (80053fc <cmd_mem+0x9c>)
 8005370:	f7fd f9ce 	bl	8002710 <chMtxLockS>
 8005374:	4b22      	ldr	r3, [pc, #136]	@ (8005400 <cmd_mem+0xa0>)
 8005376:	681a      	ldr	r2, [r3, #0]
 8005378:	429a      	cmp	r2, r3
 800537a:	d136      	bne.n	80053ea <cmd_mem+0x8a>
 800537c:	2400      	movs	r4, #0
 800537e:	f384 8811 	msr	BASEPRI, r4
  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8005382:	4b20      	ldr	r3, [pc, #128]	@ (8005404 <cmd_mem+0xa4>)
 8005384:	685b      	ldr	r3, [r3, #4]
 8005386:	b363      	cbz	r3, 80053e2 <cmd_mem+0x82>
  tpages = 0U;
 8005388:	4622      	mov	r2, r4
  n = 0U;
 800538a:	4627      	mov	r7, r4
    size_t pages = H_PAGES(H_NEXT(qp));

    /* Updating counters.*/
    n++;
 800538c:	3701      	adds	r7, #1
  while (H_NEXT(qp) != NULL) {
 800538e:	e9d3 3100 	ldrd	r3, r1, [r3]
    tpages += pages;
    if (pages > lpages) {
 8005392:	428c      	cmp	r4, r1
    tpages += pages;
 8005394:	440a      	add	r2, r1
    if (pages > lpages) {
 8005396:	bf38      	it	cc
 8005398:	460c      	movcc	r4, r1
  while (H_NEXT(qp) != NULL) {
 800539a:	2b00      	cmp	r3, #0
 800539c:	d1f6      	bne.n	800538c <cmd_mem+0x2c>
    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 800539e:	00d5      	lsls	r5, r2, #3
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 80053a0:	00e4      	lsls	r4, r4, #3
  }
  H_UNLOCK(heapp);
 80053a2:	4816      	ldr	r0, [pc, #88]	@ (80053fc <cmd_mem+0x9c>)
 80053a4:	f7ff fe34 	bl	8005010 <chMtxUnlock>
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.topmem - ch_memcore.basemem);
 80053a8:	4b17      	ldr	r3, [pc, #92]	@ (8005408 <cmd_mem+0xa8>)
  chprintf(chp, "core free memory : %u bytes" SHELL_NEWLINE_STR, chCoreGetStatusX());
 80053aa:	4918      	ldr	r1, [pc, #96]	@ (800540c <cmd_mem+0xac>)
 80053ac:	4630      	mov	r0, r6
 80053ae:	e9d3 3200 	ldrd	r3, r2, [r3]
 80053b2:	1ad2      	subs	r2, r2, r3
 80053b4:	f7fd fa64 	bl	8002880 <chprintf>
  chprintf(chp, "heap fragments   : %u" SHELL_NEWLINE_STR, n);
 80053b8:	463a      	mov	r2, r7
 80053ba:	4915      	ldr	r1, [pc, #84]	@ (8005410 <cmd_mem+0xb0>)
 80053bc:	4630      	mov	r0, r6
 80053be:	f7fd fa5f 	bl	8002880 <chprintf>
  chprintf(chp, "heap free total  : %u bytes" SHELL_NEWLINE_STR, total);
 80053c2:	462a      	mov	r2, r5
 80053c4:	4913      	ldr	r1, [pc, #76]	@ (8005414 <cmd_mem+0xb4>)
 80053c6:	4630      	mov	r0, r6
 80053c8:	f7fd fa5a 	bl	8002880 <chprintf>
  chprintf(chp, "heap free largest: %u bytes" SHELL_NEWLINE_STR, largest);
 80053cc:	4622      	mov	r2, r4
 80053ce:	4630      	mov	r0, r6
 80053d0:	4911      	ldr	r1, [pc, #68]	@ (8005418 <cmd_mem+0xb8>)
}
 80053d2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chprintf(chp, "heap free largest: %u bytes" SHELL_NEWLINE_STR, largest);
 80053d6:	f7fd ba53 	b.w	8002880 <chprintf>
    shellUsage(chp, "mem");
 80053da:	4a10      	ldr	r2, [pc, #64]	@ (800541c <cmd_mem+0xbc>)
 80053dc:	4910      	ldr	r1, [pc, #64]	@ (8005420 <cmd_mem+0xc0>)
 80053de:	f7fd ba4f 	b.w	8002880 <chprintf>
  while (H_NEXT(qp) != NULL) {
 80053e2:	461c      	mov	r4, r3
 80053e4:	461d      	mov	r5, r3
  n = 0U;
 80053e6:	461f      	mov	r7, r3
 80053e8:	e7db      	b.n	80053a2 <cmd_mem+0x42>
 80053ea:	68d9      	ldr	r1, [r3, #12]
 80053ec:	6893      	ldr	r3, [r2, #8]
 80053ee:	688a      	ldr	r2, [r1, #8]
 80053f0:	429a      	cmp	r2, r3
 80053f2:	d2c3      	bcs.n	800537c <cmd_mem+0x1c>
 80053f4:	480b      	ldr	r0, [pc, #44]	@ (8005424 <cmd_mem+0xc4>)
 80053f6:	f7fb fcab 	bl	8000d50 <chSysHalt>
 80053fa:	bf00      	nop
 80053fc:	24006c14 	.word	0x24006c14
 8005400:	24006e20 	.word	0x24006e20
 8005404:	24006c08 	.word	0x24006c08
 8005408:	24006c28 	.word	0x24006c28
 800540c:	08006bbc 	.word	0x08006bbc
 8005410:	08006bdc 	.word	0x08006bdc
 8005414:	08006bf4 	.word	0x08006bf4
 8005418:	08006c14 	.word	0x08006c14
 800541c:	08006bb8 	.word	0x08006bb8
 8005420:	080068e4 	.word	0x080068e4
 8005424:	0800720c 	.word	0x0800720c
	...

08005430 <chThdExit>:
void chThdExit(msg_t msg) {
 8005430:	b508      	push	{r3, lr}
 8005432:	2330      	movs	r3, #48	@ 0x30
 8005434:	f383 8811 	msr	BASEPRI, r3
  chThdExitS(msg);
 8005438:	f7fd f942 	bl	80026c0 <chThdExitS>
 800543c:	0000      	movs	r0, r0
	...

08005440 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8005440:	f3ef 8309 	mrs	r3, PSP
    psp += sizeof (struct port_extctx);
 8005444:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8005446:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800544a:	2300      	movs	r3, #0
 800544c:	f383 8811 	msr	BASEPRI, r3
}
 8005450:	4770      	bx	lr
 8005452:	bf00      	nop
	...

08005460 <main>:
  RCC->AHB1RSTR |= mask;
 8005460:	4acc      	ldr	r2, [pc, #816]	@ (8005794 <main+0x334>)
  RCC->AHB1RSTR &= ~mask;
 8005462:	2100      	movs	r1, #0
  RCC->AHB1RSTR |= mask;
 8005464:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  RCC->AHB3RSTR |= mask;
 8005468:	4ccb      	ldr	r4, [pc, #812]	@ (8005798 <main+0x338>)
  RCC->AHB1RSTR |= mask;
 800546a:	f8d2 0080 	ldr.w	r0, [r2, #128]	@ 0x80
  RCC->AHB3RSTR &= ~mask;
 800546e:	4dcb      	ldr	r5, [pc, #812]	@ (800579c <main+0x33c>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
 8005470:	f8df 932c 	ldr.w	r9, [pc, #812]	@ 80057a0 <main+0x340>
 8005474:	f8df a32c 	ldr.w	sl, [pc, #812]	@ 80057a4 <main+0x344>
  shell_history,
  sizeof(shell_history),
  shell_completions,
};

int main(void) {
 8005478:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 800547c:	b089      	sub	sp, #36	@ 0x24
  RCC->AHB1RSTR |= mask;
 800547e:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
  RCC->AHB1RSTR &= ~mask;
 8005482:	f8d2 0080 	ldr.w	r0, [r2, #128]	@ 0x80
 8005486:	f8c2 1080 	str.w	r1, [r2, #128]	@ 0x80
  (void)RCC->AHB1RSTR;
 800548a:	f8d2 0080 	ldr.w	r0, [r2, #128]	@ 0x80
  RCC->AHB2RSTR |= mask;
 800548e:	f8d2 0084 	ldr.w	r0, [r2, #132]	@ 0x84
 8005492:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
  RCC->AHB2RSTR &= ~mask;
 8005496:	f8d2 0084 	ldr.w	r0, [r2, #132]	@ 0x84
 800549a:	f8c2 1084 	str.w	r1, [r2, #132]	@ 0x84
  (void)RCC->AHB2RSTR;
 800549e:	f8d2 0084 	ldr.w	r0, [r2, #132]	@ 0x84
  RCC->AHB3RSTR |= mask;
 80054a2:	6fd0      	ldr	r0, [r2, #124]	@ 0x7c
 80054a4:	4320      	orrs	r0, r4
 80054a6:	67d0      	str	r0, [r2, #124]	@ 0x7c
  RCC->AHB3RSTR &= ~mask;
 80054a8:	6fd4      	ldr	r4, [r2, #124]	@ 0x7c
  RCC->AHB4RSTR |= mask;
 80054aa:	48bf      	ldr	r0, [pc, #764]	@ (80057a8 <main+0x348>)
  RCC->AHB3RSTR &= ~mask;
 80054ac:	402c      	ands	r4, r5
 80054ae:	67d4      	str	r4, [r2, #124]	@ 0x7c
  (void)RCC->AHB3RSTR;
 80054b0:	6fd4      	ldr	r4, [r2, #124]	@ 0x7c
  RCC->AHB4RSTR |= mask;
 80054b2:	f8d2 4088 	ldr.w	r4, [r2, #136]	@ 0x88
 80054b6:	4320      	orrs	r0, r4
  RCC->AHB4RSTR &= ~mask;
 80054b8:	f240 64ff 	movw	r4, #1791	@ 0x6ff
  RCC->AHB4RSTR |= mask;
 80054bc:	f8c2 0088 	str.w	r0, [r2, #136]	@ 0x88
  RCC->AHB4RSTR &= ~mask;
 80054c0:	f8d2 0088 	ldr.w	r0, [r2, #136]	@ 0x88
 80054c4:	4020      	ands	r0, r4
 80054c6:	f8c2 0088 	str.w	r0, [r2, #136]	@ 0x88
  (void)RCC->AHB4RSTR;
 80054ca:	f8d2 0088 	ldr.w	r0, [r2, #136]	@ 0x88
  RCC->APB1LRSTR |= mask;
 80054ce:	f8d2 0090 	ldr.w	r0, [r2, #144]	@ 0x90
 80054d2:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  RCC->APB1LRSTR &= ~mask;
 80054d6:	f8d2 0090 	ldr.w	r0, [r2, #144]	@ 0x90
 80054da:	f8c2 1090 	str.w	r1, [r2, #144]	@ 0x90
  (void)RCC->APB1LRSTR;
 80054de:	f8d2 0090 	ldr.w	r0, [r2, #144]	@ 0x90
  RCC->APB1HRSTR |= mask;
 80054e2:	f8d2 0094 	ldr.w	r0, [r2, #148]	@ 0x94
 80054e6:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
  RCC->APB1HRSTR &= ~mask;
 80054ea:	f8d2 0094 	ldr.w	r0, [r2, #148]	@ 0x94
 80054ee:	f8c2 1094 	str.w	r1, [r2, #148]	@ 0x94
  (void)RCC->APB1HRSTR;
 80054f2:	f8d2 0094 	ldr.w	r0, [r2, #148]	@ 0x94
  RCC->APB2RSTR |= mask;
 80054f6:	f8d2 0098 	ldr.w	r0, [r2, #152]	@ 0x98
 80054fa:	f8c2 3098 	str.w	r3, [r2, #152]	@ 0x98
  RCC->APB2RSTR &= ~mask;
 80054fe:	f8d2 0098 	ldr.w	r0, [r2, #152]	@ 0x98
 8005502:	f8c2 1098 	str.w	r1, [r2, #152]	@ 0x98
  (void)RCC->APB2RSTR;
 8005506:	f8d2 0098 	ldr.w	r0, [r2, #152]	@ 0x98
  RCC->APB3RSTR |= mask;
 800550a:	f8d2 008c 	ldr.w	r0, [r2, #140]	@ 0x8c
 800550e:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
  RCC->APB3RSTR &= ~mask;
 8005512:	f8d2 008c 	ldr.w	r0, [r2, #140]	@ 0x8c
 8005516:	f8c2 108c 	str.w	r1, [r2, #140]	@ 0x8c
  (void)RCC->APB3RSTR;
 800551a:	f8d2 008c 	ldr.w	r0, [r2, #140]	@ 0x8c
  RCC->APB4RSTR |= mask;
 800551e:	f8d2 009c 	ldr.w	r0, [r2, #156]	@ 0x9c
 8005522:	4648      	mov	r0, r9
 8005524:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
 8005528:	460b      	mov	r3, r1
  RCC->APB4RSTR &= ~mask;
 800552a:	f8d2 409c 	ldr.w	r4, [r2, #156]	@ 0x9c
 800552e:	f8c2 109c 	str.w	r1, [r2, #156]	@ 0x9c
  (void)RCC->APB4RSTR;
 8005532:	f8d2 209c 	ldr.w	r2, [r2, #156]	@ 0x9c
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8005536:	460a      	mov	r2, r1
  dma.allocated_mask = 0U;
 8005538:	f840 1b04 	str.w	r1, [r0], #4
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 800553c:	f85a 1023 	ldr.w	r1, [sl, r3, lsl #2]
 8005540:	600a      	str	r2, [r1, #0]
    dma.streams[i].func = NULL;
 8005542:	f840 2013 	str.w	r2, [r0, r3, lsl #1]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8005546:	3304      	adds	r3, #4
 8005548:	2b40      	cmp	r3, #64	@ 0x40
 800554a:	d1f7      	bne.n	800553c <main+0xdc>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 800554c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8005550:	4996      	ldr	r1, [pc, #600]	@ (80057ac <main+0x34c>)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005552:	f44f 7080 	mov.w	r0, #256	@ 0x100
 8005556:	f44f 7400 	mov.w	r4, #512	@ 0x200
 800555a:	608a      	str	r2, [r1, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 800555c:	60ca      	str	r2, [r1, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 800555e:	f8c1 2408 	str.w	r2, [r1, #1032]	@ 0x408
  DMA2->HIFCR = 0xFFFFFFFFU;
 8005562:	f8c1 240c 	str.w	r2, [r1, #1036]	@ 0x40c
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8005566:	2160      	movs	r1, #96	@ 0x60
 8005568:	4a91      	ldr	r2, [pc, #580]	@ (80057b0 <main+0x350>)
 800556a:	f882 1306 	strb.w	r1, [r2, #774]	@ 0x306
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800556e:	f8c2 3180 	str.w	r3, [r2, #384]	@ 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005572:	6013      	str	r3, [r2, #0]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005574:	2380      	movs	r3, #128	@ 0x80
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8005576:	f882 1307 	strb.w	r1, [r2, #775]	@ 0x307
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800557a:	f8c2 3180 	str.w	r3, [r2, #384]	@ 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 800557e:	6013      	str	r3, [r2, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8005580:	f882 1308 	strb.w	r1, [r2, #776]	@ 0x308
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005584:	f8c2 0180 	str.w	r0, [r2, #384]	@ 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005588:	6010      	str	r0, [r2, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 800558a:	f882 1309 	strb.w	r1, [r2, #777]	@ 0x309
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800558e:	f8c2 4180 	str.w	r4, [r2, #384]	@ 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005592:	6014      	str	r4, [r2, #0]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005594:	f44f 6480 	mov.w	r4, #1024	@ 0x400
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8005598:	f882 130a 	strb.w	r1, [r2, #778]	@ 0x30a
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800559c:	f8c2 4180 	str.w	r4, [r2, #384]	@ 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80055a0:	6014      	str	r4, [r2, #0]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80055a2:	f44f 0400 	mov.w	r4, #8388608	@ 0x800000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80055a6:	f882 1317 	strb.w	r1, [r2, #791]	@ 0x317
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80055aa:	f8c2 4180 	str.w	r4, [r2, #384]	@ 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80055ae:	6014      	str	r4, [r2, #0]

#if PAL_USE_CALLBACKS || PAL_USE_WAIT || defined(__DOXYGEN__)
  unsigned i;

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
 80055b0:	2400      	movs	r4, #0
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80055b2:	f882 1328 	strb.w	r1, [r2, #808]	@ 0x328
 80055b6:	2190      	movs	r1, #144	@ 0x90
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80055b8:	f8c2 0184 	str.w	r0, [r2, #388]	@ 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80055bc:	6050      	str	r0, [r2, #4]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80055be:	f04f 5080 	mov.w	r0, #268435456	@ 0x10000000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80055c2:	f882 137a 	strb.w	r1, [r2, #890]	@ 0x37a
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80055c6:	f04f 6180 	mov.w	r1, #67108864	@ 0x4000000
 80055ca:	4b7a      	ldr	r3, [pc, #488]	@ (80057b4 <main+0x354>)
 80055cc:	f8c2 118c 	str.w	r1, [r2, #396]	@ 0x18c
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80055d0:	60d1      	str	r1, [r2, #12]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80055d2:	2170      	movs	r1, #112	@ 0x70
 80055d4:	f882 131c 	strb.w	r1, [r2, #796]	@ 0x31c
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80055d8:	f8c2 0180 	str.w	r0, [r2, #384]	@ 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80055dc:	6010      	str	r0, [r2, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80055de:	f882 1332 	strb.w	r1, [r2, #818]	@ 0x332
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80055e2:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
 80055e6:	f8c2 1184 	str.w	r1, [r2, #388]	@ 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80055ea:	6051      	str	r1, [r2, #4]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80055ec:	21c0      	movs	r1, #192	@ 0xc0
 80055ee:	f882 1325 	strb.w	r1, [r2, #805]	@ 0x325
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80055f2:	2120      	movs	r1, #32
 80055f4:	f8c2 1184 	str.w	r1, [r2, #388]	@ 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80055f8:	6051      	str	r1, [r2, #4]
  for (i = 0; i < 16; i++) {
 80055fa:	f103 0280 	add.w	r2, r3, #128	@ 0x80
    _pal_init_event(i);
 80055fe:	e9c3 4400 	strd	r4, r4, [r3]
  for (i = 0; i < 16; i++) {
 8005602:	3308      	adds	r3, #8
 8005604:	429a      	cmp	r2, r3
 8005606:	d1fa      	bne.n	80055fe <main+0x19e>
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
 8005608:	4b6b      	ldr	r3, [pc, #428]	@ (80057b8 <main+0x358>)
  UARTD1.dmarxmode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
 800560a:	2206      	movs	r2, #6
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 800560c:	4d6b      	ldr	r5, [pc, #428]	@ (80057bc <main+0x35c>)
 800560e:	2701      	movs	r7, #1
  usbp->state        = USB_STOP;
 8005610:	4e6b      	ldr	r6, [pc, #428]	@ (80057c0 <main+0x360>)
  PWMD5.channels = STM32_TIM5_CHANNELS;
 8005612:	f04f 0b04 	mov.w	fp, #4
    usbp->in_params[i]  = NULL;
 8005616:	2100      	movs	r1, #0
 8005618:	801f      	strh	r7, [r3, #0]
 800561a:	f106 0030 	add.w	r0, r6, #48	@ 0x30
  uartp->txstate    = UART_TX_IDLE;
  uartp->rxstate    = UART_RX_IDLE;
 800561e:	709c      	strb	r4, [r3, #2]
  uartp->config     = NULL;
 8005620:	605c      	str	r4, [r3, #4]
  pwmp->config   = NULL;
 8005622:	606c      	str	r4, [r5, #4]
  pwmp->state    = PWM_STOP;
 8005624:	702f      	strb	r7, [r5, #0]
  pwmp->enabled  = 0;
 8005626:	60ec      	str	r4, [r5, #12]
  PWMD5.has_bdtr = false;
 8005628:	762c      	strb	r4, [r5, #24]
  usbp->state        = USB_STOP;
 800562a:	7037      	strb	r7, [r6, #0]
  usbp->config       = NULL;
 800562c:	6074      	str	r4, [r6, #4]
  PWMD5.channels = STM32_TIM5_CHANNELS;
 800562e:	f885 b010 	strb.w	fp, [r5, #16]
  ch_system.state = ch_sys_initializing;
 8005632:	f8df 8190 	ldr.w	r8, [pc, #400]	@ 80057c4 <main+0x364>
  UARTD1.dmatxmode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
 8005636:	e9c3 2204 	strd	r2, r2, [r3, #16]
  PWMD5.tim = STM32_TIM5;
 800563a:	4a63      	ldr	r2, [pc, #396]	@ (80057c8 <main+0x368>)
 800563c:	61ea      	str	r2, [r5, #28]
  UARTD1.usart   = USART1;
 800563e:	f502 3282 	add.w	r2, r2, #66560	@ 0x10400
 8005642:	609a      	str	r2, [r3, #8]
  UARTD1.clock   = STM32_USART1CLK;
 8005644:	4a61      	ldr	r2, [pc, #388]	@ (80057cc <main+0x36c>)
 8005646:	60da      	str	r2, [r3, #12]
    usbp->in_params[i]  = NULL;
 8005648:	2240      	movs	r2, #64	@ 0x40
  UARTD1.dmatx   = NULL;
 800564a:	e9c3 4406 	strd	r4, r4, [r3, #24]
 800564e:	f000 fdef 	bl	8006230 <memset>
  RCC_C1->APB1LENR |= mask;
 8005652:	4a50      	ldr	r2, [pc, #320]	@ (8005794 <main+0x334>)
  usbp->transmitting = 0;
 8005654:	60b4      	str	r4, [r6, #8]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8005656:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800565a:	f8d2 10e8 	ldr.w	r1, [r2, #232]	@ 0xe8
  ST_ENABLE_STOP();
 800565e:	485c      	ldr	r0, [pc, #368]	@ (80057d0 <main+0x370>)
 8005660:	4339      	orrs	r1, r7
 8005662:	f8c2 10e8 	str.w	r1, [r2, #232]	@ 0xe8
    RCC_C1->APB1LLPENR |= mask;
 8005666:	f8d2 1110 	ldr.w	r1, [r2, #272]	@ 0x110
 800566a:	4339      	orrs	r1, r7
 800566c:	f8c2 1110 	str.w	r1, [r2, #272]	@ 0x110
  (void)RCC_C1->APB1LLPENR;
 8005670:	f8d2 2110 	ldr.w	r2, [r2, #272]	@ 0x110
 8005674:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
  USBD2.otg       = OTG_HS;
 8005676:	4957      	ldr	r1, [pc, #348]	@ (80057d4 <main+0x374>)
 8005678:	433a      	orrs	r2, r7
 800567a:	63c2      	str	r2, [r0, #60]	@ 0x3c
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800567c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8005680:	f8c6 1090 	str.w	r1, [r6, #144]	@ 0x90
  USBD2.otgparams = &hsparams;
 8005684:	4954      	ldr	r1, [pc, #336]	@ (80057d8 <main+0x378>)
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 8005686:	f8c8 4008 	str.w	r4, [r8, #8]
 800568a:	f8c6 1094 	str.w	r1, [r6, #148]	@ 0x94
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800568e:	f243 61af 	movw	r1, #13999	@ 0x36af
 8005692:	6299      	str	r1, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8005694:	62da      	str	r2, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8005696:	619c      	str	r4, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8005698:	635c      	str	r4, [r3, #52]	@ 0x34
  STM32_ST_TIM->DIER   = 0;
 800569a:	60dc      	str	r4, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 800569c:	605c      	str	r4, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800569e:	615f      	str	r7, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80056a0:	601f      	str	r7, [r3, #0]
  tmp->cumulative = (rttime_t)0;
 80056a2:	2300      	movs	r3, #0
 80056a4:	f888 7000 	strb.w	r7, [r8]
  tmp->n          = (ucnt_t)0;
 80056a8:	9405      	str	r4, [sp, #20]
  tmp->worst      = (rtcnt_t)0;
 80056aa:	e9cd 2402 	strd	r2, r4, [sp, #8]
  tmp->cumulative = (rttime_t)0;
 80056ae:	2200      	movs	r2, #0
 80056b0:	e9cd 2306 	strd	r2, r3, [sp, #24]
  chTMObjectInit(&tm);
  i = TM_CALIBRATION_LOOP;
  do {
    chTMStartMeasurementX(&tm);
 80056b4:	a802      	add	r0, sp, #8
 80056b6:	f7fb fa4b 	bl	8000b50 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 80056ba:	f7fb fa51 	bl	8000b60 <chTMStopMeasurementX>
    i--;
  } while (i > 0U);
 80056be:	f1bb 0b01 	subs.w	fp, fp, #1
 80056c2:	d1f7      	bne.n	80056b4 <main+0x254>
  default_heap.provider = chCoreAllocAlignedWithOffset;
 80056c4:	4f45      	ldr	r7, [pc, #276]	@ (80057dc <main+0x37c>)
 80056c6:	2030      	movs	r0, #48	@ 0x30
  qp->next = qp;
 80056c8:	4b45      	ldr	r3, [pc, #276]	@ (80057e0 <main+0x380>)
 80056ca:	f107 020c 	add.w	r2, r7, #12
  ch_memcore.basemem = __heap_base__;
 80056ce:	4945      	ldr	r1, [pc, #276]	@ (80057e4 <main+0x384>)
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
 80056d0:	4c45      	ldr	r4, [pc, #276]	@ (80057e8 <main+0x388>)
  mp->owner = NULL;
 80056d2:	f8c3 b008 	str.w	fp, [r3, #8]
  mp->next = NULL;
 80056d6:	f8c3 b014 	str.w	fp, [r3, #20]
 80056da:	f8c3 b02c 	str.w	fp, [r3, #44]	@ 0x2c
 80056de:	f8c7 b014 	str.w	fp, [r7, #20]
 80056e2:	f8c8 4004 	str.w	r4, [r8, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 80056e6:	f8c4 b030 	str.w	fp, [r4, #48]	@ 0x30
  qp->prev = qp;
 80056ea:	e9c7 2203 	strd	r2, r2, [r7, #12]
  mp->align = align;
 80056ee:	2204      	movs	r2, #4
 80056f0:	61da      	str	r2, [r3, #28]
 80056f2:	635a      	str	r2, [r3, #52]	@ 0x34
  mp->provider = provider;
 80056f4:	4a3d      	ldr	r2, [pc, #244]	@ (80057ec <main+0x38c>)
 80056f6:	621a      	str	r2, [r3, #32]
 80056f8:	639a      	str	r2, [r3, #56]	@ 0x38
  tcp->offset = tm.best;
 80056fa:	9a02      	ldr	r2, [sp, #8]
 80056fc:	f8c8 2008 	str.w	r2, [r8, #8]
 8005700:	4a3b      	ldr	r2, [pc, #236]	@ (80057f0 <main+0x390>)
 8005702:	600a      	str	r2, [r1, #0]
  ch_memcore.topmem  = __heap_end__;
 8005704:	4a3b      	ldr	r2, [pc, #236]	@ (80057f4 <main+0x394>)
 8005706:	604a      	str	r2, [r1, #4]
 8005708:	4a3b      	ldr	r2, [pc, #236]	@ (80057f8 <main+0x398>)
 800570a:	603a      	str	r2, [r7, #0]
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 800570c:	f103 0210 	add.w	r2, r3, #16
 8005710:	611a      	str	r2, [r3, #16]
  mp->object_size = size;
 8005712:	2214      	movs	r2, #20
 8005714:	619a      	str	r2, [r3, #24]
 8005716:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 800571a:	625a      	str	r2, [r3, #36]	@ 0x24
 800571c:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 8005720:	629a      	str	r2, [r3, #40]	@ 0x28
 8005722:	221c      	movs	r2, #28
 8005724:	631a      	str	r2, [r3, #48]	@ 0x30
 8005726:	f103 023c 	add.w	r2, r3, #60	@ 0x3c
 800572a:	63da      	str	r2, [r3, #60]	@ 0x3c
 800572c:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 8005730:	641a      	str	r2, [r3, #64]	@ 0x40
 8005732:	f103 0244 	add.w	r2, r3, #68	@ 0x44
 8005736:	e9c3 3300 	strd	r3, r3, [r3]
 800573a:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 800573c:	4b2f      	ldr	r3, [pc, #188]	@ (80057fc <main+0x39c>)
  H_PAGES(&default_heap.header) = 0;
 800573e:	e9c7 bb01 	strd	fp, fp, [r7, #4]
 8005742:	63a3      	str	r3, [r4, #56]	@ 0x38
 8005744:	f380 8811 	msr	BASEPRI, r0
  __ASM volatile ("cpsie i" : : : "memory");
 8005748:	b662      	cpsie	i
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800574a:	4b2d      	ldr	r3, [pc, #180]	@ (8005800 <main+0x3a0>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800574c:	f64f 0eff 	movw	lr, #63743	@ 0xf8ff
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
 8005750:	f8c4 b034 	str.w	fp, [r4, #52]	@ 0x34

  ch_dlist_init(&vtlp->dlist);
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 8005754:	f8c4 b01c 	str.w	fp, [r4, #28]
  reg_value  =  (reg_value                                   |
 8005758:	492a      	ldr	r1, [pc, #168]	@ (8005804 <main+0x3a4>)
  DWT->LAR = 0xC5ACCE55U;
 800575a:	4a2b      	ldr	r2, [pc, #172]	@ (8005808 <main+0x3a8>)
  pqp->prio = (tprio_t)0;
 800575c:	e9c4 4b01 	strd	r4, fp, [r4, #4]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8005760:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8005764:	ea0c 0c0e 	and.w	ip, ip, lr
  reg_value  =  (reg_value                                   |
 8005768:	ea4c 0101 	orr.w	r1, ip, r1
  SCB->AIRCR =  reg_value;
 800576c:	60d9      	str	r1, [r3, #12]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800576e:	f8d3 10fc 	ldr.w	r1, [r3, #252]	@ 0xfc
 8005772:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
 8005776:	f8c3 10fc 	str.w	r1, [r3, #252]	@ 0xfc
  DWT->LAR = 0xC5ACCE55U;
 800577a:	4924      	ldr	r1, [pc, #144]	@ (800580c <main+0x3ac>)
 800577c:	f8c2 1fb0 	str.w	r1, [r2, #4016]	@ 0xfb0
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8005780:	6811      	ldr	r1, [r2, #0]
 8005782:	f041 0101 	orr.w	r1, r1, #1
 8005786:	6011      	str	r1, [r2, #0]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005788:	2220      	movs	r2, #32
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 800578a:	4659      	mov	r1, fp
 800578c:	77da      	strb	r2, [r3, #31]
 800578e:	f883 0022 	strb.w	r0, [r3, #34]	@ 0x22
 8005792:	e03d      	b.n	8005810 <main+0x3b0>
 8005794:	58024400 	.word	0x58024400
 8005798:	7fffefff 	.word	0x7fffefff
 800579c:	80001000 	.word	0x80001000
 80057a0:	24006cd8 	.word	0x24006cd8
 80057a4:	08006ee4 	.word	0x08006ee4
 80057a8:	fffff900 	.word	0xfffff900
 80057ac:	40020000 	.word	0x40020000
 80057b0:	e000e100 	.word	0xe000e100
 80057b4:	24006da0 	.word	0x24006da0
 80057b8:	24006d7c 	.word	0x24006d7c
 80057bc:	24006d5c 	.word	0x24006d5c
 80057c0:	24006c3c 	.word	0x24006c3c
 80057c4:	24006c30 	.word	0x24006c30
 80057c8:	40000c00 	.word	0x40000c00
 80057cc:	042c1d80 	.word	0x042c1d80
 80057d0:	5c001000 	.word	0x5c001000
 80057d4:	40040000 	.word	0x40040000
 80057d8:	08006e28 	.word	0x08006e28
 80057dc:	24006c08 	.word	0x24006c08
 80057e0:	240065b8 	.word	0x240065b8
 80057e4:	24006c28 	.word	0x24006c28
 80057e8:	24006e20 	.word	0x24006e20
 80057ec:	08000bb1 	.word	0x08000bb1
 80057f0:	240077e8 	.word	0x240077e8
 80057f4:	24050000 	.word	0x24050000
 80057f8:	08001261 	.word	0x08001261
 80057fc:	08006e6c 	.word	0x08006e6c
 8005800:	e000ed00 	.word	0xe000ed00
 8005804:	05fa0300 	.word	0x05fa0300
 8005808:	e0001000 	.word	0xe0001000
 800580c:	c5acce55 	.word	0xc5acce55
 8005810:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  pqp->next = pqp;
 8005814:	6024      	str	r4, [r4, #0]
 8005816:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
  dlhp->next  = dlhp;
 8005818:	f104 0310 	add.w	r3, r4, #16
  dlhp->prev  = dlhp;
 800581c:	e9c4 3304 	strd	r3, r3, [r4, #16]
  dlhp->delta = (sysinterval_t)-1;
 8005820:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8005824:	4610      	mov	r0, r2
 8005826:	61a3      	str	r3, [r4, #24]
  tbp->suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8005828:	f503 0301 	add.w	r3, r3, #8454144	@ 0x810000
 800582c:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  tbp->ptr       = &tbp->buffer[0];
 8005830:	f104 0390 	add.w	r3, r4, #144	@ 0x90
 8005834:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8005838:	465b      	mov	r3, fp
 800583a:	e9c4 0108 	strd	r0, r1, [r4, #32]
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
 800583e:	f8c4 b084 	str.w	fp, [r4, #132]	@ 0x84
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8005842:	eb04 1103 	add.w	r1, r4, r3, lsl #4
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8005846:	3301      	adds	r3, #1
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8005848:	f891 2090 	ldrb.w	r2, [r1, #144]	@ 0x90
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800584c:	2b80      	cmp	r3, #128	@ 0x80
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800584e:	f022 0207 	bic.w	r2, r2, #7
 8005852:	f881 2090 	strb.w	r2, [r1, #144]	@ 0x90
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8005856:	d1f4      	bne.n	8005842 <main+0x3e2>
  tp->hdr.pqueue.prio   = prio;
 8005858:	6463      	str	r3, [r4, #68]	@ 0x44
  return chSchReadyI(chThdCreateSuspendedI(tdp));
 800585a:	a802      	add	r0, sp, #8
  tp->realprio          = prio;
 800585c:	67e3      	str	r3, [r4, #124]	@ 0x7c
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 800585e:	4bb2      	ldr	r3, [pc, #712]	@ (8005b28 <main+0x6c8>)
  p->next       = qp;
 8005860:	f8df b2c8 	ldr.w	fp, [pc, #712]	@ 8005b2c <main+0x6cc>
 8005864:	9303      	str	r3, [sp, #12]
 8005866:	f503 7398 	add.w	r3, r3, #304	@ 0x130
  tp->owner             = oip;
 800586a:	6564      	str	r4, [r4, #84]	@ 0x54
 800586c:	9304      	str	r3, [sp, #16]
  tp->mtxlist           = NULL;
 800586e:	2300      	movs	r3, #0
  tp->epending          = (eventmask_t)0;
 8005870:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
  oip->rlist.current->wabase = oicp->mainthread_base;
 8005874:	65e3      	str	r3, [r4, #92]	@ 0x5c
    thread_descriptor_t idle_descriptor = {
 8005876:	9307      	str	r3, [sp, #28]
  tp->refs              = (trefs_t)1;
 8005878:	2301      	movs	r3, #1
 800587a:	f884 3062 	strb.w	r3, [r4, #98]	@ 0x62
  oip->rlist.current->state = CH_STATE_CURRENT;
 800587e:	f8a4 3060 	strh.w	r3, [r4, #96]	@ 0x60
    thread_descriptor_t idle_descriptor = {
 8005882:	9305      	str	r3, [sp, #20]
  p->prev->next = p;
 8005884:	f10b 0324 	add.w	r3, fp, #36	@ 0x24
  qp->prev      = p;
 8005888:	e9c4 330a 	strd	r3, r3, [r4, #40]	@ 0x28
  qp->next = qp;
 800588c:	f10b 0344 	add.w	r3, fp, #68	@ 0x44
  qp->prev = qp;
 8005890:	e9c4 331b 	strd	r3, r3, [r4, #108]	@ 0x6c
  tp->name              = name;
 8005894:	4ba6      	ldr	r3, [pc, #664]	@ (8005b30 <main+0x6d0>)
 8005896:	65a3      	str	r3, [r4, #88]	@ 0x58
  lp->next = lp;
 8005898:	f10b 0340 	add.w	r3, fp, #64	@ 0x40
 800589c:	66a3      	str	r3, [r4, #104]	@ 0x68
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 800589e:	f10b 0314 	add.w	r3, fp, #20
 80058a2:	60e3      	str	r3, [r4, #12]
    thread_descriptor_t idle_descriptor = {
 80058a4:	4ba3      	ldr	r3, [pc, #652]	@ (8005b34 <main+0x6d4>)
 80058a6:	9302      	str	r3, [sp, #8]
 80058a8:	4ba3      	ldr	r3, [pc, #652]	@ (8005b38 <main+0x6d8>)
  p->prev       = qp->prev;
 80058aa:	e9c4 bb13 	strd	fp, fp, [r4, #76]	@ 0x4c
 80058ae:	9306      	str	r3, [sp, #24]
  return chSchReadyI(chThdCreateSuspendedI(tdp));
 80058b0:	f7fb f906 	bl	8000ac0 <chThdCreateSuspendedI>
  return __sch_ready_behind(tp);
 80058b4:	f7fb fe2c 	bl	8001510 <__sch_ready_behind.isra.0>
  ch_system.state = ch_sys_running;
 80058b8:	2302      	movs	r3, #2
 80058ba:	f888 3000 	strb.w	r3, [r8]
 80058be:	6823      	ldr	r3, [r4, #0]
 80058c0:	42a3      	cmp	r3, r4
 80058c2:	f040 8394 	bne.w	8005fee <main+0xb8e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80058c6:	2200      	movs	r2, #0
 80058c8:	f382 8811 	msr	BASEPRI, r2
  sdup->vmt = &vmt;
 80058cc:	4b9b      	ldr	r3, [pc, #620]	@ (8005b3c <main+0x6dc>)
  qp->next = qp;
 80058ce:	f103 000c 	add.w	r0, r3, #12
 80058d2:	4619      	mov	r1, r3
  ibqp->bcounter  = 0;
 80058d4:	619a      	str	r2, [r3, #24]
  ibqp->link      = link;
 80058d6:	641b      	str	r3, [r3, #64]	@ 0x40
  obqp->link      = link;
 80058d8:	679b      	str	r3, [r3, #120]	@ 0x78
  qp->prev = qp;
 80058da:	e9c3 0003 	strd	r0, r0, [r3, #12]
  ibqp->bsize     = size + sizeof (size_t);
 80058de:	f44f 7082 	mov.w	r0, #260	@ 0x104
 80058e2:	6298      	str	r0, [r3, #40]	@ 0x28
  obqp->bsize     = size + sizeof (size_t);
 80058e4:	6618      	str	r0, [r3, #96]	@ 0x60
  qp->next = qp;
 80058e6:	f103 0044 	add.w	r0, r3, #68	@ 0x44
  ibqp->top       = NULL;
 80058ea:	e9c3 220d 	strd	r2, r2, [r3, #52]	@ 0x34
  obqp->top       = NULL;
 80058ee:	e9c3 221b 	strd	r2, r2, [r3, #108]	@ 0x6c
  qp->prev = qp;
 80058f2:	e9c3 0011 	strd	r0, r0, [r3, #68]	@ 0x44
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 80058f6:	f503 7221 	add.w	r2, r3, #644	@ 0x284
 80058fa:	4891      	ldr	r0, [pc, #580]	@ (8005b40 <main+0x6e0>)
 80058fc:	625a      	str	r2, [r3, #36]	@ 0x24
 80058fe:	f841 0b04 	str.w	r0, [r1], #4
  obqp->buffers   = bp;
 8005902:	669a      	str	r2, [r3, #104]	@ 0x68
  esp->next = (event_listener_t *)esp;
 8005904:	6059      	str	r1, [r3, #4]
  ibqp->notify    = infy;
 8005906:	498f      	ldr	r1, [pc, #572]	@ (8005b44 <main+0x6e4>)
  obqp->bwrptr    = bp;
 8005908:	e9c3 2215 	strd	r2, r2, [r3, #84]	@ 0x54
  sdup->state = SDU_STOP;
 800590c:	2201      	movs	r2, #1
  ibqp->notify    = infy;
 800590e:	63d9      	str	r1, [r3, #60]	@ 0x3c
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8005910:	f203 418c 	addw	r1, r3, #1164	@ 0x48c
 8005914:	721a      	strb	r2, [r3, #8]
  ibqp->suspended = suspended;
 8005916:	751a      	strb	r2, [r3, #20]
  obqp->suspended = suspended;
 8005918:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
  ibqp->brdptr    = bp;
 800591c:	f103 027c 	add.w	r2, r3, #124	@ 0x7c
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8005920:	65d9      	str	r1, [r3, #92]	@ 0x5c
  ibqp->buffers   = bp;
 8005922:	631a      	str	r2, [r3, #48]	@ 0x30
  obqp->notify    = onfy;
 8005924:	4988      	ldr	r1, [pc, #544]	@ (8005b48 <main+0x6e8>)
  ibqp->bwrptr    = bp;
 8005926:	e9c3 2207 	strd	r2, r2, [r3, #28]
  ibqp->bn        = n;
 800592a:	2202      	movs	r2, #2
  obqp->notify    = onfy;
 800592c:	6759      	str	r1, [r3, #116]	@ 0x74
 800592e:	2130      	movs	r1, #48	@ 0x30
  ibqp->bn        = n;
 8005930:	62da      	str	r2, [r3, #44]	@ 0x2c
  obqp->bcounter  = n;
 8005932:	651a      	str	r2, [r3, #80]	@ 0x50
  obqp->bn        = n;
 8005934:	665a      	str	r2, [r3, #100]	@ 0x64
 8005936:	f381 8811 	msr	BASEPRI, r1
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 800593a:	7a19      	ldrb	r1, [r3, #8]
 800593c:	3901      	subs	r1, #1
 800593e:	2901      	cmp	r1, #1
 8005940:	f200 8352 	bhi.w	8005fe8 <main+0xb88>
  sdup->state = SDU_READY;
 8005944:	721a      	strb	r2, [r3, #8]
  sdup->config = config;
 8005946:	4a81      	ldr	r2, [pc, #516]	@ (8005b4c <main+0x6ec>)
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 8005948:	6333      	str	r3, [r6, #48]	@ 0x30
  usbp->out_params[config->bulk_out - 1U] = sdup;
 800594a:	6533      	str	r3, [r6, #80]	@ 0x50
    usbp->in_params[config->int_in - 1U]  = sdup;
 800594c:	6373      	str	r3, [r6, #52]	@ 0x34
  sdup->config = config;
 800594e:	f8c3 248c 	str.w	r2, [r3, #1164]	@ 0x48c
 8005952:	6823      	ldr	r3, [r4, #0]
 8005954:	42a3      	cmp	r3, r4
 8005956:	f040 8353 	bne.w	8006000 <main+0xba0>
 800595a:	2300      	movs	r3, #0
 800595c:	f383 8811 	msr	BASEPRI, r3
  chSysInit();

  // shell
  sduObjectInit(&SDU1);
  sduStart(&SDU1, &serusbcfg);
  usbDisconnectBus(serusbcfg.usbp);
 8005960:	f8d6 2090 	ldr.w	r2, [r6, #144]	@ 0x90
 8005964:	2130      	movs	r1, #48	@ 0x30
 8005966:	f8d2 3804 	ldr.w	r3, [r2, #2052]	@ 0x804
 800596a:	f043 0302 	orr.w	r3, r3, #2
 800596e:	f8c2 3804 	str.w	r3, [r2, #2052]	@ 0x804
 8005972:	f381 8811 	msr	BASEPRI, r1
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8005976:	f643 2198 	movw	r1, #15000	@ 0x3a98
 800597a:	2008      	movs	r0, #8
 800597c:	f7fc fb58 	bl	8002030 <chSchGoSleepTimeoutS>
 8005980:	6823      	ldr	r3, [r4, #0]
 8005982:	42a3      	cmp	r3, r4
 8005984:	f040 8345 	bne.w	8006012 <main+0xbb2>
 8005988:	f04f 0800 	mov.w	r8, #0
 800598c:	f388 8811 	msr	BASEPRI, r8
 8005990:	2330      	movs	r3, #48	@ 0x30
 8005992:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 8005996:	7833      	ldrb	r3, [r6, #0]
 8005998:	1e5a      	subs	r2, r3, #1
 800599a:	2a01      	cmp	r2, #1
 800599c:	f200 8340 	bhi.w	8006020 <main+0xbc0>
  usbp->config = config;
 80059a0:	4a6b      	ldr	r2, [pc, #428]	@ (8005b50 <main+0x6f0>)
    usbp->epc[i] = NULL;
 80059a2:	4641      	mov	r1, r8
 80059a4:	486b      	ldr	r0, [pc, #428]	@ (8005b54 <main+0x6f4>)
  usbp->config = config;
 80059a6:	6072      	str	r2, [r6, #4]
    usbp->epc[i] = NULL;
 80059a8:	2224      	movs	r2, #36	@ 0x24
 80059aa:	9301      	str	r3, [sp, #4]
 80059ac:	f000 fc40 	bl	8006230 <memset>
  if (usbp->state == USB_STOP) {
 80059b0:	9b01      	ldr	r3, [sp, #4]
 80059b2:	2b01      	cmp	r3, #1
 80059b4:	f000 80e0 	beq.w	8005b78 <main+0x718>
    usbp->state = USB_READY;
 80059b8:	2302      	movs	r3, #2
 80059ba:	7033      	strb	r3, [r6, #0]
 80059bc:	6823      	ldr	r3, [r4, #0]
 80059be:	42a3      	cmp	r3, r4
 80059c0:	f040 833d 	bne.w	800603e <main+0xbde>
 80059c4:	2200      	movs	r2, #0
 80059c6:	f382 8811 	msr	BASEPRI, r2
 80059ca:	4b63      	ldr	r3, [pc, #396]	@ (8005b58 <main+0x6f8>)
  chThdSleepMilliseconds(1500);
  usbStart(serusbcfg.usbp, &usbcfg);
  usbConnectBus(serusbcfg.usbp);
 80059cc:	f8d6 1090 	ldr.w	r1, [r6, #144]	@ 0x90
 80059d0:	601b      	str	r3, [r3, #0]
 80059d2:	f8d1 3804 	ldr.w	r3, [r1, #2052]	@ 0x804
 80059d6:	f023 0302 	bic.w	r3, r3, #2
 80059da:	f8c1 3804 	str.w	r3, [r1, #2052]	@ 0x804
 80059de:	2330      	movs	r3, #48	@ 0x30
 80059e0:	f383 8811 	msr	BASEPRI, r3
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
    if ((dma.allocated_mask & mask) == 0U) {
 80059e4:	f8d9 1000 	ldr.w	r1, [r9]
 80059e8:	f011 0301 	ands.w	r3, r1, #1
 80059ec:	f000 8260 	beq.w	8005eb0 <main+0xa50>
  for (i = startid; i <= endid; i++) {
 80059f0:	4613      	mov	r3, r2
    uint32_t mask = (1U << i);
 80059f2:	2001      	movs	r0, #1
 80059f4:	e004      	b.n	8005a00 <main+0x5a0>
 80059f6:	fa00 f203 	lsl.w	r2, r0, r3
    if ((dma.allocated_mask & mask) == 0U) {
 80059fa:	4211      	tst	r1, r2
 80059fc:	f000 8259 	beq.w	8005eb2 <main+0xa52>
  for (i = startid; i <= endid; i++) {
 8005a00:	3301      	adds	r3, #1
 8005a02:	2b08      	cmp	r3, #8
 8005a04:	d1f7      	bne.n	80059f6 <main+0x596>
    return NULL;
 8005a06:	2300      	movs	r3, #0
 8005a08:	6822      	ldr	r2, [r4, #0]
 8005a0a:	42a2      	cmp	r2, r4
 8005a0c:	f040 830e 	bne.w	800602c <main+0xbcc>
 8005a10:	2200      	movs	r2, #0
 8005a12:	f382 8811 	msr	BASEPRI, r2
  dma = dmaStreamAlloc(STM32_DMA_STREAM_ID_ANY_DMA1, 10, NULL, NULL);
 8005a16:	f8df c144 	ldr.w	ip, [pc, #324]	@ 8005b5c <main+0x6fc>
  dmaStreamSetPeripheral(dma, &(WS2812_PWM_DRIVER.tim->CCR[WS2812_PWM_TIM_CHANNEL]));
 8005a1a:	69e9      	ldr	r1, [r5, #28]
 8005a1c:	689e      	ldr	r6, [r3, #8]
 8005a1e:	f101 0034 	add.w	r0, r1, #52	@ 0x34
  dma = dmaStreamAlloc(STM32_DMA_STREAM_ID_ANY_DMA1, 10, NULL, NULL);
 8005a22:	f8cc 3000 	str.w	r3, [ip]
  dmaStreamSetPeripheral(dma, &(WS2812_PWM_DRIVER.tim->CCR[WS2812_PWM_TIM_CHANNEL]));
 8005a26:	6819      	ldr	r1, [r3, #0]
 */
void dmaSetRequestSource(const stm32_dma_stream_t *dmastp, uint32_t per) {

  osalDbgCheck(per < 256U);

  dmastp->mux->CCR = per;
 8005a28:	233b      	movs	r3, #59	@ 0x3b
 8005a2a:	6033      	str	r3, [r6, #0]
  dmaStreamSetMemory0(dma, ws2812_frame_buffer_dma);
 8005a2c:	4b4c      	ldr	r3, [pc, #304]	@ (8005b60 <main+0x700>)
  dmaStreamSetPeripheral(dma, &(WS2812_PWM_DRIVER.tim->CCR[WS2812_PWM_TIM_CHANNEL]));
 8005a2e:	6088      	str	r0, [r1, #8]
  dmaStreamSetMemory0(dma, ws2812_frame_buffer_dma);
 8005a30:	60cb      	str	r3, [r1, #12]
  dmaStreamSetTransactionSize(dma, WS2812_BUFFER_SIZE_DMA);
 8005a32:	f641 0332 	movw	r3, #6194	@ 0x1832
 8005a36:	604b      	str	r3, [r1, #4]
  dmaStreamSetMode(dma,
 8005a38:	4b4a      	ldr	r3, [pc, #296]	@ (8005b64 <main+0x704>)
 8005a3a:	600b      	str	r3, [r1, #0]
 8005a3c:	2330      	movs	r3, #48	@ 0x30
 8005a3e:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 8005a42:	7829      	ldrb	r1, [r5, #0]
 8005a44:	1e4b      	subs	r3, r1, #1
 8005a46:	2b01      	cmp	r3, #1
 8005a48:	f200 82ed 	bhi.w	8006026 <main+0xbc6>
                "invalid state");

  pwmp->config = config;
 8005a4c:	4b46      	ldr	r3, [pc, #280]	@ (8005b68 <main+0x708>)
  if (pwmp->state == PWM_STOP) {
 8005a4e:	2901      	cmp	r1, #1
  pwmp->period = config->period;
  pwmp->enabled = 0U;
 8005a50:	60ea      	str	r2, [r5, #12]
  pwmp->config = config;
 8005a52:	606b      	str	r3, [r5, #4]
  pwmp->period = config->period;
 8005a54:	f04f 0305 	mov.w	r3, #5
 8005a58:	60ab      	str	r3, [r5, #8]
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8005a5a:	69eb      	ldr	r3, [r5, #28]
  if (pwmp->state == PWM_STOP) {
 8005a5c:	f000 8261 	beq.w	8005f22 <main+0xac2>
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 8005a60:	601a      	str	r2, [r3, #0]
    if (pwmp->channels > 4) {
 8005a62:	7c29      	ldrb	r1, [r5, #16]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8005a64:	635a      	str	r2, [r3, #52]	@ 0x34
    if (pwmp->channels > 4) {
 8005a66:	2904      	cmp	r1, #4
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8005a68:	639a      	str	r2, [r3, #56]	@ 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 8005a6a:	63da      	str	r2, [r3, #60]	@ 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 8005a6c:	641a      	str	r2, [r3, #64]	@ 0x40
    if (pwmp->channels > 4) {
 8005a6e:	d901      	bls.n	8005a74 <main+0x614>
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
 8005a70:	659a      	str	r2, [r3, #88]	@ 0x58
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
 8005a72:	65da      	str	r2, [r3, #92]	@ 0x5c
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8005a74:	2200      	movs	r2, #0
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8005a76:	6968      	ldr	r0, [r5, #20]
 8005a78:	4e3c      	ldr	r6, [pc, #240]	@ (8005b6c <main+0x70c>)
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8005a7a:	625a      	str	r2, [r3, #36]	@ 0x24
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8005a7c:	fbb0 f2f6 	udiv	r2, r0, r6
 8005a80:	1e51      	subs	r1, r2, #1
  osalDbgAssert((psc <= 0xFFFF) &&
 8005a82:	f5b1 3f80 	cmp.w	r1, #65536	@ 0x10000
 8005a86:	f080 8290 	bcs.w	8005faa <main+0xb4a>
 8005a8a:	fb06 f202 	mul.w	r2, r6, r2
 8005a8e:	4290      	cmp	r0, r2
 8005a90:	f040 828b 	bne.w	8005faa <main+0xb4a>
  pwmp->tim->PSC  = psc;
 8005a94:	6299      	str	r1, [r3, #40]	@ 0x28
  pwmp->tim->CR2  = pwmp->config->cr2;
 8005a96:	2200      	movs	r2, #0
  pwmp->tim->CCER  = ccer;
 8005a98:	2101      	movs	r1, #1
  pwmp->tim->ARR  = pwmp->period - 1;
 8005a9a:	2604      	movs	r6, #4
  if (pwmp->has_bdtr) {
 8005a9c:	7e28      	ldrb	r0, [r5, #24]
  pwmp->tim->ARR  = pwmp->period - 1;
 8005a9e:	62de      	str	r6, [r3, #44]	@ 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 8005aa0:	605a      	str	r2, [r3, #4]
  pwmp->tim->CCER  = ccer;
 8005aa2:	6219      	str	r1, [r3, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8005aa4:	6159      	str	r1, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8005aa6:	611a      	str	r2, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8005aa8:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8005aac:	60da      	str	r2, [r3, #12]
  if (pwmp->has_bdtr) {
 8005aae:	b110      	cbz	r0, 8005ab6 <main+0x656>
    pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
 8005ab0:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 8005ab4:	645a      	str	r2, [r3, #68]	@ 0x44
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8005ab6:	2285      	movs	r2, #133	@ 0x85
 8005ab8:	2630      	movs	r6, #48	@ 0x30
 8005aba:	601a      	str	r2, [r3, #0]
#else
  pwm_lld_start(pwmp);
  msg = HAL_RET_SUCCESS;
#endif
  if (msg == HAL_RET_SUCCESS) {
    pwmp->state = PWM_READY;
 8005abc:	2302      	movs	r3, #2
 8005abe:	702b      	strb	r3, [r5, #0]
  chSysUnlock();
 8005ac0:	f7fb f9e6 	bl	8000e90 <chSysUnlock.lto_priv.1>
 8005ac4:	f386 8811 	msr	BASEPRI, r6

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8005ac8:	782b      	ldrb	r3, [r5, #0]
 8005aca:	2b02      	cmp	r3, #2
 8005acc:	f040 82c7 	bne.w	800605e <main+0xbfe>

  pwmEnableChannelI(pwmp, channel, width);
 8005ad0:	68eb      	ldr	r3, [r5, #12]
 8005ad2:	f043 0301 	orr.w	r3, r3, #1
 8005ad6:	60eb      	str	r3, [r5, #12]
    pwmp->tim->CCR[channel] = width;
 8005ad8:	69eb      	ldr	r3, [r5, #28]
 8005ada:	2500      	movs	r5, #0
 8005adc:	635d      	str	r5, [r3, #52]	@ 0x34
 8005ade:	f7fb f9d7 	bl	8000e90 <chSysUnlock.lto_priv.1>
    ws2812_frame_buffer_dma[i] = 0;
 8005ae2:	4629      	mov	r1, r5
 8005ae4:	f246 02c8 	movw	r2, #24776	@ 0x60c8
 8005ae8:	481d      	ldr	r0, [pc, #116]	@ (8005b60 <main+0x700>)
 8005aea:	f000 fba1 	bl	8006230 <memset>
 8005aee:	f386 8811 	msr	BASEPRI, r6
  p = (uint8_t *)REG_HEADER(currcore)->next;
 8005af2:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8005af4:	6822      	ldr	r2, [r4, #0]
  tp->refs++;
 8005af6:	7d83      	ldrb	r3, [r0, #22]
  tp = threadref((p - __CH_OFFSETOF(thread_t, rqueue)));
 8005af8:	3810      	subs	r0, #16
 8005afa:	42a2      	cmp	r2, r4
  tp->refs++;
 8005afc:	f103 0301 	add.w	r3, r3, #1
 8005b00:	f880 3026 	strb.w	r3, [r0, #38]	@ 0x26
 8005b04:	f040 82b5 	bne.w	8006072 <main+0xc12>
 8005b08:	2300      	movs	r3, #0
 8005b0a:	f383 8811 	msr	BASEPRI, r3
  return tp;
 8005b0e:	4d18      	ldr	r5, [pc, #96]	@ (8005b70 <main+0x710>)
 8005b10:	e004      	b.n	8005b1c <main+0x6bc>
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
 8005b12:	f7ff fb6d 	bl	80051f0 <chRegNextThread>
  } while (ctp != NULL);
 8005b16:	2800      	cmp	r0, #0
 8005b18:	f000 80a0 	beq.w	8005c5c <main+0x7fc>
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8005b1c:	6a03      	ldr	r3, [r0, #32]
 8005b1e:	42ab      	cmp	r3, r5
 8005b20:	d1f7      	bne.n	8005b12 <main+0x6b2>
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8005b22:	4814      	ldr	r0, [pc, #80]	@ (8005b74 <main+0x714>)
 8005b24:	f7fb f914 	bl	8000d50 <chSysHalt>
 8005b28:	24006220 	.word	0x24006220
 8005b2c:	24006e48 	.word	0x24006e48
 8005b30:	08006e34 	.word	0x08006e34
 8005b34:	08006c34 	.word	0x08006c34
 8005b38:	08000ab1 	.word	0x08000ab1
 8005b3c:	24006778 	.word	0x24006778
 8005b40:	08006e80 	.word	0x08006e80
 8005b44:	08000f31 	.word	0x08000f31
 8005b48:	08000fa1 	.word	0x08000fa1
 8005b4c:	080070ac 	.word	0x080070ac
 8005b50:	0800709c 	.word	0x0800709c
 8005b54:	24006c48 	.word	0x24006c48
 8005b58:	24006c24 	.word	0x24006c24
 8005b5c:	24006770 	.word	0x24006770
 8005b60:	24000150 	.word	0x24000150
 8005b64:	00035440 	.word	0x00035440
 8005b68:	08007014 	.word	0x08007014
 8005b6c:	003d0900 	.word	0x003d0900
 8005b70:	24006600 	.word	0x24006600
 8005b74:	0800705c 	.word	0x0800705c
  RCC_C1->AHB1ENR |= mask;
 8005b78:	4bbe      	ldr	r3, [pc, #760]	@ (8005e74 <main+0xa14>)
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005b7a:	f44f 5c00 	mov.w	ip, #8192	@ 0x2000
  stm32_otg_t *otgp = usbp->otg;
 8005b7e:	f8d6 0090 	ldr.w	r0, [r6, #144]	@ 0x90
 8005b82:	f8d3 10d8 	ldr.w	r1, [r3, #216]	@ 0xd8
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8005b86:	4abc      	ldr	r2, [pc, #752]	@ (8005e78 <main+0xa18>)
 8005b88:	f041 7100 	orr.w	r1, r1, #33554432	@ 0x2000000
 8005b8c:	f8c3 10d8 	str.w	r1, [r3, #216]	@ 0xd8
    RCC_C1->AHB1LPENR |= mask;
 8005b90:	f8d3 1100 	ldr.w	r1, [r3, #256]	@ 0x100
 8005b94:	f041 7100 	orr.w	r1, r1, #33554432	@ 0x2000000
 8005b98:	f8c3 1100 	str.w	r1, [r3, #256]	@ 0x100
  (void)RCC_C1->AHB1LPENR;
 8005b9c:	f8d3 1100 	ldr.w	r1, [r3, #256]	@ 0x100
  RCC->AHB1RSTR |= mask;
 8005ba0:	f8d3 1080 	ldr.w	r1, [r3, #128]	@ 0x80
 8005ba4:	f041 7100 	orr.w	r1, r1, #33554432	@ 0x2000000
 8005ba8:	f8c3 1080 	str.w	r1, [r3, #128]	@ 0x80
  RCC->AHB1RSTR &= ~mask;
 8005bac:	f8d3 1080 	ldr.w	r1, [r3, #128]	@ 0x80
 8005bb0:	f021 7100 	bic.w	r1, r1, #33554432	@ 0x2000000
 8005bb4:	f8c3 1080 	str.w	r1, [r3, #128]	@ 0x80
  (void)RCC->AHB1RSTR;
 8005bb8:	f8d3 1080 	ldr.w	r1, [r3, #128]	@ 0x80
  RCC_C1->AHB1ENR &= ~mask;
 8005bbc:	f8d3 10d8 	ldr.w	r1, [r3, #216]	@ 0xd8
 8005bc0:	f021 6180 	bic.w	r1, r1, #67108864	@ 0x4000000
 8005bc4:	f8c3 10d8 	str.w	r1, [r3, #216]	@ 0xd8
  RCC_C1->AHB1LPENR &= ~mask;
 8005bc8:	f8d3 1100 	ldr.w	r1, [r3, #256]	@ 0x100
 8005bcc:	f021 6180 	bic.w	r1, r1, #67108864	@ 0x4000000
 8005bd0:	f8c3 1100 	str.w	r1, [r3, #256]	@ 0x100
  (void)RCC_C1->AHB1LPENR;
 8005bd4:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
 8005bd8:	23e0      	movs	r3, #224	@ 0xe0
 8005bda:	f882 334d 	strb.w	r3, [r2, #845]	@ 0x34d
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8005bde:	4ba7      	ldr	r3, [pc, #668]	@ (8005e7c <main+0xa1c>)
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005be0:	f8c2 c188 	str.w	ip, [r2, #392]	@ 0x188
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005be4:	f8c2 c008 	str.w	ip, [r2, #8]
 8005be8:	60c3      	str	r3, [r0, #12]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8005bea:	4ba5      	ldr	r3, [pc, #660]	@ (8005e80 <main+0xa20>)
 8005bec:	f8c0 3800 	str.w	r3, [r0, #2048]	@ 0x800
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8005bf0:	23c0      	movs	r3, #192	@ 0xc0
    otgp->PCGCCTL = 0;
 8005bf2:	f8c0 8e00 	str.w	r8, [r0, #3584]	@ 0xe00
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8005bf6:	6003      	str	r3, [r0, #0]
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8005bf8:	f44f 1304 	mov.w	r3, #2162688	@ 0x210000
 8005bfc:	6383      	str	r3, [r0, #56]	@ 0x38
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8005bfe:	6903      	ldr	r3, [r0, #16]
 8005c00:	2b00      	cmp	r3, #0
 8005c02:	dafc      	bge.n	8005bfe <main+0x79e>
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8005c04:	2301      	movs	r3, #1
 8005c06:	4a9f      	ldr	r2, [pc, #636]	@ (8005e84 <main+0xa24>)
 8005c08:	6103      	str	r3, [r0, #16]
 8005c0a:	6851      	ldr	r1, [r2, #4]
 8005c0c:	6853      	ldr	r3, [r2, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8005c0e:	1a5b      	subs	r3, r3, r1
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8005c10:	2b0b      	cmp	r3, #11
 8005c12:	d9fb      	bls.n	8005c0c <main+0x7ac>
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8005c14:	6903      	ldr	r3, [r0, #16]
 8005c16:	07db      	lsls	r3, r3, #31
 8005c18:	d4fc      	bmi.n	8005c14 <main+0x7b4>
 8005c1a:	4a9a      	ldr	r2, [pc, #616]	@ (8005e84 <main+0xa24>)
 8005c1c:	6851      	ldr	r1, [r2, #4]
 8005c1e:	6853      	ldr	r3, [r2, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8005c20:	1a5b      	subs	r3, r3, r1
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8005c22:	2b11      	cmp	r3, #17
 8005c24:	d9fb      	bls.n	8005c1e <main+0x7be>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8005c26:	6903      	ldr	r3, [r0, #16]
 8005c28:	2b00      	cmp	r3, #0
 8005c2a:	dafc      	bge.n	8005c26 <main+0x7c6>
    otgp->GAHBCFG = 0;
 8005c2c:	f04f 0800 	mov.w	r8, #0
    otg_disable_ep(usbp);
 8005c30:	f8d6 1094 	ldr.w	r1, [r6, #148]	@ 0x94
    otgp->GAHBCFG = 0;
 8005c34:	f8c0 8008 	str.w	r8, [r0, #8]
    otg_disable_ep(usbp);
 8005c38:	f7fb f8ba 	bl	8000db0 <otg_disable_ep.isra.0>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8005c3c:	4b92      	ldr	r3, [pc, #584]	@ (8005e88 <main+0xa28>)
    otgp->DIEPMSK  = 0;
 8005c3e:	f8c0 8810 	str.w	r8, [r0, #2064]	@ 0x810
    otgp->DOEPMSK  = 0;
 8005c42:	f8c0 8814 	str.w	r8, [r0, #2068]	@ 0x814
    otgp->DAINTMSK = 0;
 8005c46:	f8c0 881c 	str.w	r8, [r0, #2076]	@ 0x81c
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8005c4a:	6183      	str	r3, [r0, #24]
    otgp->GINTSTS  = 0xFFFFFFFF;
 8005c4c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8005c50:	6143      	str	r3, [r0, #20]
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8005c52:	6883      	ldr	r3, [r0, #8]
 8005c54:	f043 0301 	orr.w	r3, r3, #1
 8005c58:	6083      	str	r3, [r0, #8]
 8005c5a:	e6ad      	b.n	80059b8 <main+0x558>
 8005c5c:	2330      	movs	r3, #48	@ 0x30
 8005c5e:	f383 8811 	msr	BASEPRI, r3
  tp->refs              = (trefs_t)1;
 8005c62:	2301      	movs	r3, #1
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005c64:	4989      	ldr	r1, [pc, #548]	@ (8005e8c <main+0xa2c>)
 8005c66:	f8c5 0108 	str.w	r0, [r5, #264]	@ 0x108
  tp->refs              = (trefs_t)1;
 8005c6a:	f885 314e 	strb.w	r3, [r5, #334]	@ 0x14e
  tp->name              = name;
 8005c6e:	4b88      	ldr	r3, [pc, #544]	@ (8005e90 <main+0xa30>)
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005c70:	f8c5 1104 	str.w	r1, [r5, #260]	@ 0x104
  tp->name              = name;
 8005c74:	f8c5 3144 	str.w	r3, [r5, #324]	@ 0x144
  tp->hdr.pqueue.prio   = prio;
 8005c78:	2381      	movs	r3, #129	@ 0x81
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005c7a:	4986      	ldr	r1, [pc, #536]	@ (8005e94 <main+0xa34>)
  p->prev       = qp->prev;
 8005c7c:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
  tp->hdr.pqueue.prio   = prio;
 8005c7e:	f8c5 3130 	str.w	r3, [r5, #304]	@ 0x130
  tp->realprio          = prio;
 8005c82:	f8c5 3168 	str.w	r3, [r5, #360]	@ 0x168
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005c86:	f8c5 1124 	str.w	r1, [r5, #292]	@ 0x124
  tp->state             = CH_STATE_WTSTART;
 8005c8a:	2102      	movs	r1, #2
  p->next       = qp;
 8005c8c:	f8c5 b138 	str.w	fp, [r5, #312]	@ 0x138
  tp->wabase = (stkalign_t *)wsp;
 8005c90:	f8c5 5148 	str.w	r5, [r5, #328]	@ 0x148
  tp->owner             = oip;
 8005c94:	f8c5 4140 	str.w	r4, [r5, #320]	@ 0x140
  p->prev       = qp->prev;
 8005c98:	f8c5 213c 	str.w	r2, [r5, #316]	@ 0x13c
  tp->state             = CH_STATE_WTSTART;
 8005c9c:	f8a5 114c 	strh.w	r1, [r5, #332]	@ 0x14c
  tp->epending          = (eventmask_t)0;
 8005ca0:	e9c5 0058 	strd	r0, r0, [r5, #352]	@ 0x160
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005ca4:	487c      	ldr	r0, [pc, #496]	@ (8005e98 <main+0xa38>)
  p->prev->next = p;
 8005ca6:	f100 0334 	add.w	r3, r0, #52	@ 0x34
 8005caa:	f8c5 0134 	str.w	r0, [r5, #308]	@ 0x134
 8005cae:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
 8005cb0:	62e3      	str	r3, [r4, #44]	@ 0x2c
  qp->next = qp;
 8005cb2:	f100 0354 	add.w	r3, r0, #84	@ 0x54
  qp->prev = qp;
 8005cb6:	e9c5 3356 	strd	r3, r3, [r5, #344]	@ 0x158
  lp->next = lp;
 8005cba:	f100 0350 	add.w	r3, r0, #80	@ 0x50
  chSchWakeupS(tp, MSG_OK);
 8005cbe:	3024      	adds	r0, #36	@ 0x24
 8005cc0:	f8c5 3154 	str.w	r3, [r5, #340]	@ 0x154
 8005cc4:	f7fc fd94 	bl	80027f0 <chSchWakeupS.constprop.0>
 8005cc8:	6823      	ldr	r3, [r4, #0]
 8005cca:	42a3      	cmp	r3, r4
 8005ccc:	f040 81ca 	bne.w	8006064 <main+0xc04>
 8005cd0:	2300      	movs	r3, #0
 8005cd2:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(mp);
 8005cd6:	4d71      	ldr	r5, [pc, #452]	@ (8005e9c <main+0xa3c>)
  if (wbase == NULL) {
    return NULL;
  }
  wend = (void *)((uint8_t *)wbase + size);

  thread_descriptor_t td = THD_DESCRIPTOR(name, wbase, wend, prio, pf, arg);
 8005cd8:	f8df 81c4 	ldr.w	r8, [pc, #452]	@ 8005ea0 <main+0xa40>
 8005cdc:	f8df b1c4 	ldr.w	fp, [pc, #452]	@ 8005ea4 <main+0xa44>
 8005ce0:	2330      	movs	r3, #48	@ 0x30
 8005ce2:	f383 8811 	msr	BASEPRI, r3
 8005ce6:	4628      	mov	r0, r5
 8005ce8:	f7fc fd12 	bl	8002710 <chMtxLockS>
 8005cec:	6823      	ldr	r3, [r4, #0]
 8005cee:	42a3      	cmp	r3, r4
 8005cf0:	f040 8152 	bne.w	8005f98 <main+0xb38>
 8005cf4:	2300      	movs	r3, #0
 8005cf6:	f383 8811 	msr	BASEPRI, r3
  while (H_NEXT(qp) != NULL) {
 8005cfa:	687a      	ldr	r2, [r7, #4]
 8005cfc:	b1ca      	cbz	r2, 8005d32 <main+0x8d2>
  qp = &heapp->header;
 8005cfe:	486a      	ldr	r0, [pc, #424]	@ (8005ea8 <main+0xa48>)
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005d00:	f640 0ce8 	movw	ip, #2280	@ 0x8e8
 8005d04:	e000      	b.n	8005d08 <main+0x8a8>
 8005d06:	461a      	mov	r2, r3
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8005d08:	f102 030f 	add.w	r3, r2, #15
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005d0c:	6856      	ldr	r6, [r2, #4]
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8005d0e:	f023 0307 	bic.w	r3, r3, #7
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005d12:	1c71      	adds	r1, r6, #1
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8005d14:	f1a3 0908 	sub.w	r9, r3, #8
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005d18:	eb02 0ac1 	add.w	sl, r2, r1, lsl #3
 8005d1c:	00c9      	lsls	r1, r1, #3
 8005d1e:	45d1      	cmp	r9, sl
 8005d20:	d203      	bcs.n	8005d2a <main+0x8ca>
 8005d22:	ebaa 0a03 	sub.w	sl, sl, r3
 8005d26:	45e2      	cmp	sl, ip
 8005d28:	d87f      	bhi.n	8005e2a <main+0x9ca>
  while (H_NEXT(qp) != NULL) {
 8005d2a:	6813      	ldr	r3, [r2, #0]
 8005d2c:	4610      	mov	r0, r2
 8005d2e:	2b00      	cmp	r3, #0
 8005d30:	d1e9      	bne.n	8005d06 <main+0x8a6>
  H_UNLOCK(heapp);
 8005d32:	4628      	mov	r0, r5
 8005d34:	f7ff f96c 	bl	8005010 <chMtxUnlock>
  if (heapp->provider != NULL) {
 8005d38:	683b      	ldr	r3, [r7, #0]
 8005d3a:	2b00      	cmp	r3, #0
 8005d3c:	f000 80eb 	beq.w	8005f16 <main+0xab6>
    ahp = heapp->provider(pages * CH_HEAP_ALIGNMENT,
 8005d40:	2208      	movs	r2, #8
 8005d42:	f44f 600f 	mov.w	r0, #2288	@ 0x8f0
 8005d46:	4611      	mov	r1, r2
 8005d48:	4798      	blx	r3
    if (ahp != NULL) {
 8005d4a:	4681      	mov	r9, r0
 8005d4c:	2800      	cmp	r0, #0
 8005d4e:	f000 80e2 	beq.w	8005f16 <main+0xab6>
      H_SIZE(hp) = size;
 8005d52:	f44f 630f 	mov.w	r3, #2288	@ 0x8f0
      H_HEAP(hp) = heapp;
 8005d56:	f840 7c08 	str.w	r7, [r0, #-8]
      H_SIZE(hp) = size;
 8005d5a:	f840 3c04 	str.w	r3, [r0, #-4]
  wend = (void *)((uint8_t *)wbase + size);
 8005d5e:	f509 630f 	add.w	r3, r9, #2288	@ 0x8f0
  thread_descriptor_t td = THD_DESCRIPTOR(name, wbase, wend, prio, pf, arg);
 8005d62:	f8cd b018 	str.w	fp, [sp, #24]
 8005d66:	9304      	str	r3, [sp, #16]
 8005d68:	2381      	movs	r3, #129	@ 0x81
 8005d6a:	9305      	str	r3, [sp, #20]
 8005d6c:	4b4f      	ldr	r3, [pc, #316]	@ (8005eac <main+0xa4c>)
 8005d6e:	e9cd 8902 	strd	r8, r9, [sp, #8]
 8005d72:	9307      	str	r3, [sp, #28]
 8005d74:	2330      	movs	r3, #48	@ 0x30
 8005d76:	f383 8811 	msr	BASEPRI, r3
#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wbase, (uint8_t *)wend);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8005d7a:	a802      	add	r0, sp, #8
 8005d7c:	f7fa fea0 	bl	8000ac0 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 8005d80:	2301      	movs	r3, #1
  tp = chThdCreateSuspendedI(&td);
 8005d82:	4681      	mov	r9, r0
  tp->flags = CH_FLAG_MODE_HEAP;
 8005d84:	f880 3025 	strb.w	r3, [r0, #37]	@ 0x25
  chSchWakeupS(tp, MSG_OK);
 8005d88:	f7fc fd32 	bl	80027f0 <chSchWakeupS.constprop.0>
 8005d8c:	6823      	ldr	r3, [r4, #0]
 8005d8e:	42a3      	cmp	r3, r4
 8005d90:	f040 811a 	bne.w	8005fc8 <main+0xb68>
 8005d94:	2300      	movs	r3, #0
 8005d96:	f383 8811 	msr	BASEPRI, r3
  return __sch_get_currthread();
 8005d9a:	68e3      	ldr	r3, [r4, #12]
 8005d9c:	2230      	movs	r2, #48	@ 0x30
 8005d9e:	f382 8811 	msr	BASEPRI, r2
  chDbgAssert(tp != currtp, "waiting self");
 8005da2:	454b      	cmp	r3, r9
 8005da4:	f000 80ba 	beq.w	8005f1c <main+0xabc>
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
 8005da8:	f899 2026 	ldrb.w	r2, [r9, #38]	@ 0x26
 8005dac:	2a00      	cmp	r2, #0
 8005dae:	f000 80b5 	beq.w	8005f1c <main+0xabc>
  if (likely(tp->state != CH_STATE_FINAL)) {
 8005db2:	f899 2024 	ldrb.w	r2, [r9, #36]	@ 0x24
 8005db6:	2a0f      	cmp	r2, #15
 8005db8:	d007      	beq.n	8005dca <main+0x96a>
  p->next = lp->next;
 8005dba:	f8d9 202c 	ldr.w	r2, [r9, #44]	@ 0x2c
    chSchGoSleepS(CH_STATE_WTEXIT);
 8005dbe:	2009      	movs	r0, #9
 8005dc0:	601a      	str	r2, [r3, #0]
  lp->next = p;
 8005dc2:	f8c9 302c 	str.w	r3, [r9, #44]	@ 0x2c
 8005dc6:	f7fc f8f3 	bl	8001fb0 <chSchGoSleepS>
 8005dca:	6823      	ldr	r3, [r4, #0]
 8005dcc:	42a3      	cmp	r3, r4
 8005dce:	f040 80f2 	bne.w	8005fb6 <main+0xb56>
 8005dd2:	2300      	movs	r3, #0
 8005dd4:	f383 8811 	msr	BASEPRI, r3
 8005dd8:	2330      	movs	r3, #48	@ 0x30
 8005dda:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8005dde:	f899 3026 	ldrb.w	r3, [r9, #38]	@ 0x26
 8005de2:	2b00      	cmp	r3, #0
 8005de4:	f000 80e4 	beq.w	8005fb0 <main+0xb50>
  tp->refs--;
 8005de8:	3b01      	subs	r3, #1
 8005dea:	f889 3026 	strb.w	r3, [r9, #38]	@ 0x26
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8005dee:	f8d9 3024 	ldr.w	r3, [r9, #36]	@ 0x24
 8005df2:	f003 13ff 	and.w	r3, r3, #16711935	@ 0xff00ff
 8005df6:	2b0f      	cmp	r3, #15
 8005df8:	f000 80ca 	beq.w	8005f90 <main+0xb30>
 8005dfc:	6823      	ldr	r3, [r4, #0]
 8005dfe:	42a3      	cmp	r3, r4
 8005e00:	f040 8126 	bne.w	8006050 <main+0xbf0>
 8005e04:	2300      	movs	r3, #0
 8005e06:	f383 8811 	msr	BASEPRI, r3
 8005e0a:	2330      	movs	r3, #48	@ 0x30
 8005e0c:	f383 8811 	msr	BASEPRI, r3
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8005e10:	f241 3188 	movw	r1, #5000	@ 0x1388
 8005e14:	2008      	movs	r0, #8
 8005e16:	f7fc f90b 	bl	8002030 <chSchGoSleepTimeoutS>
 8005e1a:	6823      	ldr	r3, [r4, #0]
 8005e1c:	42a3      	cmp	r3, r4
 8005e1e:	f040 80dc 	bne.w	8005fda <main+0xb7a>
 8005e22:	2300      	movs	r3, #0
 8005e24:	f383 8811 	msr	BASEPRI, r3
}
 8005e28:	e75a      	b.n	8005ce0 <main+0x880>
      if (ahp > hp) {
 8005e2a:	454a      	cmp	r2, r9
 8005e2c:	f080 80a0 	bcs.w	8005f70 <main+0xb10>
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8005e30:	f102 0108 	add.w	r1, r2, #8
        if (bpages > pages) {
 8005e34:	f5ba 6f0f 	cmp.w	sl, #2288	@ 0x8f0
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8005e38:	eba9 0101 	sub.w	r1, r9, r1
 8005e3c:	ea4f 01e1 	mov.w	r1, r1, asr #3
 8005e40:	6051      	str	r1, [r2, #4]
        if (bpages > pages) {
 8005e42:	d90c      	bls.n	8005e5e <main+0x9fe>
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005e44:	ea4f 01ea 	mov.w	r1, sl, asr #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 8005e48:	f46f 708f 	mvn.w	r0, #286	@ 0x11e
          fp = H_BLOCK(ahp) + pages;
 8005e4c:	f503 630f 	add.w	r3, r3, #2288	@ 0x8f0
          H_PAGES(fp) = (bpages - pages) - 1U;
 8005e50:	4401      	add	r1, r0
 8005e52:	f8c9 18fc 	str.w	r1, [r9, #2300]	@ 0x8fc
          H_NEXT(fp) = H_NEXT(hp);
 8005e56:	6811      	ldr	r1, [r2, #0]
 8005e58:	f8c9 18f8 	str.w	r1, [r9, #2296]	@ 0x8f8
          H_NEXT(hp) = fp;
 8005e5c:	6013      	str	r3, [r2, #0]
      H_SIZE(hp) = size;
 8005e5e:	f44f 630f 	mov.w	r3, #2288	@ 0x8f0
      H_UNLOCK(heapp);
 8005e62:	4628      	mov	r0, r5
      H_SIZE(hp) = size;
 8005e64:	f8c9 3004 	str.w	r3, [r9, #4]
      H_HEAP(hp) = heapp;
 8005e68:	f849 7b08 	str.w	r7, [r9], #8
      H_UNLOCK(heapp);
 8005e6c:	f7ff f8d0 	bl	8005010 <chMtxUnlock>
 8005e70:	e775      	b.n	8005d5e <main+0x8fe>
 8005e72:	bf00      	nop
 8005e74:	58024400 	.word	0x58024400
 8005e78:	e000e100 	.word	0xe000e100
 8005e7c:	40001440 	.word	0x40001440
 8005e80:	02200003 	.word	0x02200003
 8005e84:	e0001000 	.word	0xe0001000
 8005e88:	c0303c08 	.word	0xc0303c08
 8005e8c:	08002651 	.word	0x08002651
 8005e90:	08006c3c 	.word	0x08006c3c
 8005e94:	080003f1 	.word	0x080003f1
 8005e98:	24006704 	.word	0x24006704
 8005e9c:	24006c14 	.word	0x24006c14
 8005ea0:	08006ac0 	.word	0x08006ac0
 8005ea4:	08002ee1 	.word	0x08002ee1
 8005ea8:	24006c0c 	.word	0x24006c0c
 8005eac:	08007088 	.word	0x08007088
    uint32_t mask = (1U << i);
 8005eb0:	2201      	movs	r2, #1
      dma.allocated_mask  |= mask;
 8005eb2:	4311      	orrs	r1, r2
  RCC_C1->AHB1ENR |= mask;
 8005eb4:	4a73      	ldr	r2, [pc, #460]	@ (8006084 <main+0xc24>)
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8005eb6:	0118      	lsls	r0, r3, #4
      dma.allocated_mask  |= mask;
 8005eb8:	f8c9 1000 	str.w	r1, [r9]
      dma.streams[i].func  = func;
 8005ebc:	eb09 09c3 	add.w	r9, r9, r3, lsl #3
 8005ec0:	2100      	movs	r1, #0
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8005ec2:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
      dma.streams[i].param = param;
 8005ec6:	e9c9 1101 	strd	r1, r1, [r9, #4]
 8005eca:	f8d2 10d8 	ldr.w	r1, [r2, #216]	@ 0xd8
 8005ece:	f041 0101 	orr.w	r1, r1, #1
 8005ed2:	f8c2 10d8 	str.w	r1, [r2, #216]	@ 0xd8
    RCC_C1->AHB1LPENR |= mask;
 8005ed6:	f8d2 1100 	ldr.w	r1, [r2, #256]	@ 0x100
 8005eda:	f041 0101 	orr.w	r1, r1, #1
 8005ede:	f8c2 1100 	str.w	r1, [r2, #256]	@ 0x100
      dmaStreamDisable(dmastp);
 8005ee2:	f85a 1000 	ldr.w	r1, [sl, r0]
  (void)RCC_C1->AHB1LPENR;
 8005ee6:	f8d2 2100 	ldr.w	r2, [r2, #256]	@ 0x100
 8005eea:	680a      	ldr	r2, [r1, #0]
 8005eec:	f022 021f 	bic.w	r2, r2, #31
 8005ef0:	600a      	str	r2, [r1, #0]
 8005ef2:	680a      	ldr	r2, [r1, #0]
 8005ef4:	f012 0201 	ands.w	r2, r2, #1
 8005ef8:	d1fb      	bne.n	8005ef2 <main+0xa92>
 8005efa:	4482      	add	sl, r0
 8005efc:	203d      	movs	r0, #61	@ 0x3d
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8005efe:	2621      	movs	r6, #33	@ 0x21
      dmaStreamDisable(dmastp);
 8005f00:	f89a c00c 	ldrb.w	ip, [sl, #12]
 8005f04:	fa00 f00c 	lsl.w	r0, r0, ip
 8005f08:	f8da c004 	ldr.w	ip, [sl, #4]
 8005f0c:	f8cc 0000 	str.w	r0, [ip]
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8005f10:	600a      	str	r2, [r1, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8005f12:	614e      	str	r6, [r1, #20]
      return dmastp;
 8005f14:	e578      	b.n	8005a08 <main+0x5a8>
    return NULL;
 8005f16:	f04f 0900 	mov.w	r9, #0
 8005f1a:	e73e      	b.n	8005d9a <main+0x93a>
  chDbgAssert(tp != currtp, "waiting self");
 8005f1c:	485a      	ldr	r0, [pc, #360]	@ (8006088 <main+0xc28>)
 8005f1e:	f7fa ff17 	bl	8000d50 <chSysHalt>
  RCC_C1->APB1LENR |= mask;
 8005f22:	4a58      	ldr	r2, [pc, #352]	@ (8006084 <main+0xc24>)
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8005f24:	f646 0068 	movw	r0, #26728	@ 0x6868
      pwmp->clock = STM32_TIMCLK1;
 8005f28:	4958      	ldr	r1, [pc, #352]	@ (800608c <main+0xc2c>)
 8005f2a:	6169      	str	r1, [r5, #20]
 8005f2c:	f8d2 10e8 	ldr.w	r1, [r2, #232]	@ 0xe8
 8005f30:	f041 0108 	orr.w	r1, r1, #8
 8005f34:	f8c2 10e8 	str.w	r1, [r2, #232]	@ 0xe8
    RCC_C1->APB1LLPENR |= mask;
 8005f38:	f8d2 1110 	ldr.w	r1, [r2, #272]	@ 0x110
 8005f3c:	f041 0108 	orr.w	r1, r1, #8
 8005f40:	f8c2 1110 	str.w	r1, [r2, #272]	@ 0x110
  (void)RCC_C1->APB1LLPENR;
 8005f44:	f8d2 1110 	ldr.w	r1, [r2, #272]	@ 0x110
  RCC->APB1LRSTR |= mask;
 8005f48:	f8d2 1090 	ldr.w	r1, [r2, #144]	@ 0x90
 8005f4c:	f041 0108 	orr.w	r1, r1, #8
 8005f50:	f8c2 1090 	str.w	r1, [r2, #144]	@ 0x90
  RCC->APB1LRSTR &= ~mask;
 8005f54:	f8d2 1090 	ldr.w	r1, [r2, #144]	@ 0x90
 8005f58:	f021 0108 	bic.w	r1, r1, #8
 8005f5c:	f8c2 1090 	str.w	r1, [r2, #144]	@ 0x90
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8005f60:	2122      	movs	r1, #34	@ 0x22
  (void)RCC->APB1LRSTR;
 8005f62:	f8d2 2090 	ldr.w	r2, [r2, #144]	@ 0x90
    pwmp->tim->CCMR3 = STM32_TIM_CCMR3_OC5M(6) | STM32_TIM_CCMR3_OC5PE |
 8005f66:	4a4a      	ldr	r2, [pc, #296]	@ (8006090 <main+0xc30>)
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8005f68:	6198      	str	r0, [r3, #24]
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 8005f6a:	61d8      	str	r0, [r3, #28]
    pwmp->tim->CCMR3 = STM32_TIM_CCMR3_OC5M(6) | STM32_TIM_CCMR3_OC5PE |
 8005f6c:	655a      	str	r2, [r3, #84]	@ 0x54
 8005f6e:	e591      	b.n	8005a94 <main+0x634>
        if (H_PAGES(hp) == pages) {
 8005f70:	f5b6 7f8f 	cmp.w	r6, #286	@ 0x11e
          H_NEXT(fp) = H_NEXT(hp);
 8005f74:	6813      	ldr	r3, [r2, #0]
        if (H_PAGES(hp) == pages) {
 8005f76:	d008      	beq.n	8005f8a <main+0xb2a>
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8005f78:	f5a1 6110 	sub.w	r1, r1, #2304	@ 0x900
          H_NEXT(fp) = H_NEXT(hp);
 8005f7c:	f8c2 38f8 	str.w	r3, [r2, #2296]	@ 0x8f8
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8005f80:	f602 03f8 	addw	r3, r2, #2296	@ 0x8f8
 8005f84:	10c9      	asrs	r1, r1, #3
 8005f86:	f8c2 18fc 	str.w	r1, [r2, #2300]	@ 0x8fc
    hp = H_NEXT(qp);
 8005f8a:	4691      	mov	r9, r2
          H_NEXT(qp) = fp;
 8005f8c:	6003      	str	r3, [r0, #0]
 8005f8e:	e766      	b.n	8005e5e <main+0x9fe>
 8005f90:	4648      	mov	r0, r9
 8005f92:	f7ff f88d 	bl	80050b0 <chThdRelease.part.0>
 8005f96:	e738      	b.n	8005e0a <main+0x9aa>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8005f98:	68e2      	ldr	r2, [r4, #12]
 8005f9a:	689b      	ldr	r3, [r3, #8]
 8005f9c:	6892      	ldr	r2, [r2, #8]
 8005f9e:	429a      	cmp	r2, r3
 8005fa0:	f4bf aea8 	bcs.w	8005cf4 <main+0x894>
 8005fa4:	483b      	ldr	r0, [pc, #236]	@ (8006094 <main+0xc34>)
 8005fa6:	f7fa fed3 	bl	8000d50 <chSysHalt>
  osalDbgAssert((psc <= 0xFFFF) &&
 8005faa:	483b      	ldr	r0, [pc, #236]	@ (8006098 <main+0xc38>)
 8005fac:	f7fa fed0 	bl	8000d50 <chSysHalt>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8005fb0:	483a      	ldr	r0, [pc, #232]	@ (800609c <main+0xc3c>)
 8005fb2:	f7fa fecd 	bl	8000d50 <chSysHalt>
 8005fb6:	68e2      	ldr	r2, [r4, #12]
 8005fb8:	689b      	ldr	r3, [r3, #8]
 8005fba:	6892      	ldr	r2, [r2, #8]
 8005fbc:	429a      	cmp	r2, r3
 8005fbe:	f4bf af08 	bcs.w	8005dd2 <main+0x972>
 8005fc2:	4837      	ldr	r0, [pc, #220]	@ (80060a0 <main+0xc40>)
 8005fc4:	f7fa fec4 	bl	8000d50 <chSysHalt>
 8005fc8:	68e2      	ldr	r2, [r4, #12]
 8005fca:	689b      	ldr	r3, [r3, #8]
 8005fcc:	6892      	ldr	r2, [r2, #8]
 8005fce:	429a      	cmp	r2, r3
 8005fd0:	f4bf aee0 	bcs.w	8005d94 <main+0x934>
 8005fd4:	4833      	ldr	r0, [pc, #204]	@ (80060a4 <main+0xc44>)
 8005fd6:	f7fa febb 	bl	8000d50 <chSysHalt>
 8005fda:	68e2      	ldr	r2, [r4, #12]
 8005fdc:	689b      	ldr	r3, [r3, #8]
 8005fde:	6892      	ldr	r2, [r2, #8]
 8005fe0:	429a      	cmp	r2, r3
 8005fe2:	f4bf af1e 	bcs.w	8005e22 <main+0x9c2>
 8005fe6:	e7ec      	b.n	8005fc2 <main+0xb62>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 8005fe8:	482f      	ldr	r0, [pc, #188]	@ (80060a8 <main+0xc48>)
 8005fea:	f7fa feb1 	bl	8000d50 <chSysHalt>
 8005fee:	68e2      	ldr	r2, [r4, #12]
 8005ff0:	689b      	ldr	r3, [r3, #8]
 8005ff2:	6892      	ldr	r2, [r2, #8]
 8005ff4:	429a      	cmp	r2, r3
 8005ff6:	f4bf ac66 	bcs.w	80058c6 <main+0x466>
 8005ffa:	482c      	ldr	r0, [pc, #176]	@ (80060ac <main+0xc4c>)
 8005ffc:	f7fa fea8 	bl	8000d50 <chSysHalt>
 8006000:	68e2      	ldr	r2, [r4, #12]
 8006002:	689b      	ldr	r3, [r3, #8]
 8006004:	6892      	ldr	r2, [r2, #8]
 8006006:	429a      	cmp	r2, r3
 8006008:	f4bf aca7 	bcs.w	800595a <main+0x4fa>
 800600c:	4828      	ldr	r0, [pc, #160]	@ (80060b0 <main+0xc50>)
 800600e:	f7fa fe9f 	bl	8000d50 <chSysHalt>
 8006012:	68e2      	ldr	r2, [r4, #12]
 8006014:	689b      	ldr	r3, [r3, #8]
 8006016:	6892      	ldr	r2, [r2, #8]
 8006018:	429a      	cmp	r2, r3
 800601a:	f4bf acb5 	bcs.w	8005988 <main+0x528>
 800601e:	e7d0      	b.n	8005fc2 <main+0xb62>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 8006020:	4824      	ldr	r0, [pc, #144]	@ (80060b4 <main+0xc54>)
 8006022:	f7fa fe95 	bl	8000d50 <chSysHalt>
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 8006026:	4824      	ldr	r0, [pc, #144]	@ (80060b8 <main+0xc58>)
 8006028:	f7fa fe92 	bl	8000d50 <chSysHalt>
 800602c:	68e1      	ldr	r1, [r4, #12]
 800602e:	6892      	ldr	r2, [r2, #8]
 8006030:	6889      	ldr	r1, [r1, #8]
 8006032:	4291      	cmp	r1, r2
 8006034:	f4bf acec 	bcs.w	8005a10 <main+0x5b0>
 8006038:	4820      	ldr	r0, [pc, #128]	@ (80060bc <main+0xc5c>)
 800603a:	f7fa fe89 	bl	8000d50 <chSysHalt>
 800603e:	68e2      	ldr	r2, [r4, #12]
 8006040:	689b      	ldr	r3, [r3, #8]
 8006042:	6892      	ldr	r2, [r2, #8]
 8006044:	429a      	cmp	r2, r3
 8006046:	f4bf acbd 	bcs.w	80059c4 <main+0x564>
 800604a:	481d      	ldr	r0, [pc, #116]	@ (80060c0 <main+0xc60>)
 800604c:	f7fa fe80 	bl	8000d50 <chSysHalt>
 8006050:	68e2      	ldr	r2, [r4, #12]
 8006052:	689b      	ldr	r3, [r3, #8]
 8006054:	6892      	ldr	r2, [r2, #8]
 8006056:	429a      	cmp	r2, r3
 8006058:	f4bf aed4 	bcs.w	8005e04 <main+0x9a4>
 800605c:	e7b1      	b.n	8005fc2 <main+0xb62>
  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 800605e:	4819      	ldr	r0, [pc, #100]	@ (80060c4 <main+0xc64>)
 8006060:	f7fa fe76 	bl	8000d50 <chSysHalt>
 8006064:	68e2      	ldr	r2, [r4, #12]
 8006066:	689b      	ldr	r3, [r3, #8]
 8006068:	6892      	ldr	r2, [r2, #8]
 800606a:	429a      	cmp	r2, r3
 800606c:	f4bf ae30 	bcs.w	8005cd0 <main+0x870>
 8006070:	e7a7      	b.n	8005fc2 <main+0xb62>
 8006072:	6893      	ldr	r3, [r2, #8]
 8006074:	68e2      	ldr	r2, [r4, #12]
 8006076:	6892      	ldr	r2, [r2, #8]
 8006078:	429a      	cmp	r2, r3
 800607a:	f4bf ad45 	bcs.w	8005b08 <main+0x6a8>
 800607e:	4812      	ldr	r0, [pc, #72]	@ (80060c8 <main+0xc68>)
 8006080:	f7fa fe66 	bl	8000d50 <chSysHalt>
 8006084:	58024400 	.word	0x58024400
 8006088:	0800707c 	.word	0x0800707c
 800608c:	08583b00 	.word	0x08583b00
 8006090:	01016868 	.word	0x01016868
 8006094:	0800720c 	.word	0x0800720c
 8006098:	08006fe4 	.word	0x08006fe4
 800609c:	080071e0 	.word	0x080071e0
 80060a0:	08007224 	.word	0x08007224
 80060a4:	08007070 	.word	0x08007070
 80060a8:	08006eb4 	.word	0x08006eb4
 80060ac:	08006e60 	.word	0x08006e60
 80060b0:	08006ea8 	.word	0x08006ea8
 80060b4:	08006ecc 	.word	0x08006ecc
 80060b8:	08006ff4 	.word	0x08006ff4
 80060bc:	08006ed8 	.word	0x08006ed8
 80060c0:	08006ec0 	.word	0x08006ec0
 80060c4:	08007000 	.word	0x08007000
 80060c8:	080071d4 	.word	0x080071d4

080060cc <atoi>:
 80060cc:	220a      	movs	r2, #10
 80060ce:	2100      	movs	r1, #0
 80060d0:	f000 b89c 	b.w	800620c <strtol>

080060d4 <_strtol_l.isra.0>:
 80060d4:	2b24      	cmp	r3, #36	@ 0x24
 80060d6:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80060da:	d843      	bhi.n	8006164 <_strtol_l.isra.0+0x90>
 80060dc:	2b01      	cmp	r3, #1
 80060de:	d041      	beq.n	8006164 <_strtol_l.isra.0+0x90>
 80060e0:	4680      	mov	r8, r0
 80060e2:	4849      	ldr	r0, [pc, #292]	@ (8006208 <_strtol_l.isra.0+0x134>)
 80060e4:	461f      	mov	r7, r3
 80060e6:	468e      	mov	lr, r1
 80060e8:	4675      	mov	r5, lr
 80060ea:	f81e bb01 	ldrb.w	fp, [lr], #1
 80060ee:	f810 400b 	ldrb.w	r4, [r0, fp]
 80060f2:	f014 0408 	ands.w	r4, r4, #8
 80060f6:	d1f7      	bne.n	80060e8 <_strtol_l.isra.0+0x14>
 80060f8:	f1bb 0f2d 	cmp.w	fp, #45	@ 0x2d
 80060fc:	d06f      	beq.n	80061de <_strtol_l.isra.0+0x10a>
 80060fe:	f1bb 0f2b 	cmp.w	fp, #43	@ 0x2b
 8006102:	bf08      	it	eq
 8006104:	f89e b000 	ldrbeq.w	fp, [lr]
 8006108:	f06f 4900 	mvn.w	r9, #2147483648	@ 0x80000000
 800610c:	bf08      	it	eq
 800610e:	f105 0e02 	addeq.w	lr, r5, #2
 8006112:	bb73      	cbnz	r3, 8006172 <_strtol_l.isra.0+0x9e>
 8006114:	f1bb 0f30 	cmp.w	fp, #48	@ 0x30
 8006118:	d04b      	beq.n	80061b2 <_strtol_l.isra.0+0xde>
 800611a:	270a      	movs	r7, #10
 800611c:	463b      	mov	r3, r7
 800611e:	2500      	movs	r5, #0
 8006120:	fbb9 f6f7 	udiv	r6, r9, r7
 8006124:	4628      	mov	r0, r5
 8006126:	fb07 9a16 	mls	sl, r7, r6, r9
 800612a:	e005      	b.n	8006138 <_strtol_l.isra.0+0x64>
 800612c:	d03a      	beq.n	80061a4 <_strtol_l.isra.0+0xd0>
 800612e:	fb07 c000 	mla	r0, r7, r0, ip
 8006132:	2501      	movs	r5, #1
 8006134:	f81e bb01 	ldrb.w	fp, [lr], #1
 8006138:	f1ab 0c30 	sub.w	ip, fp, #48	@ 0x30
 800613c:	f1bc 0f09 	cmp.w	ip, #9
 8006140:	d906      	bls.n	8006150 <_strtol_l.isra.0+0x7c>
 8006142:	f1ab 0c41 	sub.w	ip, fp, #65	@ 0x41
 8006146:	f1bc 0f19 	cmp.w	ip, #25
 800614a:	d819      	bhi.n	8006180 <_strtol_l.isra.0+0xac>
 800614c:	f1ab 0c37 	sub.w	ip, fp, #55	@ 0x37
 8006150:	4563      	cmp	r3, ip
 8006152:	dd1e      	ble.n	8006192 <_strtol_l.isra.0+0xbe>
 8006154:	f1b5 3fff 	cmp.w	r5, #4294967295	@ 0xffffffff
 8006158:	d0ec      	beq.n	8006134 <_strtol_l.isra.0+0x60>
 800615a:	4286      	cmp	r6, r0
 800615c:	d2e6      	bcs.n	800612c <_strtol_l.isra.0+0x58>
 800615e:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
 8006162:	e7e7      	b.n	8006134 <_strtol_l.isra.0+0x60>
 8006164:	f000 f85e 	bl	8006224 <__errno>
 8006168:	2316      	movs	r3, #22
 800616a:	6003      	str	r3, [r0, #0]
 800616c:	2000      	movs	r0, #0
 800616e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006172:	2b10      	cmp	r3, #16
 8006174:	d1d3      	bne.n	800611e <_strtol_l.isra.0+0x4a>
 8006176:	f1bb 0f30 	cmp.w	fp, #48	@ 0x30
 800617a:	d023      	beq.n	80061c4 <_strtol_l.isra.0+0xf0>
 800617c:	461f      	mov	r7, r3
 800617e:	e7ce      	b.n	800611e <_strtol_l.isra.0+0x4a>
 8006180:	f1ab 0c61 	sub.w	ip, fp, #97	@ 0x61
 8006184:	f1bc 0f19 	cmp.w	ip, #25
 8006188:	d803      	bhi.n	8006192 <_strtol_l.isra.0+0xbe>
 800618a:	f1ab 0c57 	sub.w	ip, fp, #87	@ 0x57
 800618e:	4563      	cmp	r3, ip
 8006190:	dce0      	bgt.n	8006154 <_strtol_l.isra.0+0x80>
 8006192:	1c6b      	adds	r3, r5, #1
 8006194:	d02b      	beq.n	80061ee <_strtol_l.isra.0+0x11a>
 8006196:	b954      	cbnz	r4, 80061ae <_strtol_l.isra.0+0xda>
 8006198:	2a00      	cmp	r2, #0
 800619a:	d0e8      	beq.n	800616e <_strtol_l.isra.0+0x9a>
 800619c:	bb85      	cbnz	r5, 8006200 <_strtol_l.isra.0+0x12c>
 800619e:	6011      	str	r1, [r2, #0]
 80061a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80061a4:	45e2      	cmp	sl, ip
 80061a6:	dac2      	bge.n	800612e <_strtol_l.isra.0+0x5a>
 80061a8:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
 80061ac:	e7c2      	b.n	8006134 <_strtol_l.isra.0+0x60>
 80061ae:	4240      	negs	r0, r0
 80061b0:	e7f2      	b.n	8006198 <_strtol_l.isra.0+0xc4>
 80061b2:	f89e 3000 	ldrb.w	r3, [lr]
 80061b6:	f003 03df 	and.w	r3, r3, #223	@ 0xdf
 80061ba:	2b58      	cmp	r3, #88	@ 0x58
 80061bc:	d008      	beq.n	80061d0 <_strtol_l.isra.0+0xfc>
 80061be:	2708      	movs	r7, #8
 80061c0:	463b      	mov	r3, r7
 80061c2:	e7ac      	b.n	800611e <_strtol_l.isra.0+0x4a>
 80061c4:	f89e 0000 	ldrb.w	r0, [lr]
 80061c8:	f000 00df 	and.w	r0, r0, #223	@ 0xdf
 80061cc:	2858      	cmp	r0, #88	@ 0x58
 80061ce:	d1d5      	bne.n	800617c <_strtol_l.isra.0+0xa8>
 80061d0:	2710      	movs	r7, #16
 80061d2:	f89e b001 	ldrb.w	fp, [lr, #1]
 80061d6:	463b      	mov	r3, r7
 80061d8:	f10e 0e02 	add.w	lr, lr, #2
 80061dc:	e79f      	b.n	800611e <_strtol_l.isra.0+0x4a>
 80061de:	f89e b000 	ldrb.w	fp, [lr]
 80061e2:	f04f 4900 	mov.w	r9, #2147483648	@ 0x80000000
 80061e6:	f105 0e02 	add.w	lr, r5, #2
 80061ea:	2401      	movs	r4, #1
 80061ec:	e791      	b.n	8006112 <_strtol_l.isra.0+0x3e>
 80061ee:	2322      	movs	r3, #34	@ 0x22
 80061f0:	f8c8 3000 	str.w	r3, [r8]
 80061f4:	b132      	cbz	r2, 8006204 <_strtol_l.isra.0+0x130>
 80061f6:	f10e 31ff 	add.w	r1, lr, #4294967295	@ 0xffffffff
 80061fa:	4648      	mov	r0, r9
 80061fc:	6011      	str	r1, [r2, #0]
 80061fe:	e7cf      	b.n	80061a0 <_strtol_l.isra.0+0xcc>
 8006200:	4681      	mov	r9, r0
 8006202:	e7f8      	b.n	80061f6 <_strtol_l.isra.0+0x122>
 8006204:	4648      	mov	r0, r9
 8006206:	e7b2      	b.n	800616e <_strtol_l.isra.0+0x9a>
 8006208:	080075dd 	.word	0x080075dd

0800620c <strtol>:
 800620c:	b410      	push	{r4}
 800620e:	4c04      	ldr	r4, [pc, #16]	@ (8006220 <strtol+0x14>)
 8006210:	4684      	mov	ip, r0
 8006212:	4613      	mov	r3, r2
 8006214:	6820      	ldr	r0, [r4, #0]
 8006216:	bc10      	pop	{r4}
 8006218:	460a      	mov	r2, r1
 800621a:	4661      	mov	r1, ip
 800621c:	f7ff bf5a 	b.w	80060d4 <_strtol_l.isra.0>
 8006220:	2400000c 	.word	0x2400000c

08006224 <__errno>:
 8006224:	4b01      	ldr	r3, [pc, #4]	@ (800622c <__errno+0x8>)
 8006226:	6818      	ldr	r0, [r3, #0]
 8006228:	4770      	bx	lr
 800622a:	bf00      	nop
 800622c:	2400000c 	.word	0x2400000c

08006230 <memset>:
 8006230:	0783      	lsls	r3, r0, #30
 8006232:	b530      	push	{r4, r5, lr}
 8006234:	d047      	beq.n	80062c6 <memset+0x96>
 8006236:	1e54      	subs	r4, r2, #1
 8006238:	2a00      	cmp	r2, #0
 800623a:	d03e      	beq.n	80062ba <memset+0x8a>
 800623c:	b2ca      	uxtb	r2, r1
 800623e:	4603      	mov	r3, r0
 8006240:	e001      	b.n	8006246 <memset+0x16>
 8006242:	3c01      	subs	r4, #1
 8006244:	d339      	bcc.n	80062ba <memset+0x8a>
 8006246:	f803 2b01 	strb.w	r2, [r3], #1
 800624a:	079d      	lsls	r5, r3, #30
 800624c:	d1f9      	bne.n	8006242 <memset+0x12>
 800624e:	2c03      	cmp	r4, #3
 8006250:	d92c      	bls.n	80062ac <memset+0x7c>
 8006252:	b2cd      	uxtb	r5, r1
 8006254:	eb05 2505 	add.w	r5, r5, r5, lsl #8
 8006258:	2c0f      	cmp	r4, #15
 800625a:	eb05 4505 	add.w	r5, r5, r5, lsl #16
 800625e:	d935      	bls.n	80062cc <memset+0x9c>
 8006260:	f1a4 0210 	sub.w	r2, r4, #16
 8006264:	f022 0c0f 	bic.w	ip, r2, #15
 8006268:	f103 0e10 	add.w	lr, r3, #16
 800626c:	44e6      	add	lr, ip
 800626e:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 8006272:	461a      	mov	r2, r3
 8006274:	e9c2 5500 	strd	r5, r5, [r2]
 8006278:	e9c2 5502 	strd	r5, r5, [r2, #8]
 800627c:	3210      	adds	r2, #16
 800627e:	4572      	cmp	r2, lr
 8006280:	d1f8      	bne.n	8006274 <memset+0x44>
 8006282:	f10c 0201 	add.w	r2, ip, #1
 8006286:	f014 0f0c 	tst.w	r4, #12
 800628a:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 800628e:	f004 0c0f 	and.w	ip, r4, #15
 8006292:	d013      	beq.n	80062bc <memset+0x8c>
 8006294:	f1ac 0304 	sub.w	r3, ip, #4
 8006298:	f023 0303 	bic.w	r3, r3, #3
 800629c:	3304      	adds	r3, #4
 800629e:	4413      	add	r3, r2
 80062a0:	f842 5b04 	str.w	r5, [r2], #4
 80062a4:	4293      	cmp	r3, r2
 80062a6:	d1fb      	bne.n	80062a0 <memset+0x70>
 80062a8:	f00c 0403 	and.w	r4, ip, #3
 80062ac:	b12c      	cbz	r4, 80062ba <memset+0x8a>
 80062ae:	b2c9      	uxtb	r1, r1
 80062b0:	441c      	add	r4, r3
 80062b2:	f803 1b01 	strb.w	r1, [r3], #1
 80062b6:	42a3      	cmp	r3, r4
 80062b8:	d1fb      	bne.n	80062b2 <memset+0x82>
 80062ba:	bd30      	pop	{r4, r5, pc}
 80062bc:	4664      	mov	r4, ip
 80062be:	4613      	mov	r3, r2
 80062c0:	2c00      	cmp	r4, #0
 80062c2:	d1f4      	bne.n	80062ae <memset+0x7e>
 80062c4:	e7f9      	b.n	80062ba <memset+0x8a>
 80062c6:	4603      	mov	r3, r0
 80062c8:	4614      	mov	r4, r2
 80062ca:	e7c0      	b.n	800624e <memset+0x1e>
 80062cc:	461a      	mov	r2, r3
 80062ce:	46a4      	mov	ip, r4
 80062d0:	e7e0      	b.n	8006294 <memset+0x64>
 80062d2:	bf00      	nop

080062d4 <strchr>:
 80062d4:	f011 01ff 	ands.w	r1, r1, #255	@ 0xff
 80062d8:	4603      	mov	r3, r0
 80062da:	f000 0203 	and.w	r2, r0, #3
 80062de:	d039      	beq.n	8006354 <strchr+0x80>
 80062e0:	bb8a      	cbnz	r2, 8006346 <strchr+0x72>
 80062e2:	6802      	ldr	r2, [r0, #0]
 80062e4:	b510      	push	{r4, lr}
 80062e6:	eb01 2e01 	add.w	lr, r1, r1, lsl #8
 80062ea:	eb0e 4e0e 	add.w	lr, lr, lr, lsl #16
 80062ee:	ea8e 0402 	eor.w	r4, lr, r2
 80062f2:	f1a2 3301 	sub.w	r3, r2, #16843009	@ 0x1010101
 80062f6:	ea23 0302 	bic.w	r3, r3, r2
 80062fa:	f1a4 3201 	sub.w	r2, r4, #16843009	@ 0x1010101
 80062fe:	ea22 0204 	bic.w	r2, r2, r4
 8006302:	4313      	orrs	r3, r2
 8006304:	f013 3f80 	tst.w	r3, #2155905152	@ 0x80808080
 8006308:	d10f      	bne.n	800632a <strchr+0x56>
 800630a:	f850 4f04 	ldr.w	r4, [r0, #4]!
 800630e:	ea84 0c0e 	eor.w	ip, r4, lr
 8006312:	f1a4 3301 	sub.w	r3, r4, #16843009	@ 0x1010101
 8006316:	f1ac 3201 	sub.w	r2, ip, #16843009	@ 0x1010101
 800631a:	ea23 0304 	bic.w	r3, r3, r4
 800631e:	ea22 020c 	bic.w	r2, r2, ip
 8006322:	4313      	orrs	r3, r2
 8006324:	f013 3f80 	tst.w	r3, #2155905152	@ 0x80808080
 8006328:	d0ef      	beq.n	800630a <strchr+0x36>
 800632a:	7803      	ldrb	r3, [r0, #0]
 800632c:	b923      	cbnz	r3, 8006338 <strchr+0x64>
 800632e:	e036      	b.n	800639e <strchr+0xca>
 8006330:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8006334:	2b00      	cmp	r3, #0
 8006336:	d032      	beq.n	800639e <strchr+0xca>
 8006338:	4299      	cmp	r1, r3
 800633a:	d1f9      	bne.n	8006330 <strchr+0x5c>
 800633c:	bd10      	pop	{r4, pc}
 800633e:	428a      	cmp	r2, r1
 8006340:	d028      	beq.n	8006394 <strchr+0xc0>
 8006342:	079a      	lsls	r2, r3, #30
 8006344:	d029      	beq.n	800639a <strchr+0xc6>
 8006346:	781a      	ldrb	r2, [r3, #0]
 8006348:	4618      	mov	r0, r3
 800634a:	3301      	adds	r3, #1
 800634c:	2a00      	cmp	r2, #0
 800634e:	d1f6      	bne.n	800633e <strchr+0x6a>
 8006350:	4610      	mov	r0, r2
 8006352:	4770      	bx	lr
 8006354:	b9ca      	cbnz	r2, 800638a <strchr+0xb6>
 8006356:	6802      	ldr	r2, [r0, #0]
 8006358:	f1a2 3301 	sub.w	r3, r2, #16843009	@ 0x1010101
 800635c:	ea23 0302 	bic.w	r3, r3, r2
 8006360:	f013 3f80 	tst.w	r3, #2155905152	@ 0x80808080
 8006364:	d108      	bne.n	8006378 <strchr+0xa4>
 8006366:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800636a:	f1a2 3301 	sub.w	r3, r2, #16843009	@ 0x1010101
 800636e:	ea23 0302 	bic.w	r3, r3, r2
 8006372:	f013 3f80 	tst.w	r3, #2155905152	@ 0x80808080
 8006376:	d0f6      	beq.n	8006366 <strchr+0x92>
 8006378:	7803      	ldrb	r3, [r0, #0]
 800637a:	b15b      	cbz	r3, 8006394 <strchr+0xc0>
 800637c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8006380:	2b00      	cmp	r3, #0
 8006382:	d1fb      	bne.n	800637c <strchr+0xa8>
 8006384:	4770      	bx	lr
 8006386:	0799      	lsls	r1, r3, #30
 8006388:	d005      	beq.n	8006396 <strchr+0xc2>
 800638a:	4618      	mov	r0, r3
 800638c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8006390:	2a00      	cmp	r2, #0
 8006392:	d1f8      	bne.n	8006386 <strchr+0xb2>
 8006394:	4770      	bx	lr
 8006396:	4618      	mov	r0, r3
 8006398:	e7dd      	b.n	8006356 <strchr+0x82>
 800639a:	4618      	mov	r0, r3
 800639c:	e7a1      	b.n	80062e2 <strchr+0xe>
 800639e:	4618      	mov	r0, r3
 80063a0:	bd10      	pop	{r4, pc}
 80063a2:	bf00      	nop

080063a4 <strpbrk>:
 80063a4:	b430      	push	{r4, r5}
 80063a6:	7804      	ldrb	r4, [r0, #0]
 80063a8:	b17c      	cbz	r4, 80063ca <strpbrk+0x26>
 80063aa:	780d      	ldrb	r5, [r1, #0]
 80063ac:	b185      	cbz	r5, 80063d0 <strpbrk+0x2c>
 80063ae:	460a      	mov	r2, r1
 80063b0:	462b      	mov	r3, r5
 80063b2:	e002      	b.n	80063ba <strpbrk+0x16>
 80063b4:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80063b8:	b11b      	cbz	r3, 80063c2 <strpbrk+0x1e>
 80063ba:	42a3      	cmp	r3, r4
 80063bc:	d1fa      	bne.n	80063b4 <strpbrk+0x10>
 80063be:	bc30      	pop	{r4, r5}
 80063c0:	4770      	bx	lr
 80063c2:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80063c6:	2c00      	cmp	r4, #0
 80063c8:	d1f1      	bne.n	80063ae <strpbrk+0xa>
 80063ca:	4620      	mov	r0, r4
 80063cc:	bc30      	pop	{r4, r5}
 80063ce:	4770      	bx	lr
 80063d0:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80063d4:	2c00      	cmp	r4, #0
 80063d6:	d1fb      	bne.n	80063d0 <strpbrk+0x2c>
 80063d8:	e7f7      	b.n	80063ca <strpbrk+0x26>
 80063da:	bf00      	nop

080063dc <strspn>:
 80063dc:	b430      	push	{r4, r5}
 80063de:	7804      	ldrb	r4, [r0, #0]
 80063e0:	b1ac      	cbz	r4, 800640e <strspn+0x32>
 80063e2:	780d      	ldrb	r5, [r1, #0]
 80063e4:	b185      	cbz	r5, 8006408 <strspn+0x2c>
 80063e6:	4684      	mov	ip, r0
 80063e8:	460a      	mov	r2, r1
 80063ea:	462b      	mov	r3, r5
 80063ec:	e002      	b.n	80063f4 <strspn+0x18>
 80063ee:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80063f2:	b12b      	cbz	r3, 8006400 <strspn+0x24>
 80063f4:	429c      	cmp	r4, r3
 80063f6:	d1fa      	bne.n	80063ee <strspn+0x12>
 80063f8:	f81c 4f01 	ldrb.w	r4, [ip, #1]!
 80063fc:	2c00      	cmp	r4, #0
 80063fe:	d1f3      	bne.n	80063e8 <strspn+0xc>
 8006400:	ebac 0000 	sub.w	r0, ip, r0
 8006404:	bc30      	pop	{r4, r5}
 8006406:	4770      	bx	lr
 8006408:	4628      	mov	r0, r5
 800640a:	bc30      	pop	{r4, r5}
 800640c:	4770      	bx	lr
 800640e:	4620      	mov	r0, r4
 8006410:	e7f8      	b.n	8006404 <strspn+0x28>
 8006412:	bf00      	nop

08006414 <critical_factorization>:
 8006414:	2901      	cmp	r1, #1
 8006416:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800641a:	d95b      	bls.n	80064d4 <critical_factorization+0xc0>
 800641c:	f04f 0801 	mov.w	r8, #1
 8006420:	46c6      	mov	lr, r8
 8006422:	2400      	movs	r4, #0
 8006424:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
 8006428:	4643      	mov	r3, r8
 800642a:	e008      	b.n	800643e <critical_factorization+0x2a>
 800642c:	eba3 0805 	sub.w	r8, r3, r5
 8006430:	461c      	mov	r4, r3
 8006432:	f04f 0e01 	mov.w	lr, #1
 8006436:	eb04 030e 	add.w	r3, r4, lr
 800643a:	4299      	cmp	r1, r3
 800643c:	d910      	bls.n	8006460 <critical_factorization+0x4c>
 800643e:	eb00 0c05 	add.w	ip, r0, r5
 8006442:	5cc7      	ldrb	r7, [r0, r3]
 8006444:	f81c 600e 	ldrb.w	r6, [ip, lr]
 8006448:	42b7      	cmp	r7, r6
 800644a:	d3ef      	bcc.n	800642c <critical_factorization+0x18>
 800644c:	d032      	beq.n	80064b4 <critical_factorization+0xa0>
 800644e:	f04f 0801 	mov.w	r8, #1
 8006452:	4625      	mov	r5, r4
 8006454:	46c6      	mov	lr, r8
 8006456:	4444      	add	r4, r8
 8006458:	eb04 030e 	add.w	r3, r4, lr
 800645c:	4299      	cmp	r1, r3
 800645e:	d8ee      	bhi.n	800643e <critical_factorization+0x2a>
 8006460:	2701      	movs	r7, #1
 8006462:	f8c2 8000 	str.w	r8, [r2]
 8006466:	46be      	mov	lr, r7
 8006468:	2400      	movs	r4, #0
 800646a:	f04f 36ff 	mov.w	r6, #4294967295	@ 0xffffffff
 800646e:	463b      	mov	r3, r7
 8006470:	e007      	b.n	8006482 <critical_factorization+0x6e>
 8006472:	1b9f      	subs	r7, r3, r6
 8006474:	461c      	mov	r4, r3
 8006476:	f04f 0e01 	mov.w	lr, #1
 800647a:	eb04 030e 	add.w	r3, r4, lr
 800647e:	4299      	cmp	r1, r3
 8006480:	d910      	bls.n	80064a4 <critical_factorization+0x90>
 8006482:	eb00 0c06 	add.w	ip, r0, r6
 8006486:	f810 8003 	ldrb.w	r8, [r0, r3]
 800648a:	f81c c00e 	ldrb.w	ip, [ip, lr]
 800648e:	45e0      	cmp	r8, ip
 8006490:	d8ef      	bhi.n	8006472 <critical_factorization+0x5e>
 8006492:	d017      	beq.n	80064c4 <critical_factorization+0xb0>
 8006494:	2701      	movs	r7, #1
 8006496:	4626      	mov	r6, r4
 8006498:	46be      	mov	lr, r7
 800649a:	443c      	add	r4, r7
 800649c:	eb04 030e 	add.w	r3, r4, lr
 80064a0:	4299      	cmp	r1, r3
 80064a2:	d8ee      	bhi.n	8006482 <critical_factorization+0x6e>
 80064a4:	3601      	adds	r6, #1
 80064a6:	1c68      	adds	r0, r5, #1
 80064a8:	4286      	cmp	r6, r0
 80064aa:	d301      	bcc.n	80064b0 <critical_factorization+0x9c>
 80064ac:	6017      	str	r7, [r2, #0]
 80064ae:	4630      	mov	r0, r6
 80064b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80064b4:	45c6      	cmp	lr, r8
 80064b6:	bf0a      	itet	eq
 80064b8:	4474      	addeq	r4, lr
 80064ba:	f10e 0e01 	addne.w	lr, lr, #1
 80064be:	f04f 0e01 	moveq.w	lr, #1
 80064c2:	e7b8      	b.n	8006436 <critical_factorization+0x22>
 80064c4:	45be      	cmp	lr, r7
 80064c6:	bf0a      	itet	eq
 80064c8:	4474      	addeq	r4, lr
 80064ca:	f10e 0e01 	addne.w	lr, lr, #1
 80064ce:	f04f 0e01 	moveq.w	lr, #1
 80064d2:	e7d2      	b.n	800647a <critical_factorization+0x66>
 80064d4:	2701      	movs	r7, #1
 80064d6:	2600      	movs	r6, #0
 80064d8:	e7e8      	b.n	80064ac <critical_factorization+0x98>
 80064da:	bf00      	nop

080064dc <two_way_long_needle>:
 80064dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80064e0:	4693      	mov	fp, r2
 80064e2:	f2ad 4d1c 	subw	sp, sp, #1052	@ 0x41c
 80064e6:	aa05      	add	r2, sp, #20
 80064e8:	4680      	mov	r8, r0
 80064ea:	468a      	mov	sl, r1
 80064ec:	4658      	mov	r0, fp
 80064ee:	4619      	mov	r1, r3
 80064f0:	461c      	mov	r4, r3
 80064f2:	f7ff ff8f 	bl	8006414 <critical_factorization>
 80064f6:	4613      	mov	r3, r2
 80064f8:	4681      	mov	r9, r0
 80064fa:	f20d 4214 	addw	r2, sp, #1044	@ 0x414
 80064fe:	f843 4f04 	str.w	r4, [r3, #4]!
 8006502:	4293      	cmp	r3, r2
 8006504:	d1fb      	bne.n	80064fe <two_way_long_needle+0x22>
 8006506:	b16c      	cbz	r4, 8006524 <two_way_long_needle+0x48>
 8006508:	1e60      	subs	r0, r4, #1
 800650a:	4458      	add	r0, fp
 800650c:	f10b 32ff 	add.w	r2, fp, #4294967295	@ 0xffffffff
 8006510:	ad06      	add	r5, sp, #24
 8006512:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8006516:	1aa3      	subs	r3, r4, r2
 8006518:	3b01      	subs	r3, #1
 800651a:	445b      	add	r3, fp
 800651c:	4282      	cmp	r2, r0
 800651e:	f845 3021 	str.w	r3, [r5, r1, lsl #2]
 8006522:	d1f6      	bne.n	8006512 <two_way_long_needle+0x36>
 8006524:	9b05      	ldr	r3, [sp, #20]
 8006526:	9301      	str	r3, [sp, #4]
 8006528:	464a      	mov	r2, r9
 800652a:	eb0b 0103 	add.w	r1, fp, r3
 800652e:	4658      	mov	r0, fp
 8006530:	f000 f98c 	bl	800684c <memcmp>
 8006534:	2800      	cmp	r0, #0
 8006536:	d179      	bne.n	800662c <two_way_long_needle+0x150>
 8006538:	f444 6300 	orr.w	r3, r4, #2048	@ 0x800
 800653c:	4607      	mov	r7, r0
 800653e:	4605      	mov	r5, r0
 8006540:	ebaa 0e04 	sub.w	lr, sl, r4
 8006544:	9302      	str	r3, [sp, #8]
 8006546:	1e66      	subs	r6, r4, #1
 8006548:	45ae      	cmp	lr, r5
 800654a:	d312      	bcc.n	8006572 <two_way_long_needle+0x96>
 800654c:	eb08 0c05 	add.w	ip, r8, r5
 8006550:	aa06      	add	r2, sp, #24
 8006552:	f81c 3006 	ldrb.w	r3, [ip, r6]
 8006556:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800655a:	b1cb      	cbz	r3, 8006590 <two_way_long_needle+0xb4>
 800655c:	b127      	cbz	r7, 8006568 <two_way_long_needle+0x8c>
 800655e:	9a01      	ldr	r2, [sp, #4]
 8006560:	429a      	cmp	r2, r3
 8006562:	bf84      	itt	hi
 8006564:	4613      	movhi	r3, r2
 8006566:	1ae3      	subhi	r3, r4, r3
 8006568:	441d      	add	r5, r3
 800656a:	45ae      	cmp	lr, r5
 800656c:	f04f 0700 	mov.w	r7, #0
 8006570:	d2ec      	bcs.n	800654c <two_way_long_needle+0x70>
 8006572:	eb08 000a 	add.w	r0, r8, sl
 8006576:	9902      	ldr	r1, [sp, #8]
 8006578:	f000 f996 	bl	80068a8 <strnlen>
 800657c:	4482      	add	sl, r0
 800657e:	ebaa 0e04 	sub.w	lr, sl, r4
 8006582:	45ae      	cmp	lr, r5
 8006584:	d2e2      	bcs.n	800654c <two_way_long_needle+0x70>
 8006586:	2000      	movs	r0, #0
 8006588:	f20d 4d1c 	addw	sp, sp, #1052	@ 0x41c
 800658c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006590:	454f      	cmp	r7, r9
 8006592:	463b      	mov	r3, r7
 8006594:	bf38      	it	cc
 8006596:	464b      	movcc	r3, r9
 8006598:	429e      	cmp	r6, r3
 800659a:	d918      	bls.n	80065ce <two_way_long_needle+0xf2>
 800659c:	1e59      	subs	r1, r3, #1
 800659e:	18ea      	adds	r2, r5, r3
 80065a0:	4459      	add	r1, fp
 80065a2:	4442      	add	r2, r8
 80065a4:	9500      	str	r5, [sp, #0]
 80065a6:	e002      	b.n	80065ae <two_way_long_needle+0xd2>
 80065a8:	3301      	adds	r3, #1
 80065aa:	429e      	cmp	r6, r3
 80065ac:	d00e      	beq.n	80065cc <two_way_long_needle+0xf0>
 80065ae:	f812 0b01 	ldrb.w	r0, [r2], #1
 80065b2:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 80065b6:	4285      	cmp	r5, r0
 80065b8:	d0f6      	beq.n	80065a8 <two_way_long_needle+0xcc>
 80065ba:	429e      	cmp	r6, r3
 80065bc:	9d00      	ldr	r5, [sp, #0]
 80065be:	d906      	bls.n	80065ce <two_way_long_needle+0xf2>
 80065c0:	f1c9 0201 	rsb	r2, r9, #1
 80065c4:	442a      	add	r2, r5
 80065c6:	18d5      	adds	r5, r2, r3
 80065c8:	2700      	movs	r7, #0
 80065ca:	e7bd      	b.n	8006548 <two_way_long_needle+0x6c>
 80065cc:	9d00      	ldr	r5, [sp, #0]
 80065ce:	454f      	cmp	r7, r9
 80065d0:	f109 33ff 	add.w	r3, r9, #4294967295	@ 0xffffffff
 80065d4:	f080 8081 	bcs.w	80066da <two_way_long_needle+0x1fe>
 80065d8:	eb05 0209 	add.w	r2, r5, r9
 80065dc:	4442      	add	r2, r8
 80065de:	eb0b 0109 	add.w	r1, fp, r9
 80065e2:	9500      	str	r5, [sp, #0]
 80065e4:	f8cd 900c 	str.w	r9, [sp, #12]
 80065e8:	e002      	b.n	80065f0 <two_way_long_needle+0x114>
 80065ea:	429f      	cmp	r7, r3
 80065ec:	d013      	beq.n	8006616 <two_way_long_needle+0x13a>
 80065ee:	464b      	mov	r3, r9
 80065f0:	f811 5d01 	ldrb.w	r5, [r1, #-1]!
 80065f4:	f812 0d01 	ldrb.w	r0, [r2, #-1]!
 80065f8:	4285      	cmp	r5, r0
 80065fa:	f103 39ff 	add.w	r9, r3, #4294967295	@ 0xffffffff
 80065fe:	d0f4      	beq.n	80065ea <two_way_long_needle+0x10e>
 8006600:	9d00      	ldr	r5, [sp, #0]
 8006602:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8006606:	3301      	adds	r3, #1
 8006608:	3701      	adds	r7, #1
 800660a:	429f      	cmp	r7, r3
 800660c:	d809      	bhi.n	8006622 <two_way_long_needle+0x146>
 800660e:	9b01      	ldr	r3, [sp, #4]
 8006610:	441d      	add	r5, r3
 8006612:	1ae7      	subs	r7, r4, r3
 8006614:	e798      	b.n	8006548 <two_way_long_needle+0x6c>
 8006616:	3701      	adds	r7, #1
 8006618:	429f      	cmp	r7, r3
 800661a:	9d00      	ldr	r5, [sp, #0]
 800661c:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8006620:	d9f5      	bls.n	800660e <two_way_long_needle+0x132>
 8006622:	4660      	mov	r0, ip
 8006624:	f20d 4d1c 	addw	sp, sp, #1052	@ 0x41c
 8006628:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800662c:	eba4 0309 	sub.w	r3, r4, r9
 8006630:	454b      	cmp	r3, r9
 8006632:	bf38      	it	cc
 8006634:	464b      	movcc	r3, r9
 8006636:	3301      	adds	r3, #1
 8006638:	9301      	str	r3, [sp, #4]
 800663a:	9305      	str	r3, [sp, #20]
 800663c:	f444 6300 	orr.w	r3, r4, #2048	@ 0x800
 8006640:	2500      	movs	r5, #0
 8006642:	ebaa 0e04 	sub.w	lr, sl, r4
 8006646:	9300      	str	r3, [sp, #0]
 8006648:	1e66      	subs	r6, r4, #1
 800664a:	45ae      	cmp	lr, r5
 800664c:	d309      	bcc.n	8006662 <two_way_long_needle+0x186>
 800664e:	eb08 0005 	add.w	r0, r8, r5
 8006652:	aa06      	add	r2, sp, #24
 8006654:	5d83      	ldrb	r3, [r0, r6]
 8006656:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800665a:	b16b      	cbz	r3, 8006678 <two_way_long_needle+0x19c>
 800665c:	441d      	add	r5, r3
 800665e:	45ae      	cmp	lr, r5
 8006660:	d2f5      	bcs.n	800664e <two_way_long_needle+0x172>
 8006662:	eb08 000a 	add.w	r0, r8, sl
 8006666:	9900      	ldr	r1, [sp, #0]
 8006668:	f000 f91e 	bl	80068a8 <strnlen>
 800666c:	4482      	add	sl, r0
 800666e:	ebaa 0e04 	sub.w	lr, sl, r4
 8006672:	45ae      	cmp	lr, r5
 8006674:	d2eb      	bcs.n	800664e <two_way_long_needle+0x172>
 8006676:	e786      	b.n	8006586 <two_way_long_needle+0xaa>
 8006678:	45b1      	cmp	r9, r6
 800667a:	d217      	bcs.n	80066ac <two_way_long_needle+0x1d0>
 800667c:	f109 31ff 	add.w	r1, r9, #4294967295	@ 0xffffffff
 8006680:	eb05 0209 	add.w	r2, r5, r9
 8006684:	4459      	add	r1, fp
 8006686:	4442      	add	r2, r8
 8006688:	464b      	mov	r3, r9
 800668a:	e002      	b.n	8006692 <two_way_long_needle+0x1b6>
 800668c:	3301      	adds	r3, #1
 800668e:	42b3      	cmp	r3, r6
 8006690:	d00c      	beq.n	80066ac <two_way_long_needle+0x1d0>
 8006692:	f812 7b01 	ldrb.w	r7, [r2], #1
 8006696:	f811 cf01 	ldrb.w	ip, [r1, #1]!
 800669a:	45bc      	cmp	ip, r7
 800669c:	d0f6      	beq.n	800668c <two_way_long_needle+0x1b0>
 800669e:	429e      	cmp	r6, r3
 80066a0:	d904      	bls.n	80066ac <two_way_long_needle+0x1d0>
 80066a2:	f1c9 0201 	rsb	r2, r9, #1
 80066a6:	442a      	add	r2, r5
 80066a8:	18d5      	adds	r5, r2, r3
 80066aa:	e7ce      	b.n	800664a <two_way_long_needle+0x16e>
 80066ac:	f1b9 0f00 	cmp.w	r9, #0
 80066b0:	f43f af6a 	beq.w	8006588 <two_way_long_needle+0xac>
 80066b4:	eb05 0109 	add.w	r1, r5, r9
 80066b8:	4441      	add	r1, r8
 80066ba:	eb0b 0209 	add.w	r2, fp, r9
 80066be:	e002      	b.n	80066c6 <two_way_long_needle+0x1ea>
 80066c0:	455b      	cmp	r3, fp
 80066c2:	f43f af61 	beq.w	8006588 <two_way_long_needle+0xac>
 80066c6:	f812 cd01 	ldrb.w	ip, [r2, #-1]!
 80066ca:	f811 7d01 	ldrb.w	r7, [r1, #-1]!
 80066ce:	45bc      	cmp	ip, r7
 80066d0:	4613      	mov	r3, r2
 80066d2:	d0f5      	beq.n	80066c0 <two_way_long_needle+0x1e4>
 80066d4:	9b01      	ldr	r3, [sp, #4]
 80066d6:	441d      	add	r5, r3
 80066d8:	e7c1      	b.n	800665e <two_way_long_needle+0x182>
 80066da:	464b      	mov	r3, r9
 80066dc:	e794      	b.n	8006608 <two_way_long_needle+0x12c>
 80066de:	bf00      	nop

080066e0 <strstr>:
 80066e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80066e4:	460d      	mov	r5, r1
 80066e6:	7809      	ldrb	r1, [r1, #0]
 80066e8:	b090      	sub	sp, #64	@ 0x40
 80066ea:	4604      	mov	r4, r0
 80066ec:	2900      	cmp	r1, #0
 80066ee:	d054      	beq.n	800679a <strstr+0xba>
 80066f0:	786a      	ldrb	r2, [r5, #1]
 80066f2:	2a00      	cmp	r2, #0
 80066f4:	f000 8082 	beq.w	80067fc <strstr+0x11c>
 80066f8:	78ab      	ldrb	r3, [r5, #2]
 80066fa:	2b00      	cmp	r3, #0
 80066fc:	d051      	beq.n	80067a2 <strstr+0xc2>
 80066fe:	78e8      	ldrb	r0, [r5, #3]
 8006700:	682e      	ldr	r6, [r5, #0]
 8006702:	2800      	cmp	r0, #0
 8006704:	f000 8081 	beq.w	800680a <strstr+0x12a>
 8006708:	792b      	ldrb	r3, [r5, #4]
 800670a:	2b00      	cmp	r3, #0
 800670c:	d056      	beq.n	80067bc <strstr+0xdc>
 800670e:	4628      	mov	r0, r5
 8006710:	f7fa f896 	bl	8000840 <strlen>
 8006714:	4606      	mov	r6, r0
 8006716:	f440 7100 	orr.w	r1, r0, #512	@ 0x200
 800671a:	4620      	mov	r0, r4
 800671c:	f000 f8c4 	bl	80068a8 <strnlen>
 8006720:	4286      	cmp	r6, r0
 8006722:	d85a      	bhi.n	80067da <strstr+0xfa>
 8006724:	2efe      	cmp	r6, #254	@ 0xfe
 8006726:	f200 8088 	bhi.w	800683a <strstr+0x15a>
 800672a:	1b80      	subs	r0, r0, r6
 800672c:	1827      	adds	r7, r4, r0
 800672e:	2240      	movs	r2, #64	@ 0x40
 8006730:	1c71      	adds	r1, r6, #1
 8006732:	4668      	mov	r0, sp
 8006734:	f7ff fd7c 	bl	8006230 <memset>
 8006738:	b17e      	cbz	r6, 800675a <strstr+0x7a>
 800673a:	1e6a      	subs	r2, r5, #1
 800673c:	fa5f fc86 	uxtb.w	ip, r6
 8006740:	1990      	adds	r0, r2, r6
 8006742:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8006746:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800674a:	3340      	adds	r3, #64	@ 0x40
 800674c:	446b      	add	r3, sp
 800674e:	1aa9      	subs	r1, r5, r2
 8006750:	4461      	add	r1, ip
 8006752:	4290      	cmp	r0, r2
 8006754:	f803 1c40 	strb.w	r1, [r3, #-64]
 8006758:	d1f3      	bne.n	8006742 <strstr+0x62>
 800675a:	3c01      	subs	r4, #1
 800675c:	5da3      	ldrb	r3, [r4, r6]
 800675e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8006762:	3340      	adds	r3, #64	@ 0x40
 8006764:	446b      	add	r3, sp
 8006766:	f813 3c40 	ldrb.w	r3, [r3, #-64]
 800676a:	441c      	add	r4, r3
 800676c:	42a7      	cmp	r7, r4
 800676e:	d203      	bcs.n	8006778 <strstr+0x98>
 8006770:	e038      	b.n	80067e4 <strstr+0x104>
 8006772:	4444      	add	r4, r8
 8006774:	42a7      	cmp	r7, r4
 8006776:	d335      	bcc.n	80067e4 <strstr+0x104>
 8006778:	f814 c006 	ldrb.w	ip, [r4, r6]
 800677c:	f00c 0c3f 	and.w	ip, ip, #63	@ 0x3f
 8006780:	f10c 0340 	add.w	r3, ip, #64	@ 0x40
 8006784:	eb0d 0c03 	add.w	ip, sp, r3
 8006788:	4632      	mov	r2, r6
 800678a:	4629      	mov	r1, r5
 800678c:	4620      	mov	r0, r4
 800678e:	f81c 8c40 	ldrb.w	r8, [ip, #-64]
 8006792:	f000 f85b 	bl	800684c <memcmp>
 8006796:	2800      	cmp	r0, #0
 8006798:	d1eb      	bne.n	8006772 <strstr+0x92>
 800679a:	4620      	mov	r0, r4
 800679c:	b010      	add	sp, #64	@ 0x40
 800679e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80067a2:	7800      	ldrb	r0, [r0, #0]
 80067a4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80067a8:	b1b8      	cbz	r0, 80067da <strstr+0xfa>
 80067aa:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 80067ae:	429a      	cmp	r2, r3
 80067b0:	4621      	mov	r1, r4
 80067b2:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 80067b6:	d1f7      	bne.n	80067a8 <strstr+0xc8>
 80067b8:	1e4c      	subs	r4, r1, #1
 80067ba:	e7ee      	b.n	800679a <strstr+0xba>
 80067bc:	7822      	ldrb	r2, [r4, #0]
 80067be:	b162      	cbz	r2, 80067da <strstr+0xfa>
 80067c0:	ba31      	rev	r1, r6
 80067c2:	e001      	b.n	80067c8 <strstr+0xe8>
 80067c4:	428b      	cmp	r3, r1
 80067c6:	d01e      	beq.n	8006806 <strstr+0x126>
 80067c8:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 80067cc:	4620      	mov	r0, r4
 80067ce:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 80067d2:	2a00      	cmp	r2, #0
 80067d4:	d1f6      	bne.n	80067c4 <strstr+0xe4>
 80067d6:	428b      	cmp	r3, r1
 80067d8:	d015      	beq.n	8006806 <strstr+0x126>
 80067da:	2400      	movs	r4, #0
 80067dc:	4620      	mov	r0, r4
 80067de:	b010      	add	sp, #64	@ 0x40
 80067e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80067e4:	5dbb      	ldrb	r3, [r7, r6]
 80067e6:	19b8      	adds	r0, r7, r6
 80067e8:	2b00      	cmp	r3, #0
 80067ea:	d0f6      	beq.n	80067da <strstr+0xfa>
 80067ec:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 80067f0:	f000 f85a 	bl	80068a8 <strnlen>
 80067f4:	4407      	add	r7, r0
 80067f6:	42a7      	cmp	r7, r4
 80067f8:	d2af      	bcs.n	800675a <strstr+0x7a>
 80067fa:	e7ee      	b.n	80067da <strstr+0xfa>
 80067fc:	b010      	add	sp, #64	@ 0x40
 80067fe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8006802:	f7ff bd67 	b.w	80062d4 <strchr>
 8006806:	1ec4      	subs	r4, r0, #3
 8006808:	e7c7      	b.n	800679a <strstr+0xba>
 800680a:	0412      	lsls	r2, r2, #16
 800680c:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8006810:	7821      	ldrb	r1, [r4, #0]
 8006812:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8006816:	2900      	cmp	r1, #0
 8006818:	d0df      	beq.n	80067da <strstr+0xfa>
 800681a:	4602      	mov	r2, r0
 800681c:	e001      	b.n	8006822 <strstr+0x142>
 800681e:	2900      	cmp	r1, #0
 8006820:	d0db      	beq.n	80067da <strstr+0xfa>
 8006822:	ea41 0002 	orr.w	r0, r1, r2
 8006826:	ebb3 2f00 	cmp.w	r3, r0, lsl #8
 800682a:	4625      	mov	r5, r4
 800682c:	ea4f 2200 	mov.w	r2, r0, lsl #8
 8006830:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8006834:	d1f3      	bne.n	800681e <strstr+0x13e>
 8006836:	1eac      	subs	r4, r5, #2
 8006838:	e7af      	b.n	800679a <strstr+0xba>
 800683a:	4601      	mov	r1, r0
 800683c:	4633      	mov	r3, r6
 800683e:	462a      	mov	r2, r5
 8006840:	4620      	mov	r0, r4
 8006842:	b010      	add	sp, #64	@ 0x40
 8006844:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8006848:	f7ff be48 	b.w	80064dc <two_way_long_needle>

0800684c <memcmp>:
 800684c:	2a03      	cmp	r2, #3
 800684e:	b430      	push	{r4, r5}
 8006850:	d915      	bls.n	800687e <memcmp+0x32>
 8006852:	ea41 0400 	orr.w	r4, r1, r0
 8006856:	07a4      	lsls	r4, r4, #30
 8006858:	4684      	mov	ip, r0
 800685a:	460b      	mov	r3, r1
 800685c:	d004      	beq.n	8006868 <memcmp+0x1c>
 800685e:	1e54      	subs	r4, r2, #1
 8006860:	e00f      	b.n	8006882 <memcmp+0x36>
 8006862:	3a04      	subs	r2, #4
 8006864:	2a03      	cmp	r2, #3
 8006866:	d908      	bls.n	800687a <memcmp+0x2e>
 8006868:	4619      	mov	r1, r3
 800686a:	4660      	mov	r0, ip
 800686c:	f853 4b04 	ldr.w	r4, [r3], #4
 8006870:	f85c 5b04 	ldr.w	r5, [ip], #4
 8006874:	42a5      	cmp	r5, r4
 8006876:	d0f4      	beq.n	8006862 <memcmp+0x16>
 8006878:	e7f1      	b.n	800685e <memcmp+0x12>
 800687a:	4660      	mov	r0, ip
 800687c:	4619      	mov	r1, r3
 800687e:	1e54      	subs	r4, r2, #1
 8006880:	b17a      	cbz	r2, 80068a2 <memcmp+0x56>
 8006882:	1e43      	subs	r3, r0, #1
 8006884:	3901      	subs	r1, #1
 8006886:	1902      	adds	r2, r0, r4
 8006888:	e001      	b.n	800688e <memcmp+0x42>
 800688a:	429a      	cmp	r2, r3
 800688c:	d009      	beq.n	80068a2 <memcmp+0x56>
 800688e:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8006892:	f811 cf01 	ldrb.w	ip, [r1, #1]!
 8006896:	4560      	cmp	r0, ip
 8006898:	d0f7      	beq.n	800688a <memcmp+0x3e>
 800689a:	eba0 000c 	sub.w	r0, r0, ip
 800689e:	bc30      	pop	{r4, r5}
 80068a0:	4770      	bx	lr
 80068a2:	2000      	movs	r0, #0
 80068a4:	bc30      	pop	{r4, r5}
 80068a6:	4770      	bx	lr

080068a8 <strnlen>:
 80068a8:	b171      	cbz	r1, 80068c8 <strnlen+0x20>
 80068aa:	4603      	mov	r3, r0
 80068ac:	eb00 0c01 	add.w	ip, r0, r1
 80068b0:	e001      	b.n	80068b6 <strnlen+0xe>
 80068b2:	4563      	cmp	r3, ip
 80068b4:	d006      	beq.n	80068c4 <strnlen+0x1c>
 80068b6:	461a      	mov	r2, r3
 80068b8:	3301      	adds	r3, #1
 80068ba:	7811      	ldrb	r1, [r2, #0]
 80068bc:	2900      	cmp	r1, #0
 80068be:	d1f8      	bne.n	80068b2 <strnlen+0xa>
 80068c0:	1a10      	subs	r0, r2, r0
 80068c2:	4770      	bx	lr
 80068c4:	1a18      	subs	r0, r3, r0
 80068c6:	4770      	bx	lr
 80068c8:	4608      	mov	r0, r1
 80068ca:	4770      	bx	lr
